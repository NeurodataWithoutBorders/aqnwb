/**
 *
 * \page registered_type_page Implementing a new Neurodata Type
 *
 * \tableofcontents
 *
 *
 *
 * New neurodata_types typically inherit from at least either \ref AQNWB::NWB::Container "Container"
 * or \ref AQNWB::NWB::Data "Data", or a more specialized type of the two. In any case,
 * all classes that represent a ``neurodata_type`` defined in the schema should be implemented
 * as a subtype of \ref AQNWB::NWB::RegisteredType "RegisteredType".
 *
 * @section implement_registered_type How to Implement a RegisteredType
 *
 * To implement a subclass of \ref AQNWB::NWB::RegisteredType "RegisteredType", follow these steps:
 *
 * 1. Include the `RegisteredType.h` header file in your subclass header file.
 *    @code
 *    #include "nwb/RegisteredType.hpp"
 *    @endcode
 *
 * 2. Define your subclass by inheriting from \ref AQNWB::NWB::RegisteredType "RegisteredType".
 *    Ensure that your subclass implements a constructor with the arguments `(const std::string& path, std::shared_ptr<IO::BaseIO> io)`,
 *    as the "create" method expects this constructor signature.
 *    @code
 *    class MySubClass : public AQNWB::NWB::RegisteredType {
 *    public:
 *        MySubClass(const std::string& path, std::shared_ptr<IO::BaseIO> io)
 *            : RegisteredType(path, io) {}
 *
 *        // Implement any additional methods or overrides here
 *    };
 *    @endcode
 *
 * 3. Use the `REGISTER_SUBCLASS` macro to register your subclass. This should usually appear in the header (`hpp`) file as part of the class definition.
 *    @code
 *    REGISTER_SUBCLASS(MySubClass, "my-namespace")
 *    @endcode
 *
 * 4. In the corresponding source (`cpp`) file, initialize the static member to trigger the registration.
 *    @code
 *    #include "MySubClass.h"
 *
 *    // Initialize the static member to trigger registration
 *    REGISTER_SUBCLASS_IMPL(MySubClass)
 *    @endcode
 *
 * \warning
 * To ensure proper function on read, the name of the class should match the name of the
 * ``neurodata_type`` as defined in the schema. Similarly, "my-namespace" should match
 * the name of the namespace in the schema (e.g., "core", "hdmf-common"). In this way
 * we can look up the corresponding class for an object in a file based on the
 * ``neurodata_type`` and ``namespace`` attributes stored in the file.
 *
 *
 * **Example:**
 *
 * *MySubClass.h*
 * @code
 * #pragma once
 * #include "RegisteredType.h"
 *
 * class MySubClass : public AQNWB::NWB::RegisteredType {
 * public:
 *     MySubClass(const std::string& path, std::shared_ptr<IO::BaseIO> io)
 *         : RegisteredType(path, io) {}
 *
 *     void doSomething() const override {
 *         std::cout << "MySubClass doing something!" << std::endl;
 *     }
 *
 *     REGISTER_SUBCLASS(MySubClass, "my-namespace")
 * };
 * @endcode
 *
 * *MySubClass.cpp*
 * @code
 * #include "MySubClass.h"
 *
 * // Initialize the static member to trigger registration
 * REGISTER_SUBCLASS_IMPL(MySubClass)
 * @endcode
 *
 * @section type_registry How the Type Registry in RegisteredType Works
 *
 * The type registry in \ref AQNWB::NWB::RegisteredType "RegisteredType" allows for dynamic creation of registered subclasses by name. Here is how it works:
 *
 * 1. **Registry Storage**:
 *    - The registry is implemented using 1) an `std::unordered_set` to store subclass names (which can be
 *      accessed via \ref AQNWB::NWB::RegisteredType::getRegistry "getRegistry()") and
 *      2) an `std::unordered_map` to store factory functions for creating instances of the subclasses
 *      (which can be accessed via \ref AQNWB::NWB::RegisteredType::getFactoryMap() "getFactoryMap()").
 *      The factory methods are the required constructor that uses the io and path as input.
 *    - These are defined as static members within the \ref AQNWB::NWB::RegisteredType "RegisteredType" class.
 *
 * 2. **Registration**:
 *    - The \ref AQNWB::NWB::RegisteredType::registerSubclass "registerSubclass" method is used to add a
 *      subclass name and its corresponding factory function to the registry.
 *    - This method is called via the `REGISTER_SUBCLASS` macro, which defines a static method (`registerSubclass()`)
 *      and static member (`registered_`) to trigger the registration when the subclass is loaded.
 *
 * 3. **Dynamic Creation**:
 *    - The \ref AQNWB::NWB::RegisteredType::create "create" method is used to create an instance of a registered subclass by name.
 *    - This method looks up the subclass name in the registry and calls the corresponding factory function to create an instance.
 *
 * 4. **Automatic Registration**:
 *    - The `REGISTER_SUBCLASS_IMPL` macro initializes the static member (`registered_`), which triggers the
 *      \ref AQNWB::NWB::RegisteredType::registerSubclass "registerSubclass" method
 *      and ensures that the subclass is registered when the program starts.
 *
 * 5. **Class Name and Namespace Retrieval**:
 *    - The \ref AQNWB::NWB::RegisteredType::getTypeName "getTypeName" and \ref AQNWB::NWB::RegisteredType::getNamespace "getNamespace" methods are `final` functions
 *      in \ref AQNWB::NWB::RegisteredType "RegisteredType" that return the name and namespace of the class type as strings.
 *      These methods cannot be overridden by subclasses, ensuring consistency in type identification.
 *
 *
 *
 * @section use_registered_type_registry How to Use the RegisteredType Registry
 *
 * The \ref AQNWB::NWB::RegisteredType "RegisteredType" registry allows for dynamic creation and management of registered subclasses. Here is how you can use it:
 *
 * 1. **Creating Instances Dynamically**:
 *    - Use the \ref AQNWB::NWB::RegisteredType::create "create" method to create an instance of a registered subclass by name.
 *    - This method takes the subclass name, path, and a shared pointer to the IO object as arguments. This
 *      illustrates how we can read a specific typed object in an NWB file.
 *    \snippet tests/examples/test_RegisteredType_example.cpp example_RegisterType_get_type_instance
 *
 * 2. **Retrieving Registered Subclass Names**:
 *    - Use the \ref AQNWB::NWB::RegisteredType::getRegistry "getRegistry" method to retrieve the
 *      set of registered subclass names.
 *      \snippet tests/examples/test_RegisteredType_example.cpp example_RegisterType_get_registered_names
 *
 * 3. **Retrieving the Factory Map**:
 *    - Use the \ref AQNWB::NWB::RegisteredType::getFactoryMap "getFactoryMap" method to retrieve
 *      the map of factory functions for creating instances of registered subclasses.
 *      \snippet tests/examples/test_RegisteredType_example.cpp example_RegisterType_get_registered_factories
 *
 * **Full Example**
 *
 *  \snippet tests/examples/test_RegisteredType_example.cpp example_RegisterType_full
 */