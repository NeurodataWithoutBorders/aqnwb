/**
 *
 * \page register_namespace_page Integrating NWB Extensions
 *
 * \tableofcontents
 *
 * @section integrate_namespace How to Integrate a New Namespace
 *
 * Integrating a new schema namespace with AqNWB (e.g., to support an extension to NWB) involves generating
 * the necessary specification files and ensuring that the namespace is registered with the 
 * \ref AQNWB::SPEC::NamespaceRegistry "NamespaceRegistry". This process is simplified through 
 * the use of the `generate_spec_files.py` script.
 *
 * 1. **Get the schema files**: Download or create the schema for the namespace in JSON or YAML format. 
 *    @note 
 *    If you are creating a new extension, please see the
 *    [NWB Extension Tutorial](https://nwb-overview.readthedocs.io/en/latest/extensions_tutorial/extensions_tutorial_home.html)
 *    for more information on how to create data schema for NWB. 
 * 
 * 2. **Convert the schema files to C++**: Run the `resources/generate_spec_files.py` script on your
 *    schema files to generate the necessary C++ header files. This script processes the schema and creates 
 *    the appropriate C++ header files that include the namespace definitions and registration. 
 *    @note
 *    To learn more about how to use the script and its parameters, you can view the help doc by running:
 *    @code 
 *    python resources/generate_spec_files.py --help
 *    @endcode
 *
 * 3. **Include the Generated Header Files**: In your C++ code that uses AqNWB, include the generated header files. The 
 *    header files will automatically take care of registering the namespace with the \ref AQNWB::SPEC::NamespaceRegistry "NamespaceRegistry"
 *    by calling the \ref REGISTER_NAMESPACE macro.  Once the extension has been registered, 
 *    \ref AQNWB::NWB::NWBFile::initialize "NWBFile::initialize" will automatically take care of caching 
 *    your schema in the NWB file when creating a new file. 
 *
 * 4. **Implement appropriate RegisteredType classes**: Follow the tutorial on
 *    \ref registered_type_page to define appropriate interfaces for the `neurodata_type`s defined in your new namespace. 
 *
 * @section namespace_registry How the NamespaceRegistry Works
 *
 * The \ref AQNWB::SPEC::NamespaceRegistry "NamespaceRegistry" is a singleton class that manages the 
 * registration and lookup of namespace information. 
 *
 * @subsection register_namespace Registering a Namespace
 *
 * The \ref REGISTER_NAMESPACE macro is used to register a namespace with the \ref AQNWB::SPEC::NamespaceRegistry "NamespaceRegistry".
 * This macro is typically placed in the generated header file for the namespace schema and ensures that
 * the namespace is registered when the header file is included. For example:
 * @code
 * REGISTER_NAMESPACE("your_namespace", "1.0.0", specVariables);
 * @endcode
 * would register the namespace `your_namespace` with version `1.0.0` and the specified `specVariables`.
 *
 * @subsection namespace_lookup Looking up Namespaces
 *
 * To retrieve information about a registered namespace, we can use the \ref AQNWB::SPEC::NamespaceRegistry::getNamespaceInfo "getNamespaceInfo" 
 * method. For example:
 * 
 * @code
 * const NamespaceInfo* info = NamespaceRegistry::instance().getNamespaceInfo("your_namespace");
 * if (info) {
 *     // Use the namespace information
 * }
 * @endcode
 *
 * Alternatively, we can also use \ref AQNWB::SPEC::NamespaceRegistry::getAllNamespaces "getAllNamespaces" 
 * to get a reference to all registered namespaces. For example:
 * @code
 * const auto& allNamespaces = NamespaceRegistry::instance().getAllNamespaces();
 * for (const auto& [name, info] : allNamespaces) {
 *     // Process each namespace
 * }
 * @endcode
 *
 * The returned `info` object is, in both cases, a \ref AQNWB::Types::NamespaceInfo "NamespaceInfo" struct
 * with the name, version, and specVariables. 
 */