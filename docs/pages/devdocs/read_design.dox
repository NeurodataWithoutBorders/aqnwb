/**
 * \page read_design_page Implementation of data read
 *
 * \tableofcontents
 *
 * The read system in AqNWB is built around several key concepts:
 * 
 * 1. Lazy loading through wrapper objects
 * 2. Dynamic type creation through a registration system
 * 3. Field access through generated accessor methods
 *
 * \section read_design_sec_read_date Reading datasets and attributes
 *
 * AqNWB reads datasets and attributes lazyly via wrappers. To create \ref AQNWB::IO::ReadDataWrapper "ReadDataWrapper" 
 * objects for reading datasets and attributes, a user will typically 
 * use either pre-definied read methods created via the \ref DEFINE_FIELD
 * macro (see also \ref use_the_define_field_macro) or the \ref AQNWB::NWB::RegisteredType::readField "RegisteredType::readField" 
 * method. The main components involved in reading data from an NWB file via AqNWB are:
 *
 * - \ref AQNWB::IO::BaseIO "BaseIO", \ref AQNWB::IO::HDF5::HDF5IO "HDF5IO" responsible for
 *   reading data from disk and allocating memory for data on read
 * - \ref AQNWB::IO::DataBlockGeneric "DataBlockGeneric" represents a generic, n-dimensional block of data
 *   loaded from a file, storing the data as a generic ``std::any`` along with the ``shape`` of the data
 * - \ref AQNWB::IO::DataBlock "DataBlock" represents a typed, n-dimensional block of data, derived
 *   from a \ref AQNWB::IO::DataBlockGeneric "DataBlockGeneric"
 * - \ref AQNWB::IO::ReadDataWrapper "ReadDataWrapper", is a simple wrapper class that represents
 *   a dataset/attribute for read, enabling lazy data read and allowing for transparent use of different I/O backends
 * - \ref AQNWB::NWB::Container "Container" type classes represent Groups with an assigned ``neurodata_type``
 *   in the NWB format. 
 *
 * The following figure provides an overview of these main classes involved with reading data from a dataset or attribute.
 *
 * @dot
 * digraph G {
 *     node [shape=none];
 *
 *     HDF5IO [
 *         label=<
 *             <table border="0" cellborder="1" cellspacing="0">
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>HDF5IO</b></td></tr>
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Functions</b></td></tr>
 *                 <tr><td align="left">+ readDataset(): DataBlockGeneric</td></tr>
 *                 <tr><td align="left">+ readAttribute(): DataBlockGeneric</td></tr>
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Attributes</b></td></tr>
 *             </table>
 *         >
 *     ];
 *
 *     NWBFile [
 *         shape=note,
 *         label="NWB file (HDF5)"
 *     ];
 *
 *     DataBlockGeneric [
 *         label=<
 *             <table border="0" cellborder="1" cellspacing="0">
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>DataBlockGeneric</b></td></tr>
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Functions</b></td></tr>
 *                 <tr><td align="left">+ getData(): void</td></tr>
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Attributes</b></td></tr>
 *                 <tr><td align="left">+ data: std::any</td></tr>
 *                 <tr><td align="left">+ shape: std::vector&lt;SizeType&gt;</td></tr>
 *             </table>
 *         >
 *     ];
 *
 *     ReadDataWrapper [
 *         label=<
 *             <table border="0" cellborder="1" cellspacing="0">
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>ReadDataWrapper</b></td></tr>
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Functions</b></td></tr>
 *                 <tr><td align="left">+ valuesGeneric(): DataBlockGeneric</td></tr>
 *                 <tr><td align="left">+ values(): DataBlock</td></tr>
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Attributes</b></td></tr>
 *                 <tr><td align="left">+ io: const std::shared_ptr&lt;BaseIO&gt;</td></tr>
 *                 <tr><td align="left">+ dataPath: std::string</td></tr>
 *             </table>
 *         >
 *     ];
 *
 *     DataBlock [
 *         label=<
 *             <table border="0" cellborder="1" cellspacing="0">
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>DataBlock</b></td></tr>
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Functions</b></td></tr>
 *                 <tr><td align="left">+ fromGeneric(): DataBlock</td></tr>
 *                 <tr><td align="left">+ as_multi_array(): MultiArray</td></tr>
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Attributes</b></td></tr>
 *                 <tr><td align="left">+ data: std::vector&lt;DTYPE&gt;</td></tr>
 *                 <tr><td align="left">+ shape: std::vector&lt;SizeType&gt;</td></tr>
 *             </table>
 *         >
 *     ];
 *
 *     Container [
 *         label=<
 *             <table border="0" cellborder="1" cellspacing="0">
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Container</b></td></tr>
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Attributes</b></td></tr>
 *                 <tr><td align="left">+ io: std::shared_ptr&lt;BaseIO&gt;</td></tr>
 *                 <tr><td align="left">+ path: std::string</td></tr>
 *             </table>
 *         >
 *     ];
 *
 *     { rank=same; Container; }
 *     { rank=same; DataBlock; ReadDataWrapper; DataBlockGeneric; }
 *     { rank=same; HDF5IO; }
 *     { rank=same; NWBFile; }
 *
 *     Container -> ReadDataWrapper [label="create"];
 *     ReadDataWrapper -> DataBlockGeneric [label="return\ndata"];
 *     ReadDataWrapper -> DataBlock [label="return\ndata"];
 *     DataBlock -> DataBlockGeneric [label="created\nfrom"];
 *     ReadDataWrapper -> HDF5IO [label="call readDataset\nor readAttribute"];
 *     HDF5IO -> NWBFile [label="read data"];
 * }
 * @enddot
 *
 * \section reading_neurodata_type_objects Reading neurodata_type objects 
 *
 * NWB `neurodata_types` are represented in AqNWB as classes that inherit from 
 * \ref AQNWB::NWB::RegisteredType "RegisteredType" (see also \ref registered_type_page). 
 * \ref AQNWB::NWB::RegisteredType "RegisteredType" in turn maintains a registry of all 
 * available registered types that it uses to support convenient read of `neurodata_type`
 * objects from an NWB file. For read, a user then typically uses either: 
 * -  Pre-defined read methods created via the \ref DEFINE_REGISTERED_FIELD macro
 *    (see also \ref use_the_define_registered_field_macro).
 * - \ref AQNWB::NWB::RegisteredType::readField "RegisteredType::readField"  to read 
 *    arbitrary registered fields.
 * - \ref AQNWB::NWB::RegisteredType::create "RegisteredType::create" to manually create
 *    a \ref AQNWB::NWB::RegisteredType "RegisteredType" from a file.
 * - Construct the specific class directly using a known `path` and `io` object.
 *
 *
 * \subsection type_registry How the Type Registry in RegisteredType Works
 *
 * The type registry in \ref AQNWB::NWB::RegisteredType "RegisteredType" allows for dynamic 
 * creation of registered subclasses by name. Here is how it works:
 *
 * 1. **Registry Storage**:
 *    - The registry is stored as  static members within the \ref AQNWB::NWB::RegisteredType "RegisteredType" class
 *      and is implemented using 1) an `std::unordered_set` to store subclass names (which can be
 *      accessed via \ref AQNWB::NWB::RegisteredType::getRegistry "getRegistry()") and
 *      2) an `std::unordered_map` to store factory functions for creating instances of the subclasses
 *      (which can be accessed via \ref AQNWB::NWB::RegisteredType::getFactoryMap() "getFactoryMap()").
 *      The factory methods are the required constructor that uses the io and path as input.
 *
 * 2. **Preparing for Registration**: \ref REGISTER_SUBCLASS
 *    - The \ref REGISTER_SUBCLASS macro macro modifies the class to make it ready for registration by:
 *      - Creating the `_registered` field to trigger the registration when the subclass is loaded
 *      - Defining a static method \ref AQNWB::NWB::RegisteredType::registerSubclass "registerSubclass", which 
 *        is used to add a subclass name and its corresponding factory function to the registry.
 *      - Adding `getTypeName` and `getNamespace` functions for defining the `neurodata_type` name
 *    - \ref REGISTER_SUBCLASS_WITH_TYPENAME is a special version of  the \ref REGISTER_SUBCLASS macro, which
 *      allows setting the typename explicitly as a third argument. This is for the **special case**
 *      where the name of the class cannot be the same as the name of the type (see 
 *      also \ref using_registered_subclass_with_typename)
 *
 * 3. **Actual automatic Registration**: \ref REGISTER_SUBCLASS_IMPL
 *    - The \ref REGISTER_SUBCLASS_IMPL macro initializes the static member (`registered_`), which triggers the
 *      \ref AQNWB::NWB::RegisteredType::registerSubclass "registerSubclass" method
 *      and ensures that the subclass is registered when the program starts.
 *
 * 4. **Dynamic Creation**:
 *    - The \ref AQNWB::NWB::RegisteredType::create "RegisteredType::create" method is used to create
 *      an instance of a registered subclass by name. This method looks up the subclass name in the 
 *      registry and calls the corresponding factory function to create an instance.
 *
 * 5. **Class Name and Namespace Retrieval**:
 *    - The \ref AQNWB::NWB::RegisteredType::getTypeName "getTypeName" and
 *      \ref AQNWB::NWB::RegisteredType::getNamespace "getNamespace" return the string name of the
 *      class and namespace, respectively. The `REGISTER_SUBCLASS` macro implements an automatic
 *      override of the methods to ensure the appropriate type and namespace string are returned.
 *      These methods should, hence, not be manually overridden by subclasses, to ensure consistency
 *      in type identification.
 *
 *
 * \subsection use_registered_type_registry How to Use the RegisteredType Registry
 *
 * The \ref AQNWB::NWB::RegisteredType "RegisteredType" registry allows for dynamic creation and management 
 * of registered subclasses. Here is how you can use it:
 *
 * 1. **Creating Instances Dynamically**:
 *    - Use the \ref AQNWB::NWB::RegisteredType::create "create" method to create an instance of a registered subclass by name.
 *    - This method takes the subclass name, path, and a shared pointer to the IO object as arguments. This
 *      illustrates how we can read a specific typed object in an NWB file.
 *    \snippet tests/examples/test_RegisteredType_example.cpp example_RegisterType_get_type_instance
 *
 * 2. **Retrieving Registered Subclass Names**:
 *    - Use the \ref AQNWB::NWB::RegisteredType::getRegistry "getRegistry" method to retrieve the
 *      set of registered subclass names.
 *      \snippet tests/examples/test_RegisteredType_example.cpp example_RegisterType_get_registered_names
 *
 * 3. **Retrieving the Factory Map**:
 *    - Use the \ref AQNWB::NWB::RegisteredType::getFactoryMap "getFactoryMap" method to retrieve
 *      the map of factory functions for creating instances of registered subclasses.
 *      \snippet tests/examples/test_RegisteredType_example.cpp example_RegisterType_get_registered_factories
 *
 * \subsection read_design_templates Reading templated RegisteredType classes
 *
 * AqNWB uses templated classes to handle data types in a type-safe way while maintaining flexibility. The two main
 * templated neurodata_type classes are \ref AQNWB::NWB::VectorData "VectorData<DTYPE>" and 
 * \ref AQNWB::NWB::Data "Data<DTYPE>" (see also \ref implement_templated_registered_type). 
 * For example:
 *
 * ```cpp
 * // Reading a VectorData field
 * auto genericVector = RegisteredType::create("hdmf-common::VectorData", path, io);
 * auto typedVector = std::dynamic_pointer_cast<VectorData<double>>(genericVector);
 * ```
 *
 * Here the NWB file contains only the base `neurodata_type`information (e.g., "VectorData")
 * without the template information. On read, the system then creates the generic instance using `std::any` 
 * that the users can then cast to specific types as needed using the templated interfaces.
 * However, note that in the \ref DEFINE_FIELD  macro, we can directly use the more specialized types,
 * e.g., ``VectorData<int>``, such that for autogenerated read methods, a user often does
 * not need to cast to the more specific type or specify the data type.
 *
 * \subsection use_registered_type_registry_example Example: Using the type registry
 *
 * \snippet tests/examples/test_RegisteredType_example.cpp example_RegisterType_full
 *
 * \section read_design_example Example Implementation Details
 *
 * For implementation examples and detailed code snippets, see the following sections:
 *
 * \subsection read_design_example_create Creating and Writing Data
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_mockdata_snippet
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_create_file_snippet
 *
 * \subsection read_design_example_read Reading and Processing Data
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_get_data_wrapper_snippet
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_check_data_exists_snippet
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_get_datablock_snippet
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_validate_datablock_snippet
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_get_boostarray_snippet
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_validate_boostarray_snippet
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_attribute_snippet
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_get_data_wrapper_as_generic_snippet
 */
