/**
 * \page read_page Reading data
 *
 * \tableofcontents
 *
 * \section read_design_intro Introduction
 *
 * Reading data from an open NWB file via AqNWB consists of two main steps. In the
 * first step we retrieve a wrapper object that provides lazy read access to the
 * particular dataset or attribute:
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_get_data_wrapper_snippet
 *
 * In the second step we then request the parts of the data we are interested in,
 * at which point the data is being loaded from disk.
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_get_datablock_snippet
 *
 * In the following sections we dive deeper into the \ref read_design_sec, describing
 * the different classes involved in reading data and their responsibilities. We then
 * show a more detailed \ref read_design_example to illustrate how read works in the
 * overall context of data acquisition.
 *
 *
 * \section read_design_sec Software Design
 *
 * The following figure shows the main classes involved with reading data from a dataset.
 * Reading data from an attribute works much in the same way, but  \ref AQNWB::ReadDatasetWrapper "ReadDatasetWrapper"
 * is replaced with  \ref AQNWB::ReadAttributeWrapper "ReadAttributeWrapper".
 *
 * @dot
 * digraph G {
 *     node [shape=none];
 *
 *     HDF5IO [
 *         label=<
 *             <table border="0" cellborder="1" cellspacing="0">
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>HDF5IO</b></td></tr>
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Functions</b></td></tr>
 *                 <tr><td align="left">+ readDataset(): DataBlockGeneric</td></tr>
 *                 <tr><td align="left">+ readAttribute(): DataBlockGeneric</td></tr>
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Attributes</b></td></tr>
 *             </table>
 *         >
 *     ];
 *
 *     NWBFile [
 *         shape=note,
 *         label="NWB file (HDF5)"
 *     ];
 *
 *     DataBlockGeneric [
 *         label=<
 *             <table border="0" cellborder="1" cellspacing="0">
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>DataBlockGeneric</b></td></tr>
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Functions</b></td></tr>
 *                 <tr><td align="left">+ getData(): void</td></tr>
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Attributes</b></td></tr>
 *                 <tr><td align="left">+ data: std::any</td></tr>
 *                 <tr><td align="left">+ shape: std::vector&lt;SizeType&gt;</td></tr>
 *             </table>
 *         >
 *     ];
 *
 *     ReadDatasetWrapper [
 *         label=<
 *             <table border="0" cellborder="1" cellspacing="0">
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>ReadDatasetWrapper</b></td></tr>
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Functions</b></td></tr>
 *                 <tr><td align="left">+ valuesGeneric(): DataBlockGeneric</td></tr>
 *                 <tr><td align="left">+ values(): DataBlock</td></tr>
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Attributes</b></td></tr>
 *                 <tr><td align="left">+ io: const std::shared_ptr&lt;BaseIO&gt;</td></tr>
 *                 <tr><td align="left">+ dataPath: std::string</td></tr>
 *             </table>
 *         >
 *     ];
 *
 *     DataBlock [
 *         label=<
 *             <table border="0" cellborder="1" cellspacing="0">
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>DataBlock</b></td></tr>
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Functions</b></td></tr>
 *                 <tr><td align="left">+ fromGeneric(): DataBlock</td></tr>
 *                 <tr><td align="left">+ as_multi_array(): MultiArray</td></tr>
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Attributes</b></td></tr>
 *                 <tr><td align="left">+ data: std::vector&lt;DTYPE&gt;</td></tr>
 *                 <tr><td align="left">+ shape: std::vector&lt;SizeType&gt;</td></tr>
 *             </table>
 *         >
 *     ];
 *
 *     Container [
 *         label=<
 *             <table border="0" cellborder="1" cellspacing="0">
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Container</b></td></tr>
 *                 <tr><td colspan="2" bgcolor="lightgray"><b>Attributes</b></td></tr>
 *                 <tr><td align="left">+ io: std::shared_ptr&lt;BaseIO&gt;</td></tr>
 *                 <tr><td align="left">+ path: std::string</td></tr>
 *             </table>
 *         >
 *     ];
 *
 *     { rank=same; Container; }
 *     { rank=same; DataBlock; ReadDatasetWrapper; DataBlockGeneric; }
 *     { rank=same; HDF5IO; }
 *     { rank=same; NWBFile; }
 *
 *     Container -> ReadDatasetWrapper [label="create"];
 *     ReadDatasetWrapper -> DataBlockGeneric [label="return\ndata"];
 *     ReadDatasetWrapper -> DataBlock [label="return\ndata"];
 *     DataBlock -> DataBlockGeneric [label="created\nfrom"];
 *     ReadDatasetWrapper -> HDF5IO [label="call readDataset"];
 *     HDF5IO -> NWBFile [label="read data"];
 * }
 * @enddot
 *
 *
 * The main components involved in reading data from an NWB file via AqNWB are:
 *
 * - \ref AQNWB::BaseIO "BaseIO", \ref AQNWB::HDF5::HDF5IO "HDF5IO" responsible for
 *   reading data from disk and allocating memory for data on read
 * - \ref AQNWB::DataBlockGeneric "DataBlockGeneric" represents a generic, n-dimensional block of data
 *   loaded from a file, storing the data as a generic ``std::any`` along with the ``shape`` of the data.
 *   - \ref AQNWB::DataBlock "DataBlock" represents a typed, n-dimensional block of data, derived
 *     from a \ref AQNWB::DataBlockGeneric "DataBlockGeneric"
 * - \ref AQNWB::ReadDatasetWrapper "ReadDatasetWrapper", \ref AQNWB::ReadAttributeWrapper "ReadAttributeWrapper"
 *   are simple wrapper classes (based on \ref AQNWB::ReadDataWrapperBase "ReadDataWrapperBase") that  represent
 *   a dataset/attribute for read, enabling lazy data read and allowing for transparent use of different I/O backends.
 * - \ref AQNWB::NWB::Container "Container" type classes represent Groups with an assigned ``neurodata_type``
 *   in the NWB format, and are responsible for providing access to the datasets/attributes that they own.
 *   To provide access, these classes create \ref AQNWB::ReadDatasetWrapper "ReadDatasetWrapper" /
 *   \ref AQNWB::ReadAttributeWrapper "ReadAttributeWrapper" objects for the user for lazy read access to the data.
 *
 * We will discuss these different components in a bit more detail next.
 *
 * \subsection read_design_wrapper_container Container
 *
 * The \ref AQNWB::NWB::Container "Container" class (e.g., \ref AQNWB::NWB::ElectricalSeries "ElectricalSeries"
 * or  \ref AQNWB::NWB::NWBFile "NWBFile") is responsible for exposing read access to it's
 * specific datasets and attributes by providing appropriate access functions, which return
 * \ref AQNWB::ReadDatasetWrapper "ReadDatasetWrapper" or \ref AQNWB::ReadAttributeWrapper "ReadAttributeWrapper"
 * objects for lazily reading from the dataset/attribute.
 *
 * \subsection read_design_wrapper_propos ReadDatasetWrapper and ReadAttributeWrapper
 *
 * The  \ref AQNWB::ReadDatasetWrapper "ReadDatasetWrapper" stores a shared pointer
 * \ref AQNWB::ReadDatasetWrapper::io "io" to the  I/O object and the
 * \ref AQNWB::ReadDatasetWrapper::dataPath "dataPath" to the dataset.
 *
 * The \ref AQNWB::ReadDatasetWrapper::valuesGeneric "valuesGeneric" method then allows us
 * to read all or parts of the dataset into memory as ``std::any``. This function uses
 * the \ref AQNWB::BaseIO::readDataset "readDataset" method of the I/O backend
 * (e.g.,  \ref AQNWB::HDF5::HDF5IO::readDataset "HDF5IO.readDataset") to load the data.
 * The I/O backend in turn takes care of allocating the memory for the
 * appropriate data type and loading the data from disk.
 *
 * We can retrieve data directly with the appropriate type  by using the templated
 * \ref AQNWB::ReadDatasetWrapper::values "values" function instead, which
 * uses  \ref AQNWB::ReadDatasetWrapper::valuesGeneric "valuesGeneric" and then
 * automatically casts the data to a typed  \ref AQNWB::DataBlock "DataBlock<DTYPE>"
 * instead of returning an untyped  \ref AQNWB::DataBlock "DataBlockGeneric".
 *
 * \note
 * \ref AQNWB::ReadAttributeWrapper "ReadAttributeWrapper" works much in the same
 * way as \ref AQNWB::ReadDatasetWrapper "ReadDatasetWrapper" but does not support
 * slicing, i.e., attributes are always loaded fully into memory since attributes
 * are intended for small data only.
 *
 * \note
 * \ref AQNWB::ReadDatasetWrapper "ReadDatasetWrapper" and \ref AQNWB::ReadAttributeWrapper "ReadAttributeWrapper"
 * both inherit from \ref AQNWB::ReadDataWrapperBase "ReadDataWrapperBase".
 *
 *
 * \subsection read_design_data_block DataBlockGeneric and DataBlock
 *
 * At first, data values are always represented as a \ref AQNWB::DataBlockGeneric "DataBlockGeneric"
 * object, which stores the \ref AQNWB::DataBlockGeneric::data "data" as ``std::any``
 * along with the  \ref AQNWB::DataBlockGeneric::shape "shape" of the data. For example,
 * \ref AQNWB::ReadDatasetWrapper::valuesGeneric "ReadDatasetWrapper.valuesGeneric"
 * and \ref AQNWB::HDF5::HDF5IO::readDataset "HDF5IO.readDataset" return
 * a  \ref AQNWB::DataBlockGeneric "DataBlockGeneric". This has the advantage that
 * we can let the backend handle memory allocation and typing for us and load data
 * even if we don't know the type yet.
 *
 * \subsubsection read_design_data_block_typed DataBlock with typed data
 *
 * To cast the data to the appropriate specific type (e.g., ``float``) we can then create a
 * \ref AQNWB::DataBlock "DataBlock" with the appropriate data type via the
 * \ref AQNWB::DataBlock::fromGeneric "DataBlock.fromGeneric" factory method. \ref AQNWB::DataBlock "DataBlock"
 * is templated on the specific data type, i.e., we call ``DataBlock<float>.fromGeneric(myGenericDataBlock)``.
 * \ref AQNWB::DataBlock "DataBlock" then stores the \ref AQNWB::DataBlock::data "data" as an
 * appropriately typed 1-dimensional ``std::vector`` along with the \ref AQNWB::DataBlock::shape "shape"
 * of the data.
 *
 * \note
 * The \ref AQNWB::DataBlock::fromGeneric "DataBlock.fromGeneric" (and
 * \ref AQNWB::DataBlock::as_multi_array "DataBlock.as_multi_array") use casting
 * and referencing to transform the data without making additional copies
 * of the data.
 *
 * \subsubsection read_design_data_block_multiarray Using Boost Multi Array for N-Dimensional Data
 *
 * To simplify access to multi-dimensional data, we can then represent the data
 * as a ``BOOST::multi_array``. The \ref AQNWB::DataBlock::as_multi_array "DataBlock.as_multi_array"
 * convenience method generates a ``boost::const_multi_array_ref<DTYPE, NDIMS>`` for us.
 * Here the  ``DTYPE`` template parameter is the same as for the \ref AQNWB::DataBlock "DataBlock"
 * (so that we don't have to specify it again), and the ``NDIMS`` template parameter
 * is the number of dimensions (which is the same as \ref AQNWB::DataBlock::shape "shape.size()").
 *
 * \note
 * Since we are in a strongly typed language, we here need to know the ``DTYPE`` at compile time
 * when using \ref AQNWB::DataBlock "DataBlock". And if we want to use the
 * \ref AQNWB::DataBlock::as_multi_array "DataBlock.as_multi_array", then we also need to know
 * the number of dimensions ``NDIMS`` at compile time.
 *
 *
 * \subsection read_design_wrapper_io I/O
 *
 * The I/O backend is responsible for implementing the actual
 * \ref AQNWB::BaseIO::readDataset "readDataset" and \ref AQNWB::BaseIO::readAttribute "readAttribute"
 * methods used for reading data from disk. The methods are also responsible for
 * allocating appropriate memory with the respective data type. The functions
 * return the data as \ref AQNWB::DataBlockGeneric "DataBlockGeneric", which
 * stores the data as untyped ``std::any``. The user can then cast the
 * data to the appropriate type as discussed in \ref read_design_data_block_typed.
 *
 *
 *
 * \section read_design_example Example
 *
 * \subsection read_design_example_create Create a NWB file as usual
 *
 * \paragraph read_design_example_step_1 Setup mock data for write
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_mockdata_snippet
 *
 * \paragraph read_design_example_step_1_2 Create the NWBFile and record data
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_create_file_snippet
 *
 * \subsection read_design_example_read_during Read data during recording
 *
 * \paragraph read_design_example_laxy_read Lazy data access
 *
 * All data read is implemented lazily, i.e., AqNWB does not load data into memory
 * until we make a request to do so. To access data lazily, datasets and attributes are
 * wrapped via \ref AQNWB::ReadDatasetWrapper and \ref AQNWB::ReadAttributeWrapper, respectively.
 * The \ref AQNWB::NWB::Container "Container" object that owns the dataset/attribute then
 * provides accessor methods to get access to the dataset/attribute. Here, we
 * access the ``data`` dataset of the \ref AQNWB::NWB::ElectricalSeries "ElectricalSeries".
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_get_data_wrapper_snippet
 *
 * \paragraph read_design_example_load_data Read data into memory
 *
 * To access the data values of a data, we can then use the \ref AQNWB::ReadDatasetWrapper::valuesGeneric "valuesGeneric"
 * and \ref AQNWB::ReadDatasetWrapper::values "values" methods, which load the data as generic (untyped) or typed
 * data, respectively.
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_get_datablock_snippet
 *
 * The data is here represented as a \ref AQNWB::DataBlock "DataBlock", which stores the data as 1-dimensionsal
 * vector along with the shape of the data. E.g, here we validate the data against the original mock data:
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_validate_datablock_snippet
 *
 * \paragraph read_design_example_boostarray Accessing multi-dimensional data as Boost multi-array
 *
 * To ease interaction with mutli-dimensional data, e.g., the ``(time x channel)`` data of our
 * \ref AQNWB::NWB::ElectricalSeries "ElectricalSeries", we can use the
 * \ref AQNWB::DataBlock::as_multi_array "DataBlock.as_multi_array" method to construct a
 * ``boost::const_multi_array_ref``.
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_get_boostarray_snippet
 *
 * Using boost multi-array simplifies access and interaction with the data as a multi-dimensional array.
 * Here we use this again to validate the data we loaded against the original mock, like we did above.
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_validate_boostarray_snippet
 *
 * \paragraph read_design_example_attribute Reading an attribute
 *
 * Reading an ``Attribute`` from a file works much in the same way as reading a ``Dataset``.
 * The main differences are when we read an attribute:
 * 1. We interact with \ref AQNWB::ReadAttributeWrapper "ReadAttributeWrapper" instead of a
 *    \ref AQNWB::ReadDatasetWrapper "ReadDatasetWrapper"
 * 2. \ref AQNWB::ReadAttributeWrapper "ReadAttributeWrapper"  does not support slicing,
 *    but because attributes are small, we always load all values when requesting the
 *    data values via the \ref AQNWB::ReadAttributeWrapper::valuesGeneric "valuesGeneric"
 *    or \ref AQNWB::ReadAttributeWrapper::values "values<DTYPE>" methods.
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_attribute_snippet
 *
 * \note
 * In this case, the NWB specifies ``float32`` as the dtype for the ``resolution`` attribute.
 * As such, the template parameter for the ``VTYPE`` (value type) template parameter
 * for \ref AQNWB::ReadAttributeWrapper "ReadAttributeWrapper<VTYPE>" is set to ``float``
 * by default, so we do not need to specify it. If for some reason a file should use
 * ``float64`` instead, then we can still set the ``VTYPE`` accordingly via
 * ``electricalSeries->resolutionLazy<float64>()``.
 *
 * \paragraph read_design_example_readgeneric Reading data with unknown type
 *
 * So far we read data by specifying the ``VTYPE`` template parameter of the read wrapper.
 * However, if we do not know (or want to) specify the ``VTYPE`` then we can set it to ``std::any``,
 * which is the default for data with variable type, e.g.
 * \ref AQNWB::NWB::ElectricalSeries::dataLazy "ElectricalSeries::dataLazy". In this case, we can
 * still read the data via the \ref AQNWB::ReadDatasetWrapper::valuesGeneric "valuesGeneric"
 * to load the data first in untyped form. When loading the data, the I/O backend determines
 * the data type and allocates memory appropriately. The actual data type is then stored
 * in \ref AQNWB::DataBlockGeneric::typeIndex "typeIndex" variable of our data block.
 * We can then convert our \ref AQNWB::DataBlockGeneric "DataBlockGeneric" to a
 * \ref AQNWB::DataBlock "DataBlock<DTYPE>" with a specific data type via
 * \ref AQNWB::DataBlock::fromGeneric "DataBlock.fromGeneric()".
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_get_data_wrapper_as_generic_snippet
 *
 * \note
 * In most cases, we should not need runtime checking of types in the context of
 * specific data acquisition systems. This is likely mostly relevant if one wants to consume
 * arbitrary NWB files that may use different data types. One approach to implement
 * behavior for types determined at runtime is to define a mapping of the type
 * information to the corresponding statically type functionality, e.g., via
 * ``switch/case`` logic or by using a map for lookup, such as:
 * \code{.cpp}
 * DataBlockGeneric dataValuesGeneric = readDataWrapperGeneric->valuesGeneric();
 * // Map to associate std::type_index with corresponding type-specific functions
 * std::unordered_map<std::type_index, std::function<void(const DataBlockGeneric&)>> typeMap = {
 *       {typeid(float), processData<float>},
 *       {typeid(int), processData<<int>},
 *       // Add more types as needed
 * };
 * // Use the map to process the data with the approbriate type
 * auto it = typeMap.find(dataValuesGeneric.typeIndex);
 * if (it != typeMap.end()) {
 *       it->second(dataValuesGeneric); // call the correct proceesData function
 * } else {
 *       std::cout << "Unsupported type" << std::endl;
 * }
 * \endcode
 *
 * \subsection read_design_example_stop_recording Finalize the recording
 *
 * Next we stop the recording and close the file so we can show how we can read from the file
 * we just created.
 *
 * \snippet tests/examples/test_ecephys_data_read.cpp example_read_finish_recording_snippet
 *
 * \subsection read_design_example_read_posthoc Read data from an existing file
 *
 * To read from an existing file we simply need to create the I/O object and the construct the
 * Container object we want to read.
 *
 *  \snippet tests/examples/test_ecephys_data_read.cpp  example_read_only_snippet
 *
 */


