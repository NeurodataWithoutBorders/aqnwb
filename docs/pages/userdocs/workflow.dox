/**
 * \page workflow Acquiring Data ðŸ“Š
 *
 * \tableofcontents
 *
 * \section recording_workflow Overview of a recording workflow
 *
 * For users wanting to integrate NWB with a particular data acquisition software, here
 * we outline the steps for a single recording from file creation to saving.
 *
 * 1. Create the I/O object (e.g,.  \ref AQNWB::IO::HDF5::HDF5IO "HDF5IO") used for
 *    writing data to the file on disk.
 * 2. Create the \ref AQNWB::NWB::NWBFile "NWBFile" object which represents the NWB file and provides
 *    convenience functions for creating NWB file contents.
 * 3. Create the recording metadata stored in ``/general`` in NWB, e.g., the  
 *    \ref AQNWB::NWB::ElectrodeTable "ElectrodeTable" object used for 
 *    saving electrodes information. 
 * 4. Create the \ref AQNWB::NWB::RegisteredType "RegisteredType" objects (e.g.,
 *    \ref AQNWB::NWB::ElectricalSeries "ElectricalSeries") used for recording. 
 *
 *     - Upon creation, the \ref AQNWB::NWB::RegisteredType "RegisteredType" objects are automatically
 *       registered with the \ref AQNWB::IO::RecordingObjects "RecordingObjects" object provided by the I/O object 
 *       for easy access and to facilitate management of the recording process.
 *
 * 5. Start the recording.
 * 6. Write data.
 * 7. Stop the recording and close the \ref AQNWB::NWB::NWBFile "NWBFile".
 *
 * Below, we walk through these steps in more detail.
 *
 * \image html resources/images/aqnwb_workflow_and_api.png "Overview of the workflow and design of AqNWB." width=800px
 *
 *
 * \subsection create_io 1. Create the I/O object
 *
 * First, create an I/O object (e.g., \ref AQNWB::IO::HDF5::HDF5IO "HDF5IO") used for writing
 * data to the file. AqNWB provides the convenience method, \ref AQNWB::createIO "createIO"
 * to create this object using one of the supported backends. For more fine-grained
 * control of different backend parameters, you can create your own `std::shared_ptr`
 * using any of the derived \ref AQNWB::IO::BaseIO "BaseIO" classes.
 *
 * \snippet tests/examples/testWorkflowExamples.cpp example_workflow_io_snippet
 *
 * \subsection create_nwbfile 2. Create the NWBFile
 *
 * Next, constructs the \ref AQNWB::NWB::NWBFile "NWBFile"  object, using the I/O object as an input.
 * Then, initialize the object to create the basic file structure of the NWBFile.
 *
 * \snippet tests/examples/testWorkflowExamples.cpp example_workflow_nwbfile_snippet
 *
 * \note 
 * In AqNWB `neurodata_types` in NWB are represented by subclasses of \ref AQNWB::NWB::RegisteredType "RegisteredType".
 * All \ref AQNWB::NWB::RegisteredType "RegisteredType" objects (e.g., a  \ref AQNWB::NWB::TimeSeries "TimeSeries") are
 * constructed via a `create` factory method that requires the `path` in the file and the `io` as input.   
 *
 * \subsection create_recmeta 3. Create the recording metadata 
 *
 * \subsubsection create_recmeta_ecephys Create the extracellular recording metadata
 * Next, construct the \ref AQNWB::NWB::ElectrodeTable "ElectrodeTable" object, 
 * using the `recordingArrays` as an input. Note that in many cases, you will be recording from 
 * all electrodes detected by the device and this `recordingArrays` structure will be the same as
 * is used to create the \ref AQNWB::NWB::ElectricalSeries "ElectricalSeries". However in some cases
 * (e.g. when using Neuropixels or multiple probes), you may be recording from a subset of 
 * all available electrodes as part of a single \ref AQNWB::NWB::ElectricalSeries "ElectricalSeries". In this case,
 * you should create the ref AQNWB::NWB::ElectrodesTable "ElectrodesTable" with all electrodes
 * detected by the acquisition system, not just those being actively recorded from. This approach is
 * critical for mapping information about which \ref AQNWB::NWB::ElectricalSeries "ElectricalSeries"
 * were recorded from which electrodes.
 *
 * \snippet tests/examples/testWorkflowExamples.cpp example_workflow_electrodes_table_snippet
 * 
 *
 * \subsection create_datasets 4. Create datasets and add to RecordingObjects
 *
 * Next, create the different data types (e.g. \ref AQNWB::NWB::ElectricalSeries "ElectricalSeries"
 * or other \ref AQNWB::NWB::TimeSeries "TimeSeries") that you would like to write data into. After
 * initialization, these objects are added automatically to the  \ref AQNWB::IO::RecordingObjects "RecordingObjects"
 * instance owned by the I/O object so that it can manage access and data writing during the recording process.
 * Once added, ownership of the \ref AQNWB::NWB::RegisteredType "RegisteredType"  is transferred to the
 * \ref AQNWB::IO::RecordingObjects "RecordingObjects" object, so that we can access it again via
 * its index. New containers will always be appended to the end of the private member
 * \ref AQNWB::IO::RecordingObjects::m_recording_objects "RecordingObjects::m_recording_objects" object.
 *
 * \snippet tests/examples/testWorkflowExamples.cpp example_workflow_datasets_snippet
 *
 * We can check the contents of our \ref AQNWB::IO::RecordingObjects "RecordingObjects" to confirm:
 *
 * \snippet tests/examples/testWorkflowExamples.cpp example_workflow_recording_containers_snippet
 * 
 * **Output:**
 * @code
 * RecordingObjects contents:
 * Index = 0; Type = core::NWBFile; Path = /; 
 * Index = 1; Type = hdmf-common::ElementIdentifiers; Path = /general/extracellular_ephys/electrodes/id; 
 * Index = 2; Type = hdmf-common::VectorData; Path = /general/extracellular_ephys/electrodes/group_name; 
 * Index = 3; Type = hdmf-common::VectorData; Path = /general/extracellular_ephys/electrodes/location; 
 * Index = 4; Type = core::DynamicTable; Path = /general/extracellular_ephys/electrodes; 
 * Index = 5; Type = core::Device; Path = /general/devices/array0; 
 * Index = 6; Type = core::ElectrodeGroup; Path = /general/extracellular_ephys/array0; 
 * Index = 7; Type = core::Device; Path = /general/devices/array1; 
 * Index = 8; Type = core::ElectrodeGroup; Path = /general/extracellular_ephys/array1; 
 * Index = 9; Type = hdmf-common::VectorData; Path = /general/extracellular_ephys/electrodes/group; 
 * Index = 10; Type = core::ElectricalSeries; Path = /acquisition/esdata0; 
 * Index = 11; Type = core::ElectricalSeries; Path = /acquisition/esdata1; 
 * @endcode 
 *
 * \note
 * Registration with the \ref AQNWB::IO::RecordingObjects "RecordingObjects"  of the I/O occurs when a 
 * \ref AQNWB::NWB::RegisteredType "RegisteredType" is being created via the the static
 * \ref AQNWB::NWB::RegisteredType::create "RegisteredType::create" factory methods. 
 *
 * \subsection start_recording 5. Start the recording.
 *
 * Then, start the recording process with a call to the ``startRecording`` function of the I/O object.
 *
 * \snippet tests/examples/testWorkflowExamples.cpp example_workflow_start_snippet
 *
 * \note
 * When using \ref AQNWB::IO::HDF5::HDF5IO "HDF5IO" for writing to HDF5, calling
 * \ref AQNWB::IO::HDF5::HDF5IO::startRecording "startRecording" will by default enable
 * \ref hdf5io_swmr "SWMR mode" to ensure file integrity and support concurrent read.
 * As a result, no additional datasets or groups can be added to the file once a recording
 * has been started unless the file is closed and reopened.
 *
 * <p></p>
 *
 * \note 
 * To ensure that all NWB metadata is consistent when we start the recording process, 
 * \ref AQNWB::IO::BaseIO::startRecording "startRecording" also calls 
 * \ref AQNWB::IO::RecordingObjects::finalize "RecordingObjects::finalize" to
 * finalize all our \ref AQNWB::NWB::RegisteredType "RegisteredType" objects.
 *
 * \subsection write_data 6. Write data.
 *
 * During the recording process, use the \ref AQNWB::IO::RecordingObjects "RecordingObjects"
 * as an interface to access the various  \ref AQNWB::NWB::Container "Container" object and corresponding
 * datasets and write blocks of data to the file. Calling `flush()` on the I/O object at any time will
 * ensure the data is moved to disk.
 *
 * \snippet tests/examples/testWorkflowExamples.cpp example_workflow_write_snippet
 *
 * \note
 * We should always reuse the existing objects that are cached in 
 * \ref AQNWB::IO::RecordingObjects "RecordingObjects". Calling for example
 * `ElectricalSeries::create("/acquisition/esdata0", io) multiple times 
 * for the same I/O and path will result in the creation and registration of 
 * effectively duplicate objects that attempt to access (and potentially modify)
 * the same objects in the NWB file, hence, leading to potentially unintended
 * interactions, e.g., one object overwriting changes of the other. 
 *
 * \subsection stop_recording 7. Stop the recording and finalize the file.
 *
 * When the recording process is finished, call `stopRecording` from the I/O object
 * to flush any data and close the file.
 *
 * \snippet tests/examples/testWorkflowExamples.cpp example_workflow_stop_snippet
 *
 * \note 
 * To ensure that all NWB metadata is consistent after we complete the recording process, 
 * \ref AQNWB::IO::BaseIO::stopRecording "stopRecording" also calls 
 * \ref AQNWB::IO::RecordingObjects::finalize "RecordingObjects::finalize" again.
 *
 * <p></p>
 *
 * \note 
 * If we do not use the \ref AQNWB::IO::BaseIO::startRecording "startRecording
 * \ref AQNWB::IO::BaseIO::stopRecording "stopRecording" functions to create and NWBFile 
 * then we need to make sure to manually call \ref AQNWB::IO::RecordingObjects::finalize "RecordingObjects::finalize"
 * before we close the I/O to make sure file contents are finalized correctly.
 *
 * \section advanced_recording_workflow Advanced: Recording individual datasets
 *
 * In the above workflow we used utility methods, e.g., 
 * \ref AQNWB::IO::writeTimeseriesData "writeTimeseriesData" 
 * to ensure data is being recorded in a consistent manner such that data and timestamps
 * are both updated at the same time to ensure the recording is consistent. For finer-grained
 * control to record into individual datasets directly, we can use the corresponding 
 * record methods, e.g., \ref AQNWB::NWB::TimeSeries::recordData "TimeSeries.recordData" to 
 * retrieve the \ref AQNWB::IO::BaseRecordingData "BaseRecordingData" object for 
 * writing data to the datasets. The \ref AQNWB::IO::BaseRecordingData "BaseRecordingData" 
 * objects for all datasets that belong to a recording object are cached by the 
 * \ref AQNWB::NWB::RegisteredType "RegisteredType" base class to ensure that the current
 * state of the recording process (e.g., the \ref AQNWB::IO::BaseRecordingData::getPosition() "position")
 * are stored. With this we can manually write individual data blocks ourselves while 
 * ensuring continuation of the recording process:
 *
 * \snippet tests/examples/testWorkflowExamples.cpp example_workflow_advanced_snippet
 *
 * \subsection advanced_recording_workflow_reset Resetting the recording position
 *
 * If for some reason we want to reset the recording (to overwrite already recorded values)
 * we can do so for individual datasets by setting `reset=true` when retrieving the 
 * \ref AQNWB::IO::BaseRecordingData "BaseRecordingData" object (e.g., via 
 * \ref AQNWB::NWB::TimeSeries::recordData "auto dataRecorder = electricalSeries0->recordData(true)")
 * or for all datasets of a particular object via, e.g.
 * \ref AQNWB::NWB::RegisteredType::clearRecordingDataCache "electricalSeries0->clearRecordingDataCache()".
 * In both cases the cached \ref AQNWB::IO::BaseRecordingData "BaseRecordingData" object will be 
 * deleted, such that the next time we request it, a new \ref AQNWB::IO::BaseRecordingData "BaseRecordingData"
 * object will be constructed that will then start again writing values from the beginning of the dataset.
 * 
 */
