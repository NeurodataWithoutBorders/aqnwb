<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>aqnwb: HDF5 I/O ðŸ“‚</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom-modern.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="aqnwb-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">aqnwb<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td></tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('hdf5io.html','',''); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
</script>
<div id="main-nav"></div>
<div id="container"><div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">HDF5 I/O ðŸ“‚ </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1 class="doxsection"><a class="anchor" id="hdf5io_data_layout"></a>
Optimizing Data Layout</h1>
<p>HDF5 supports advanced I/O features for optimizing the layout of large data arrays via <a class="el" href="#hdf5io_chunking">Chunking</a> and <a class="el" href="#hdf5io_filters">I/O Filters</a>. Below we discuss these features in more detail. The main classes involved in configuring chunking and I/O filters in HDF5 via <a class="el" href="namespace_a_q_n_w_b.html" title="The main namespace for AqNWB.">AQNWB</a> are:</p>
<ul>
<li><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_array_data_set_config.html">ArrayDataSetConfig</a> for configuring datasets for write, including chunking settings.<ul>
<li><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_array_data_set_config.html">HDF5ArrayDataSetConfig</a> then extends the basic <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_array_data_set_config.html">ArrayDataSetConfig</a> to add HDF5-specific configurations, such as, support for configuring I/O filters (e.g., for compression)</li>
<li><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_filter_config.html">HDF5FilterConfig</a> is used with <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_array_data_set_config.html">HDF5ArrayDataSetConfig</a> to configure a single I/O filter.</li>
</ul>
</li>
<li><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_i_o.html#a0b301f91a26412d2f1a36f233f7099db">HDF5IO::createArrayDataSet</a> is the main method used for creating n-dimensional array datasets</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="hdf5io_chunking"></a>
Chunking</h2>
<p>For datasets intended for recording, <span class="tt">AqNWB</span> uses chunking to ensure the dataset can be extended as new data arrives during the recording process. Using chunking in HDF5, a dataset is divided into fixed-size blocks (called chunks), which are stored separately in the file. This technique is particularly beneficial for large datasets and offers several advantages:</p>
<ul>
<li><b>Extend datasets</b>: Chunked datasets can be easily extended in any dimension. This flexibility is crucial for recording datasets where the size of the dataset is not known in advance.</li>
<li><b>Performance Optimization</b>: By carefully choosing the chunk size, you can optimize performance based on your particular read/write access patterns. When only a portion of a chunked dataset is accessed, only the relevant chunks are read or written, reducing the amount of I/O operations.</li>
<li><b>Compression</b>: Data within each chunk can be compressed independently, which can help to significant reduce data size, especially for datasets with redundancy (see <a class="el" href="#hdf5io_filters">I/O Filters and Compression</a>).</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Choosing a chunking configuration that does not align well with the desired read/write pattern may lead to reduced performance due to repeated read, decompression, and update to the same chunk or read of extra data as chunks are always read fully.</dd></dl>
<div class="dotgraph">
<iframe scrolling="no" loading="lazy" frameborder="0" src="dot_inline_dotgraph_5.svg" width="460" height="271"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<h2 class="doxsection"><a class="anchor" id="hdf5io_filters"></a>
I/O Filters and Compression</h2>
<p>HDF5 filters are used to transform data as it is written to and read from the file. Filters are applied on a per-chunk basis (i.e., chunking is required to use filters), and are typically used for compression or error detection.</p>
<p>Compression filters reduce the amount of storage space required for datasets by eliminating redundancy in the data. One commonly used compression filter is <span class="tt">GZIP (DEFLATE)</span> which provides a good balance between compression ratio and speed. Multiple filters may be applied simultaneously. E.g., the <span class="tt">Shuffle</span> filter can be used to rearrange the bytes in the data to improve the effectiveness of compression filters. By shuffling the data, redundancy within the byte stream is increased, which can help improve compression ratios. For more information on the available filters in HDF5, please refer to the <a href="https://support.hdfgroup.org/documentation/hdf5/latest/_h5_d__u_g.html#subsubsec_dataset_transfer_filter">HDF5 Data Pipeline Filters Documentation</a> by the HDF5 project.</p>
<h2 class="doxsection"><a class="anchor" id="hdf5io_filters_usage"></a>
Using Chunking and I/O Filters in AqNWB</h2>
<p>When creating datasets, you can specify the filters to be applied using the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_array_data_set_config.html">HDF5ArrayDataSetConfig</a> class. The following example demonstrates how to configure and apply the GZIP and Shuffle filters to a dataset. The <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_array_data_set_config.html">HDF5ArrayDataSetConfig</a> class allows you to specify the data type, shape, chunking, and filters for the dataset. The <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_i_o.html#a0b301f91a26412d2f1a36f233f7099db">HDF5IO::createArrayDataSet</a> method then creates the dataset with the specified configuration.</p>
<div class="fragment"><div class="line">    <span class="comment">// Create the HDF5IO object and open the file as usual</span></div>
<div class="line">    std::string path = getTestFilePath(<span class="stringliteral">&quot;testWithFilters.h5&quot;</span>);</div>
<div class="line">    std::unique_ptr&lt;AQNWB::IO::HDF5::HDF5IO&gt; hdf5io =</div>
<div class="line">        std::make_unique&lt;AQNWB::IO::HDF5::HDF5IO&gt;(path);</div>
<div class="line">    hdf5io-&gt;open();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define the data type, shape, and chunking</span></div>
<div class="line">    <a class="code hl_class" href="class_a_q_n_w_b_1_1_i_o_1_1_base_data_type.html">AQNWB::IO::BaseDataType</a> type(<a class="code hl_enumvalue" href="class_a_q_n_w_b_1_1_i_o_1_1_base_data_type.html#a3ad0684f43e20f91bb130f18b35ed07ca173028aa2272afaa22cea5057be4faf8">AQNWB::IO::BaseDataType::Type::T_I32</a>, 1);</div>
<div class="line">    <a class="code hl_typedef" href="_base_i_o_8hpp.html#ae7b9f006e82f06f4fc09caf38bd47460">SizeArray</a> shape = {100, 100};</div>
<div class="line">    <a class="code hl_typedef" href="_base_i_o_8hpp.html#ae7b9f006e82f06f4fc09caf38bd47460">SizeArray</a> chunking = {10, 10};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create HDF5ArrayDataSetConfig and add filters</span></div>
<div class="line">    <a class="code hl_class" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_array_data_set_config.html">AQNWB::IO::HDF5::HDF5ArrayDataSetConfig</a> config(type, shape, chunking);</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gzip_level = 4;</div>
<div class="line">    config.addFilter(</div>
<div class="line">        <a class="code hl_function" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_filter_config.html#abe6285c00a7407308c7e5dc5494b1938">AQNWB::IO::HDF5::HDF5FilterConfig::createGzipFilter</a>(gzip_level));</div>
<div class="line">    config.addFilter(<a class="code hl_function" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_filter_config.html#a495cbe6122dc9cb7a9903ef76d291b2c">AQNWB::IO::HDF5::HDF5FilterConfig::createShuffleFilter</a>());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the dataset</span></div>
<div class="line">    <span class="keyword">auto</span> baseDataset = hdf5io-&gt;createArrayDataSet(config, <span class="stringliteral">&quot;/filtered_dataset&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// [Optional/Testing] Verify the dataset properties</span></div>
<div class="line">    <span class="keyword">auto</span> dataset =</div>
<div class="line">        <span class="keyword">dynamic_cast&lt;</span><a class="code hl_class" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_recording_data.html">AQNWB::IO::HDF5::HDF5RecordingData</a>*<span class="keyword">&gt;</span>(baseDataset.get());</div>
<div class="line">    <span class="keyword">const</span> H5::DataSet* h5Dataset = dataset-&gt;<a class="code hl_function" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_recording_data.html#a7892398dd563ac3149c27dbbe8986e90">getDataSet</a>();</div>
<div class="line">    H5::DSetCreatPropList dcpl = h5Dataset-&gt;getCreatePlist();</div>
<div class="line">    REQUIRE(dcpl.getNfilters() == 2);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_filter_config.html">HDF5FilterConfig</a> provides convenient factory methods to setup common filters, e.g., <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_filter_config.html#abe6285c00a7407308c7e5dc5494b1938">createGzipFilter</a>. Alternatively, we can also use any of the HDF5 filters directly via <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_array_data_set_config.html#a9aefd3b9c5e9fd7efcdb2950e63e557b">HDF5ArrayDataSetConfig::addFilter</a>, <br  />
 e.g., in the case of GZIP via <span class="tt">config.addFilter(H5Z_FILTER_DEFLATE, {4});</span></dd></dl>
<h1 class="doxsection"><a class="anchor" id="hdf5io_swmr"></a>
Single-Writer Multiple-Reader (SWMR) Mode</h1>
<p>The <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_i_o.html">HDF5IO</a> I/O backend uses by default SWMR mode while recording data. Using SWMR, one process can write to the HDF5 file and multiple other processes can read from the file concurrently while ensuring that the readers see a consistent view of the data.</p>
<div class="dotgraph">
<iframe scrolling="no" loading="lazy" frameborder="0" src="dot_inline_dotgraph_6.svg" width="367" height="288"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<dl class="section warning"><dt>Warning</dt><dd>There are known issues using SWMR mode on Windows due to file locking by the reader processes. One workaround is to set the environment variable <span class="tt">HDF5_USE_FILE_LOCKING=FALSE</span> to prevent file access errors when using a writer process with other reader processes. <br  />
</dd></dl>
<h2 class="doxsection"><a class="anchor" id="hdf5io_swmr_features"></a>
Why does AqNWB use SMWR mode?</h2>
<p>Using SWMR has several key advantages for data acquisition applications:</p>
<ul>
<li><b>Concurrent</b> <b>Access:</b> Enables one writer process to update the file while multiple reader processes read from it without blocking each other.</li>
<li><b>Data</b> <b>Consistency</b> <b>and</b> <b>Integrity:</b> Ensures that readers see a consistent view of the data, even as it is being written. Readers will only see data that has been completely written and flushed to disk. Hence, SWMR mode, maintains the integrity and consistency of the data, ensuring that the HDF5 file remains readable even if errors should occur during the data acquisition process.</li>
<li><b>Real-Time</b> <b>Data</b> <b>Access:</b> Useful for applications that need to monitor and analyze data in real-time as it is being generated.</li>
<li><b>Simplified</b> <b>Workflow</b> <b>for</b> <b>Real</b> <b>Time</b> <b>Analyses:</b> Simplifies the architecture of applications that require real-time data consumption during acquisition, avoiding the need for intermediate storage solutions and complex inter-process communication or file locking mechanisms.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>While SWMR mode ensures data integrity, some data loss may still occur if the application crashes. Only data that has been completely written and flushed to disk will be readable. To manually flush data to disk use <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_i_o.html#af169224331c1c4f67ccf8521f5d778db">HDF5IO::flush</a>.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="hdf5io_swmr_workflow"></a>
Writing an NWB file with SWMR mode</h2>
<p>SWMR mode is enabled when calling <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_i_o.html#a8606979d328123bb7bd8efa9df85c6df">HDF5IO::startRecording</a>. Once SWMR mode is enabled, no new data objects (Datasets, Groups, Attributes etc.) can be created, but we can only add and set values to existing data objects. Since other processes may read from the HDF5 file, it is not possible to intermittently disable SWMR mode to add new objects, i.e., once SWMR mode is enabled, the only way to add new objects to the file is to close the file and reopen in read/write mode. As such, the typical workflow when using SWMR mode during data acquisition is to:</p>
<ol type="1">
<li>Open the HDF5 file</li>
<li>Create all elements of the NWB file</li>
<li>Start the recording process</li>
<li>Stop recording and close the file</li>
</ol>
<p>This workflow is applicable to a wide range of data acquisition use-cases. However, for use cases that require creation of new Groups and Datasets during acquisition, you can disable the use of SWMR mode by setting <span class="tt">disableSWMRMode=true</span> when constructing the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_i_o.html">AQNWB::IO::HDF5::HDF5IO</a> object.</p>
<dl class="section warning"><dt>Warning</dt><dd>While disabling SWMR mode allows Groups and Datasets to be created during and after recording, this comes at the cost of losing the concurrent access and data integrity features that SWMR mode provides.</dd></dl>
<h3 class="doxsection"><a class="anchor" id="hdf5io_swmr_examples"></a>
Code Examples</h3>
<p>This code snippet shows all the includes that are being used by the code examples shown in this section:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;filesystem&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;future&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;numeric&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;catch2/catch_test_macros.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_h_d_f5_array_data_set_config_8hpp.html">io/hdf5/HDF5ArrayDataSetConfig.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_h_d_f5_i_o_8hpp.html">io/hdf5/HDF5IO.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_h_d_f5_recording_data_8hpp.html">io/hdf5/HDF5RecordingData.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_n_w_b_file_8hpp.html">nwb/NWBFile.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_electrode_table_8hpp.html">nwb/file/ElectrodeTable.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;testUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>fs = std::filesystem;</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="hdf5io_swmr_examples_with_swmr"></a>
Workflow with SWMR</h4>
<div class="fragment"><div class="line">    <span class="comment">// create and open the HDF5 file. SWMR mode is used by default</span></div>
<div class="line">    std::string path = getTestFilePath(<span class="stringliteral">&quot;testWithSWMRMode.h5&quot;</span>);</div>
<div class="line">    std::unique_ptr&lt;AQNWB::IO::HDF5::HDF5IO&gt; hdf5io =</div>
<div class="line">        std::make_unique&lt;AQNWB::IO::HDF5::HDF5IO&gt;(path);</div>
<div class="line">    hdf5io-&gt;open();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// add a dataset</span></div>
<div class="line">    std::vector&lt;int&gt; testData(10000);</div>
<div class="line">    std::iota(testData.begin(), testData.end(), 1);  <span class="comment">// Initialize testData</span></div>
<div class="line">    std::string dataPath = <span class="stringliteral">&quot;/data&quot;</span>;</div>
<div class="line">    <a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> numBlocks = 10;  <span class="comment">// write 10 chunks of</span></div>
<div class="line">    <a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> numSamples = testData.size();</div>
<div class="line">    <a class="code hl_class" href="class_a_q_n_w_b_1_1_i_o_1_1_array_data_set_config.html">AQNWB::IO::ArrayDataSetConfig</a> datasetConfig(</div>
<div class="line">        BaseDataType::I32,  <span class="comment">// type</span></div>
<div class="line">        <a class="code hl_typedef" href="_base_i_o_8hpp.html#ae7b9f006e82f06f4fc09caf38bd47460">SizeArray</a> {0},  <span class="comment">// size. Initial size of the dataset</span></div>
<div class="line">        <a class="code hl_typedef" href="_base_i_o_8hpp.html#ae7b9f006e82f06f4fc09caf38bd47460">SizeArray</a> {1000}  <span class="comment">// chunking. Size of a data chunk</span></div>
<div class="line">    );</div>
<div class="line">    std::unique_ptr&lt;BaseRecordingData&gt; dataset = hdf5io-&gt;createArrayDataSet(</div>
<div class="line">        datasetConfig,</div>
<div class="line">        dataPath);  <span class="comment">// path. Path to the dataset in the HDF5 file</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Start recording. Starting the recording places the HDF5 file in SWMR mode</span></div>
<div class="line">    <a class="code hl_typedef" href="_base_i_o_8hpp.html#a38fce1d86c801b13b6860d3346276776">Status</a> status = hdf5io-&gt;startRecording();</div>
<div class="line">    REQUIRE(status == Status::Success);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Once in SWMR mode we can add data to the file but we can no longer create</span></div>
<div class="line">    <span class="comment">// new data objects (Groups, Datasets, Attributes etc.).</span></div>
<div class="line">    REQUIRE(hdf5io-&gt;canModifyObjects() == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// write the our testData to the file.</span></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> b = 0; b &lt;= numBlocks; b++) {</div>
<div class="line">      <span class="comment">// write a single 1D block of data and flush to file</span></div>
<div class="line">      std::vector&lt;SizeType&gt; dataShape = {numSamples};</div>
<div class="line">      dataset-&gt;writeDataBlock(dataShape, BaseDataType::I32, &amp;testData[0]);</div>
<div class="line">      <span class="comment">// Optionally we can flush all data to disk</span></div>
<div class="line">      status = hdf5io-&gt;flush();</div>
<div class="line">      REQUIRE(status == Status::Success);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// stop recording. In SWMR mode the file is now closed and recording cannot</span></div>
<div class="line">    <span class="comment">// be restarted</span></div>
<div class="line">    status = hdf5io-&gt;stopRecording();</div>
<div class="line">    REQUIRE(hdf5io-&gt;isOpen() == <span class="keyword">false</span>);</div>
<div class="line">    REQUIRE(hdf5io-&gt;startRecording() == Status::Failure);</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="hdf5io_noswmr_examples_without_swmr"></a>
Workflow with SWMR disabled</h4>
<div class="fragment"><div class="line">    <span class="comment">// create and open the HDF5 file. With SWMR mode explicitly disabled</span></div>
<div class="line">    std::string path = getTestFilePath(<span class="stringliteral">&quot;testWithoutSWMRMode.h5&quot;</span>);</div>
<div class="line">    std::unique_ptr&lt;AQNWB::IO::HDF5::HDF5IO&gt; hdf5io =</div>
<div class="line">        std::make_unique&lt;AQNWB::IO::HDF5::HDF5IO&gt;(path,</div>
<div class="line">                                                  <span class="keyword">true</span>  <span class="comment">// Disable SWMR mode</span></div>
<div class="line">        );</div>
<div class="line">    hdf5io-&gt;open();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// add a dataset</span></div>
<div class="line">    std::vector&lt;int&gt; testData(10000);</div>
<div class="line">    std::iota(testData.begin(), testData.end(), 1);  <span class="comment">// Initialize testData</span></div>
<div class="line">    std::string dataPath = <span class="stringliteral">&quot;/data&quot;</span>;</div>
<div class="line">    <a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> numBlocks = 10;  <span class="comment">// write 10 chunks of</span></div>
<div class="line">    <a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> numSamples = testData.size();</div>
<div class="line">    <a class="code hl_class" href="class_a_q_n_w_b_1_1_i_o_1_1_array_data_set_config.html">AQNWB::IO::ArrayDataSetConfig</a> datasetConfig(</div>
<div class="line">        BaseDataType::I32,  <span class="comment">// type</span></div>
<div class="line">        <a class="code hl_typedef" href="_base_i_o_8hpp.html#ae7b9f006e82f06f4fc09caf38bd47460">SizeArray</a> {0},  <span class="comment">// size. Initial size of the dataset</span></div>
<div class="line">        <a class="code hl_typedef" href="_base_i_o_8hpp.html#ae7b9f006e82f06f4fc09caf38bd47460">SizeArray</a> {1000}  <span class="comment">// chunking. Size of a data chunk</span></div>
<div class="line">    );</div>
<div class="line">    std::unique_ptr&lt;BaseRecordingData&gt; dataset = hdf5io-&gt;createArrayDataSet(</div>
<div class="line">        datasetConfig,</div>
<div class="line">        dataPath);  <span class="comment">// path. Path to the dataset in the HDF5 file</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Start recording. Starting the recording places the HDF5 file in SWMR mode</span></div>
<div class="line">    <a class="code hl_typedef" href="_base_i_o_8hpp.html#a38fce1d86c801b13b6860d3346276776">Status</a> status = hdf5io-&gt;startRecording();</div>
<div class="line">    REQUIRE(status == Status::Success);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// With SWMR mode disabled we are still allowed to create new data objects</span></div>
<div class="line">    <span class="comment">// (Groups, Datasets, Attributes etc.) during the recording. However, with</span></div>
<div class="line">    <span class="comment">// SWMR mode disabled, we lose the data consistency and concurrent read</span></div>
<div class="line">    <span class="comment">// features that SWMR mode provides.</span></div>
<div class="line">    REQUIRE(hdf5io-&gt;canModifyObjects() == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// write the our testData to the file.</span></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> b = 0; b &lt;= numBlocks; b++) {</div>
<div class="line">      <span class="comment">// write a single 1D block of data and flush to file</span></div>
<div class="line">      std::vector&lt;SizeType&gt; dataShape = {numSamples};</div>
<div class="line">      dataset-&gt;writeDataBlock(dataShape, BaseDataType::I32, &amp;testData[0]);</div>
<div class="line">      <span class="comment">// Optionally we can flush all data to disk</span></div>
<div class="line">      status = hdf5io-&gt;flush();</div>
<div class="line">      REQUIRE(status == Status::Success);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// stop recording.</span></div>
<div class="line">    status = hdf5io-&gt;stopRecording();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Since SWMR mode is disabled, stopping the recording won&#39;t close the file</span></div>
<div class="line">    <span class="comment">// so that we can restart the recording if we want to</span></div>
<div class="line">    REQUIRE(hdf5io-&gt;isOpen() == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Restart the recording</span></div>
<div class="line">    REQUIRE(hdf5io-&gt;startRecording() == Status::Success);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Stop the recording and close the file</span></div>
<div class="line">    hdf5io-&gt;stopRecording();</div>
<div class="line">    hdf5io-&gt;close();</div>
<div class="line">    REQUIRE(hdf5io-&gt;isOpen() == <span class="keyword">false</span>);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="hdf5io_swmr_read"></a>
Reading with SWMR mode</h2>
<p>While the file is being written to in SWMR mode, readers must open the file with the <span class="tt">H5F_ACC_RDONLY</span> flag and then enable SWMR read mode using the <span class="tt">H5Fstart_swmr_read</span> function, e.g.:</p>
<div class="fragment"><div class="line">hid_t file_id = H5Fopen(<span class="stringliteral">&quot;example.h5&quot;</span>, H5F_ACC_RDONLY, H5P_DEFAULT);</div>
<div class="line">H5Fstart_swmr_read(file_id);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="userdocs.html">For Users</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
