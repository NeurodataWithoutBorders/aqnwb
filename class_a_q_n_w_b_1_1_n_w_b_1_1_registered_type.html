<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>aqnwb: AQNWB::NWB::RegisteredType Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom-modern.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="aqnwb-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">aqnwb<span id="projectnumber">&#160;0.3.0</span>
   </div>
  </td>
 </tr>
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td></tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html','','class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type-members'); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
</script>
<div id="main-nav"></div>
<div id="container"><div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">AQNWB::NWB::RegisteredType Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Base class for types defined in the <a class="el" href="namespace_a_q_n_w_b_1_1_n_w_b.html" title="Namespace for all classes related to the NWB data standard.">NWB</a> schema.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_registered_type_8hpp_source.html">RegisteredType.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AQNWB::NWB::RegisteredType:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type__inherit__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for AQNWB::NWB::RegisteredType:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type__coll__graph.svg" width="223" height="126"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab92081cf30cab76ac6e35125300f77a4" id="r_ab92081cf30cab76ac6e35125300f77a4"><td class="memItemLeft">virtual&#160;</td><td class="memItemRight"><a class="el" href="#ab92081cf30cab76ac6e35125300f77a4">~RegisteredType</a> ()</td></tr>
<tr class="memdesc:ab92081cf30cab76ac6e35125300f77a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="memitem:a079202bc1ce62c7f5794f5b658598b8c" id="r_a079202bc1ce62c7f5794f5b658598b8c"><td class="memItemLeft">const std::string &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a079202bc1ce62c7f5794f5b658598b8c">getPath</a> () const</td></tr>
<tr class="memdesc:a079202bc1ce62c7f5794f5b658598b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the path of the registered type.  <br /></td></tr>
<tr class="memitem:a9fa62ba79d610ba55aacec4dce012ccf" id="r_a9fa62ba79d610ba55aacec4dce012ccf"><td class="memItemLeft">std::string&#160;</td><td class="memItemRight"><a class="el" href="#a9fa62ba79d610ba55aacec4dce012ccf">getName</a> () const</td></tr>
<tr class="memdesc:a9fa62ba79d610ba55aacec4dce012ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the object.  <br /></td></tr>
<tr class="memitem:ab614b1609f536e88ed1f32762dc3894b" id="r_ab614b1609f536e88ed1f32762dc3894b"><td class="memItemLeft">std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">AQNWB::IO::BaseIO</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#ab614b1609f536e88ed1f32762dc3894b">getIO</a> () const</td></tr>
<tr class="memdesc:ab614b1609f536e88ed1f32762dc3894b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a shared pointer to the <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html" title="The namespace for IO components of AqNWB.">IO</a> object.  <br /></td></tr>
<tr class="memitem:ac277f0e6485c7c8050a76324eb994223" id="r_ac277f0e6485c7c8050a76324eb994223"><td class="memItemLeft"><a class="el" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a>&#160;</td><td class="memItemRight"><a class="el" href="#ac277f0e6485c7c8050a76324eb994223">getRecordingObjectIndex</a> () const</td></tr>
<tr class="memdesc:ac277f0e6485c7c8050a76324eb994223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of this object in m_io-&gt;m_recording_objects.  <br /></td></tr>
<tr class="memitem:ae66a9bc325b1ddb2c6a5f537feb8591a" id="r_ae66a9bc325b1ddb2c6a5f537feb8591a"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#ae66a9bc325b1ddb2c6a5f537feb8591a">isRegisteredRecordingObject</a> () const</td></tr>
<tr class="memdesc:ae66a9bc325b1ddb2c6a5f537feb8591a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> object is registered in the RecordingObjects manager object of the I/O.  <br /></td></tr>
<tr class="memitem:a9114e761cf006ec16c3733b9f8915f9d" id="r_a9114e761cf006ec16c3733b9f8915f9d"><td class="memItemLeft"><a class="el" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a>&#160;</td><td class="memItemRight"><a class="el" href="#a9114e761cf006ec16c3733b9f8915f9d">registerRecordingObject</a> ()</td></tr>
<tr class="memdesc:a9114e761cf006ec16c3733b9f8915f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register this <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> object with the RecordingObjects manager object of the I/O.  <br /></td></tr>
<tr class="memitem:aafbac618f2867992dbe8c2f35a072bae" id="r_aafbac618f2867992dbe8c2f35a072bae"><td class="memItemLeft">virtual <a class="el" href="class_a_q_n_w_b_1_1_types.html#a9f8b64371967b1e93cdb8e5caa8634c9">AQNWB::Types::Status</a>&#160;</td><td class="memItemRight"><a class="el" href="#aafbac618f2867992dbe8c2f35a072bae">finalize</a> ()</td></tr>
<tr class="memdesc:aafbac618f2867992dbe8c2f35a072bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> object.  <br /></td></tr>
<tr class="memitem:ad3753ec40e8c6b6fafa59ca80433e978" id="r_ad3753ec40e8c6b6fafa59ca80433e978"><td class="memItemLeft">const std::unordered_map&lt; std::string, std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_recording_data.html">IO::BaseRecordingData</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight"><a class="el" href="#ad3753ec40e8c6b6fafa59ca80433e978">getCacheRecordingData</a> () const</td></tr>
<tr class="memdesc:ad3753ec40e8c6b6fafa59ca80433e978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache of BaseRecordingData objects.  <br /></td></tr>
<tr class="memitem:ab63d3505ee5b5f1c949cb042c7f2deeb" id="r_ab63d3505ee5b5f1c949cb042c7f2deeb"><td class="memItemLeft">virtual void&#160;</td><td class="memItemRight"><a class="el" href="#ab63d3505ee5b5f1c949cb042c7f2deeb">clearRecordingDataCache</a> ()</td></tr>
<tr class="memdesc:ab63d3505ee5b5f1c949cb042c7f2deeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the BaseRecordingData object cache to reset the recording state.  <br /></td></tr>
<tr class="memitem:a150f881ad61cb8352eea7ddba47bc6ad" id="r_a150f881ad61cb8352eea7ddba47bc6ad"><td class="memItemLeft">virtual std::string&#160;</td><td class="memItemRight"><a class="el" href="#a150f881ad61cb8352eea7ddba47bc6ad">getTypeName</a> () const</td></tr>
<tr class="memdesc:a150f881ad61cb8352eea7ddba47bc6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the class type.  <br /></td></tr>
<tr class="memitem:a651f3d7e5cc28dc93888e8a821c5aa1c" id="r_a651f3d7e5cc28dc93888e8a821c5aa1c"><td class="memItemLeft">virtual std::string&#160;</td><td class="memItemRight"><a class="el" href="#a651f3d7e5cc28dc93888e8a821c5aa1c">getNamespace</a> () const</td></tr>
<tr class="memdesc:a651f3d7e5cc28dc93888e8a821c5aa1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the schema namespace of the class type.  <br /></td></tr>
<tr class="memitem:a0e670647b466cb65a88b81f9fe4a6e37" id="r_a0e670647b466cb65a88b81f9fe4a6e37"><td class="memItemLeft">std::string&#160;</td><td class="memItemRight"><a class="el" href="#a0e670647b466cb65a88b81f9fe4a6e37">getFullTypeName</a> () const</td></tr>
<tr class="memdesc:a0e670647b466cb65a88b81f9fe4a6e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the full name of the type, i.e., <span class="tt">namespace::typename</span>.  <br /></td></tr>
<tr class="memitem:adc5ba3d9e27c74f8181944e505bba6e5" id="r_adc5ba3d9e27c74f8181944e505bba6e5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="class_a_q_n_w_b_1_1_types.html#a778ba605df5dabb117ede12e41111915">StorageObjectType</a> SOT, typename VTYPE, typename std::enable_if&lt; <a class="el" href="struct_a_q_n_w_b_1_1_types_1_1_is_data_storage_object_type.html">Types::IsDataStorageObjectType</a>&lt; SOT &gt;::value, int &gt;::type = 0&gt; </td></tr>
<tr class="memitem:adc5ba3d9e27c74f8181944e505bba6e5 template"><td class="memItemLeft">std::unique_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">AQNWB::IO::ReadDataWrapper</a>&lt; SOT, VTYPE &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#adc5ba3d9e27c74f8181944e505bba6e5">readField</a> (const std::string &amp;fieldPath) const</td></tr>
<tr class="memdesc:adc5ba3d9e27c74f8181944e505bba6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support reading of arbitrary fields by their relative path.  <br /></td></tr>
<tr class="memitem:a07451eb27d98493d2d362129a3934a4d" id="r_a07451eb27d98493d2d362129a3934a4d"><td class="memItemLeft">std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">AQNWB::NWB::RegisteredType</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a07451eb27d98493d2d362129a3934a4d">readField</a> (const std::string &amp;fieldPath) const</td></tr>
<tr class="memdesc:a07451eb27d98493d2d362129a3934a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a field that is itself a <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a>.  <br /></td></tr>
<tr class="memitem:a8a83a775f6a8a94d6ae3428e05ef9bfc" id="r_a8a83a775f6a8a94d6ae3428e05ef9bfc"><td class="memItemLeft">virtual std::unordered_map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a8a83a775f6a8a94d6ae3428e05ef9bfc">findOwnedTypes</a> (const std::unordered_set&lt; std::string &gt; &amp;types={}, const <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html#af7fd0e43e0ffc4d765046020e6929035">AQNWB::IO::SearchMode</a> &amp;search_mode=<a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html#af7fd0e43e0ffc4d765046020e6929035a0bce90db02919671dbe161b9bd8cef05">AQNWB::IO::SearchMode::STOP_ON_TYPE</a>) const</td></tr>
<tr class="memdesc:a8a83a775f6a8a94d6ae3428e05ef9bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all typed objects that are owned by this object, i.e., objects that have a neurodata_type and namespace attribute and have this object as there closest parent with an assigned type.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab7e3361637885fe601cc20cb342bf01c" id="r_ab7e3361637885fe601cc20cb342bf01c"><td class="memItemLeft">static std::unordered_set&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight"><a class="el" href="#ab7e3361637885fe601cc20cb342bf01c">getRegistry</a> ()</td></tr>
<tr class="memdesc:ab7e3361637885fe601cc20cb342bf01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the registry of subclass names.  <br /></td></tr>
<tr class="memitem:ac83aa589b9c3ab5a00bab462e58fdbd5" id="r_ac83aa589b9c3ab5a00bab462e58fdbd5"><td class="memItemLeft">static std::unordered_map&lt; std::string, std::pair&lt; std::function&lt; std::shared_ptr&lt; <a class="el" href="#aa1e04074725b7331d725bbda8156bc2d">RegisteredType</a> &gt;(const std::string &amp;, std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">AQNWB::IO::BaseIO</a> &gt;)&gt;, std::pair&lt; std::string, std::string &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight"><a class="el" href="#ac83aa589b9c3ab5a00bab462e58fdbd5">getFactoryMap</a> ()</td></tr>
<tr class="memdesc:ac83aa589b9c3ab5a00bab462e58fdbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the factory map for creating instances of subclasses.  <br /></td></tr>
<tr class="memitem:a6f7d3d6d30763215c823452176ed876a" id="r_a6f7d3d6d30763215c823452176ed876a"><td class="memItemLeft">static std::shared_ptr&lt; <a class="el" href="#aa1e04074725b7331d725bbda8156bc2d">RegisteredType</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a6f7d3d6d30763215c823452176ed876a">create</a> (const std::string &amp;fullClassName, const std::string &amp;path, std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">IO::BaseIO</a> &gt; io, bool fallbackToBase=false)</td></tr>
<tr class="memdesc:a6f7d3d6d30763215c823452176ed876a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance of a registered subclass by name.  <br /></td></tr>
<tr class="memitem:a13dd3c9a0045cb3729ba9cf56e4a2fa7" id="r_a13dd3c9a0045cb3729ba9cf56e4a2fa7"><td class="memItemLeft">static std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">AQNWB::NWB::RegisteredType</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a13dd3c9a0045cb3729ba9cf56e4a2fa7">create</a> (const std::string &amp;path, std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">IO::BaseIO</a> &gt; io, bool fallbackToBase=false)</td></tr>
<tr class="memdesc:a13dd3c9a0045cb3729ba9cf56e4a2fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create an instance of a subclass of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> from file.  <br /></td></tr>
<tr class="memitem:a2291ceaa71c1b02ed86a3d4626a7ac48" id="r_a2291ceaa71c1b02ed86a3d4626a7ac48"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a2291ceaa71c1b02ed86a3d4626a7ac48 template"><td class="memItemLeft">static std::shared_ptr&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a2291ceaa71c1b02ed86a3d4626a7ac48">create</a> (const std::string &amp;path, std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">AQNWB::IO::BaseIO</a> &gt; io)</td></tr>
<tr class="memdesc:a2291ceaa71c1b02ed86a3d4626a7ac48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create an instance of a subclass of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> by type.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa1e04074725b7331d725bbda8156bc2d" id="r_aa1e04074725b7331d725bbda8156bc2d"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#aa1e04074725b7331d725bbda8156bc2d">RegisteredType</a> (const std::string &amp;path, std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">AQNWB::IO::BaseIO</a> &gt; io)</td></tr>
<tr class="memdesc:aa1e04074725b7331d725bbda8156bc2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-static-methods" class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ab20cf389f4f512056d7755ec23d6d0a9" id="r_ab20cf389f4f512056d7755ec23d6d0a9"><td class="memItemLeft">static void&#160;</td><td class="memItemRight"><a class="el" href="#ab20cf389f4f512056d7755ec23d6d0a9">registerSubclass</a> (const std::string &amp;fullClassName, std::function&lt; std::shared_ptr&lt; <a class="el" href="#aa1e04074725b7331d725bbda8156bc2d">RegisteredType</a> &gt;(const std::string &amp;, std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">AQNWB::IO::BaseIO</a> &gt;)&gt; factoryFunction, const std::string &amp;typeName, const std::string &amp;typeNamespace)</td></tr>
<tr class="memdesc:ab20cf389f4f512056d7755ec23d6d0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a subclass name and its factory function in the registry.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-attribs" class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2c2954495607eb4afe4e9ab8eff3a08b" id="r_a2c2954495607eb4afe4e9ab8eff3a08b"><td class="memItemLeft">std::string&#160;</td><td class="memItemRight"><a class="el" href="#a2c2954495607eb4afe4e9ab8eff3a08b">m_path</a></td></tr>
<tr class="memdesc:a2c2954495607eb4afe4e9ab8eff3a08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The path of the registered type.  <br /></td></tr>
<tr class="memitem:a73f9bb35022892941b8b46a1669605da" id="r_a73f9bb35022892941b8b46a1669605da"><td class="memItemLeft">std::weak_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">IO::BaseIO</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a73f9bb35022892941b8b46a1669605da">m_io</a></td></tr>
<tr class="memdesc:a73f9bb35022892941b8b46a1669605da"><td class="mdescLeft">&#160;</td><td class="mdescRight">A weak pointer to the <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html" title="The namespace for IO components of AqNWB.">IO</a> object.  <br /></td></tr>
<tr class="memitem:a549f4d2169ae451bda8d959c9a11dbc3" id="r_a549f4d2169ae451bda8d959c9a11dbc3"><td class="memItemLeft">std::unordered_map&lt; std::string, std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_recording_data.html">IO::BaseRecordingData</a> &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a549f4d2169ae451bda8d959c9a11dbc3">m_recordingDataCache</a></td></tr>
<tr class="memdesc:a549f4d2169ae451bda8d959c9a11dbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache for BaseRecordingData objects for datasets to retain recording state.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-static-attribs" class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:ac3e284613a1e28db9875fb06b66b0c19" id="r_ac3e284613a1e28db9875fb06b66b0c19"><td class="memItemLeft">static const std::string&#160;</td><td class="memItemRight"><a class="el" href="#ac3e284613a1e28db9875fb06b66b0c19">m_defaultUnregisteredGroupTypeClass</a></td></tr>
<tr class="memdesc:ac3e284613a1e28db9875fb06b66b0c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the default <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> to use for reading Group types that are not registered.  <br /></td></tr>
<tr class="memitem:a30cc61d9d6b91dd6bd767ceccf35fb7f" id="r_a30cc61d9d6b91dd6bd767ceccf35fb7f"><td class="memItemLeft">static const std::string&#160;</td><td class="memItemRight"><a class="el" href="#a30cc61d9d6b91dd6bd767ceccf35fb7f">m_defaultUnregisteredDatasetTypeClass</a></td></tr>
<tr class="memdesc:a30cc61d9d6b91dd6bd767ceccf35fb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the default <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> to use for reading Dataset types that are not registered.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for types defined in the <a class="el" href="namespace_a_q_n_w_b_1_1_n_w_b.html" title="Namespace for all classes related to the NWB data standard.">NWB</a> schema. </p>
<p>This class maintains a static registry of all subclasses that inherit from it. To register a new class we need to call the macro "REGISTER_SUBCLASS(MySubClass)" in the definition of the subclass. All subclasses must also implement the constructor with the <span class="tt">path</span> and <span class="tt">io</span> as sole input arguments. This in turn allows us to create any subclass of container based on its name because we can : 1) look-up classes by their name in the registry and 2) all subclasses have a consistent constructor. The registry is static in the sense that it is a static member of the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html" title="Abstract data type for a group storing collections of data and metadata.">Container</a> class (and as such it is shared among all instances of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html" title="Abstract data type for a group storing collections of data and metadata.">Container</a> and its subclasses). However, the registry is not static in the sense that it is being created at compile time; but it is created and can be modified at runtime. </p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab92081cf30cab76ac6e35125300f77a4" name="ab92081cf30cab76ac6e35125300f77a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92081cf30cab76ac6e35125300f77a4">&#9670;&#160;</a></span>~RegisteredType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RegisteredType::~RegisteredType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a id="aa1e04074725b7331d725bbda8156bc2d" name="aa1e04074725b7331d725bbda8156bc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e04074725b7331d725bbda8156bc2d">&#9670;&#160;</a></span>RegisteredType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RegisteredType::RegisteredType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">AQNWB::IO::BaseIO</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>io</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>All registered subclasses of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> must implement a constructor with these arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the registered type. </td></tr>
    <tr><td class="paramname">io</td><td>A shared pointer to the <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html" title="The namespace for IO components of AqNWB.">IO</a> object. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_aa1e04074725b7331d725bbda8156bc2d_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ab63d3505ee5b5f1c949cb042c7f2deeb" name="ab63d3505ee5b5f1c949cb042c7f2deeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63d3505ee5b5f1c949cb042c7f2deeb">&#9670;&#160;</a></span>clearRecordingDataCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AQNWB::NWB::RegisteredType::clearRecordingDataCache </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the BaseRecordingData object cache to reset the recording state. </p>

</div>
</div>
<a id="a6f7d3d6d30763215c823452176ed876a" name="a6f7d3d6d30763215c823452176ed876a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7d3d6d30763215c823452176ed876a">&#9670;&#160;</a></span>create() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">AQNWB::NWB::RegisteredType</a> &gt; RegisteredType::create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fullClassName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">IO::BaseIO</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>io</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>fallbackToBase</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an instance of a registered subclass by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fullClassName</td><td>The combined namespace and class name to instantiate, i.e., namespace::class </td></tr>
    <tr><td class="paramname">path</td><td>The path of the registered type. </td></tr>
    <tr><td class="paramname">io</td><td>A shared pointer to the <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html" title="The namespace for IO components of AqNWB.">IO</a> object. </td></tr>
    <tr><td class="paramname">fallbackToBase</td><td>If true, return a base class instance if the full class is not found. The base class to use is defined by m_defaultUnregisteredGroupTypeClass and m_defaultUnregisteredDatasetTypeClass depending on whether the type is a group or dataset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique_ptr to the created instance of the subclass, or nullptr if the subclass is not found. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_a6f7d3d6d30763215c823452176ed876a_cgraph.svg" width="482" height="76"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_a6f7d3d6d30763215c823452176ed876a_icgraph.svg" width="100%" height="584"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a2291ceaa71c1b02ed86a3d4626a7ac48" name="a2291ceaa71c1b02ed86a3d4626a7ac48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2291ceaa71c1b02ed86a3d4626a7ac48">&#9670;&#160;</a></span>create() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; T &gt; AQNWB::NWB::RegisteredType::create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">AQNWB::IO::BaseIO</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>io</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create an instance of a subclass of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> by type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The subclass of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> to instantiate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the container. </td></tr>
    <tr><td class="paramname">io</td><td>A shared pointer to the <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html" title="The namespace for IO components of AqNWB.">IO</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique_ptr to the created instance of the subclass. </dd></dl>

</div>
</div>
<a id="a13dd3c9a0045cb3729ba9cf56e4a2fa7" name="a13dd3c9a0045cb3729ba9cf56e4a2fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13dd3c9a0045cb3729ba9cf56e4a2fa7">&#9670;&#160;</a></span>create() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">AQNWB::NWB::RegisteredType</a> &gt; RegisteredType::create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">IO::BaseIO</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>io</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>fallbackToBase</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create an instance of a subclass of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> from file. </p>
<p>The function: 1) reads the "namespace" and "neurodata_type" attributes at the given path, 2) looks up the corresponding subclass of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> for that type in the type registry 3) instantiates the subclass to represent the object at the path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the registered type. </td></tr>
    <tr><td class="paramname">io</td><td>A shared pointer to the <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html" title="The namespace for IO components of AqNWB.">IO</a> object. </td></tr>
    <tr><td class="paramname">fallbackToBase</td><td>If true, return a base class instance if the full class is not found. The base class to use is defined by m_defaultUnregisteredGroupTypeClass and m_defaultUnregisteredDatasetTypeClass depending on whether the type is a group or dataset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique pointer to the created <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> instance, or nullptr if creation fails. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_a13dd3c9a0045cb3729ba9cf56e4a2fa7_cgraph.svg" width="100%" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="aafbac618f2867992dbe8c2f35a072bae" name="aafbac618f2867992dbe8c2f35a072bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafbac618f2867992dbe8c2f35a072bae">&#9670;&#160;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_q_n_w_b_1_1_types.html#a9f8b64371967b1e93cdb8e5caa8634c9">AQNWB::Types::Status</a> RegisteredType::finalize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalize the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> object. </p>
<p>This method provides a standard interface for finalizing <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> objects. Finalizing means that the function must ensure to generate a valid state of the type in the file. E.g., in the case of a table, the function may generate row indices, column order etc.. Finalize may be called multiple times, e.g., when starting a recording to ensure the file is in a valid state, and then again when stopping the recording to ensure the final state is valid. The default implementation does nothing and returns AQNWB::Types::Status::Success.</p>
<dl class="section return"><dt>Returns</dt><dd>AQNWB::Types::Status::Success if successful, otherwise AQNWB::Types::Status::Failure. </dd></dl>

<p>Reimplemented in <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_dynamic_table.html#af5265103ac7a6ac7548a6a10757a0be5">AQNWB::NWB::DynamicTable</a>, and <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrodes_table.html#a8c91ac320289a2bdc6c55aeb78b4a1ad">AQNWB::NWB::ElectrodesTable</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_aafbac618f2867992dbe8c2f35a072bae_icgraph.svg" width="100%" height="388"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a8a83a775f6a8a94d6ae3428e05ef9bfc" name="a8a83a775f6a8a94d6ae3428e05ef9bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a83a775f6a8a94d6ae3428e05ef9bfc">&#9670;&#160;</a></span>findOwnedTypes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, std::string &gt; RegisteredType::findOwnedTypes </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>types</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html#af7fd0e43e0ffc4d765046020e6929035">AQNWB::IO::SearchMode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>search_mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html#af7fd0e43e0ffc4d765046020e6929035a0bce90db02919671dbe161b9bd8cef05">AQNWB::IO::SearchMode::STOP_ON_TYPE</a></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all typed objects that are owned by this object, i.e., objects that have a neurodata_type and namespace attribute and have this object as there closest parent with an assigned type. </p>
<p>This is a shorthand for calling <span class="tt"><a class="el" href="#ab614b1609f536e88ed1f32762dc3894b" title="Get a shared pointer to the IO object.">getIO()</a>-&gt;findTypes(m_path, types, IO::SearchMode::STOP_ON_TYPE, true);</span></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">types</td><td>The set of types to search for. If an empty set is provided, then all objects with an assigned type (i.e., object that have a neurodata_type and namespace attributed) will be returned. </td></tr>
    <tr><td class="paramname">search_mode</td><td>The search mode to use. By default <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html#af7fd0e43e0ffc4d765046020e6929035a0bce90db02919671dbe161b9bd8cef05" title="Stop searching inside an object once a matching type is found.">IO::SearchMode::STOP_ON_TYPE</a> is used to only retrieve objects that are owned by this object. To recursively search though all types nested within the object set to <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html#af7fd0e43e0ffc4d765046020e6929035aec2c6b5e5e8c3b3810251e9974647ef8" title="Continue searching inside an object even after a matching type is found.">IO::SearchMode::CONTINUE_ON_TYPE</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unordered map where each key is the path to an object and its corresponding value is the type of the object. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_a8a83a775f6a8a94d6ae3428e05ef9bfc_cgraph.svg" width="482" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ad3753ec40e8c6b6fafa59ca80433e978" name="ad3753ec40e8c6b6fafa59ca80433e978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3753ec40e8c6b6fafa59ca80433e978">&#9670;&#160;</a></span>getCacheRecordingData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt; std::string, std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_recording_data.html">IO::BaseRecordingData</a> &gt; &gt; &amp; AQNWB::NWB::RegisteredType::getCacheRecordingData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the cache of BaseRecordingData objects. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the cache of BaseRecordingData objects </dd></dl>

</div>
</div>
<a id="ac83aa589b9c3ab5a00bab462e58fdbd5" name="ac83aa589b9c3ab5a00bab462e58fdbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83aa589b9c3ab5a00bab462e58fdbd5">&#9670;&#160;</a></span>getFactoryMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, std::pair&lt; std::function&lt; std::shared_ptr&lt; <a class="el" href="#aa1e04074725b7331d725bbda8156bc2d">RegisteredType</a> &gt;(const std::string &amp;, std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">AQNWB::IO::BaseIO</a> &gt;)&gt;, std::pair&lt; std::string, std::string &gt; &gt; &gt; &amp; RegisteredType::getFactoryMap </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the factory map for creating instances of subclasses. </p>
<p>The factory map is a function-local static variable, which means it is lazily initialized on the first call to this function and persists for the duration of the program. This implementation provides thread-safety and avoids the static initialization order fiasco.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to an unordered_map containing factory functions for registered subclasses. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_ac83aa589b9c3ab5a00bab462e58fdbd5_icgraph.svg" width="100%" height="584"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a0e670647b466cb65a88b81f9fe4a6e37" name="a0e670647b466cb65a88b81f9fe4a6e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e670647b466cb65a88b81f9fe4a6e37">&#9670;&#160;</a></span>getFullTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string AQNWB::NWB::RegisteredType::getFullTypeName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the full name of the type, i.e., <span class="tt">namespace::typename</span>. </p>
<p>This is just a simple convenience function that uses the getNamespace and getTypeName methods.</p>
<dl class="section return"><dt>Returns</dt><dd>The full name of the type consisting of <span class="tt">namespace::typename</span> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_a0e670647b466cb65a88b81f9fe4a6e37_cgraph.svg" width="482" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ab614b1609f536e88ed1f32762dc3894b" name="ab614b1609f536e88ed1f32762dc3894b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab614b1609f536e88ed1f32762dc3894b">&#9670;&#160;</a></span>getIO()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">AQNWB::IO::BaseIO</a> &gt; AQNWB::NWB::RegisteredType::getIO </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a shared pointer to the <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html" title="The namespace for IO components of AqNWB.">IO</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to the <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html" title="The namespace for IO components of AqNWB.">IO</a> object. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_ab614b1609f536e88ed1f32762dc3894b_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a9fa62ba79d610ba55aacec4dce012ccf" name="a9fa62ba79d610ba55aacec4dce012ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa62ba79d610ba55aacec4dce012ccf">&#9670;&#160;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string AQNWB::NWB::RegisteredType::getName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the object. </p>
<p>This is the last part of <a class="el" href="#a079202bc1ce62c7f5794f5b658598b8c" title="Gets the path of the registered type.">getPath()</a>, much like the filename portion of a file system path. </p><dl class="section return"><dt>Returns</dt><dd>String with the name of the object </dd></dl>

</div>
</div>
<a id="a651f3d7e5cc28dc93888e8a821c5aa1c" name="a651f3d7e5cc28dc93888e8a821c5aa1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651f3d7e5cc28dc93888e8a821c5aa1c">&#9670;&#160;</a></span>getNamespace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string RegisteredType::getNamespace </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the schema namespace of the class type. </p>
<p>This is the namespace of the neurodata_type in the format schema and NOT the namespace of the class in C++. The REGISTER_SUBCLASS macro defines an automatic override for this function to return the namespace as defined when the class was registered.</p>
<dl class="section return"><dt>Returns</dt><dd>The namespace of the type as a string. </dd></dl>

<p>Reimplemented in <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_annotation_series.html#a098c3c29e8df100c88029d9b9f5c88e9">AQNWB::NWB::AnnotationSeries</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html#a1a8f53595eb2637e32e816a3ff99a230">AQNWB::NWB::Container</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data.html#a4492a59ec08422039f9d0bc509ffd06d">AQNWB::NWB::Data</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_device.html#af5743857e9c51c99360776cc757bc025">AQNWB::NWB::Device</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_dynamic_table.html#a92b40bccab43dde705a6fa86872cea32">AQNWB::NWB::DynamicTable</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html#ae01cb16c642e895a4de05e64debd8dc7">AQNWB::NWB::ElectricalSeries</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrode_group.html#ac9f300e2308bb4849cf44b733064746d">AQNWB::NWB::ElectrodeGroup</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrodes_table.html#a92e0a4427f4eeb032b20c679876f8688">AQNWB::NWB::ElectrodesTable</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_element_identifiers.html#ab51c8869b9168dc945dcfc61692ae32c">AQNWB::NWB::ElementIdentifiers</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_container.html#aa7ada6d9ac9c045bd810efb56d89bd8e">AQNWB::NWB::NWBContainer</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_data.html#a53e8bf3b98dda1c724eb53e6ff488573">AQNWB::NWB::NWBData</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_data_interface.html#a6fdcd6e22958c158470aed44495ee779">AQNWB::NWB::NWBDataInterface</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html#a0b44558c283edd9db7d2fcf284c1a5ec">AQNWB::NWB::NWBFile</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_processing_module.html#ae720de3c7079deb1417636cc5a557096">AQNWB::NWB::ProcessingModule</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_spike_event_series.html#af5db02bc128a66c17702fa5c2ae5eaa5">AQNWB::NWB::SpikeEventSeries</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_time_series.html#a939a4213950507861a18207b460d72ad">AQNWB::NWB::TimeSeries</a>, and <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html#a14d3fb14c1eb5cb40bf37a8666d32a91">AQNWB::NWB::VectorData</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_a651f3d7e5cc28dc93888e8a821c5aa1c_icgraph.svg" width="482" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a079202bc1ce62c7f5794f5b658598b8c" name="a079202bc1ce62c7f5794f5b658598b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079202bc1ce62c7f5794f5b658598b8c">&#9670;&#160;</a></span>getPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; AQNWB::NWB::RegisteredType::getPath </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the path of the registered type. </p>
<dl class="section return"><dt>Returns</dt><dd>The path of the registered type. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_a079202bc1ce62c7f5794f5b658598b8c_icgraph.svg" width="486" height="207"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ac277f0e6485c7c8050a76324eb994223" name="ac277f0e6485c7c8050a76324eb994223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac277f0e6485c7c8050a76324eb994223">&#9670;&#160;</a></span>getRecordingObjectIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> RegisteredType::getRecordingObjectIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of this object in m_io-&gt;m_recording_objects. </p>
<dl class="section return"><dt>Returns</dt><dd>Index of the object of <a class="el" href="class_a_q_n_w_b_1_1_types.html#a489c41cdd124123f0595271873e00dbe" title="Value to use to indicate that a SizeType index is not set.">AQNWB::Types::SizeTypeNotSet</a> if the object is not registered </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_ac277f0e6485c7c8050a76324eb994223_cgraph.svg" width="482" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_ac277f0e6485c7c8050a76324eb994223_icgraph.svg" width="482" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ab7e3361637885fe601cc20cb342bf01c" name="ab7e3361637885fe601cc20cb342bf01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e3361637885fe601cc20cb342bf01c">&#9670;&#160;</a></span>getRegistry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; std::string &gt; &amp; RegisteredType::getRegistry </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the registry of subclass names. </p>
<p>The registry is a function-local static variable, which means it is lazily initialized on the first call to this function and persists for the duration of the program. This implementation provides thread-safety and avoids the static initialization order fiasco.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to an unordered_set containing the names of all registered subclasses. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_ab7e3361637885fe601cc20cb342bf01c_icgraph.svg" width="482" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a150f881ad61cb8352eea7ddba47bc6ad" name="a150f881ad61cb8352eea7ddba47bc6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150f881ad61cb8352eea7ddba47bc6ad">&#9670;&#160;</a></span>getTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string RegisteredType::getTypeName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the class type. </p>
<p>The REGISTER_SUBCLASS macro defines an automatic override for this function to return the unmangled name of the class. The name of the class must be the same as the neurodata_type that it implements.</p>
<dl class="section return"><dt>Returns</dt><dd>The name of the type as a string </dd></dl>

<p>Reimplemented in <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_annotation_series.html#a1a1d20183ab9f430020d88e003f07ae4">AQNWB::NWB::AnnotationSeries</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html#a21e3abbea48e9455731f2859c7954c97">AQNWB::NWB::Container</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data.html#a27b6db1fbbd11f84f76456be6c6a741e">AQNWB::NWB::Data</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_device.html#a33695e62396fdd0b48b2174f403ed574">AQNWB::NWB::Device</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_dynamic_table.html#ae55c617c34e682979efa695f422f295a">AQNWB::NWB::DynamicTable</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html#a8b63df4e42d0e98a9ed1e77a51dce8ff">AQNWB::NWB::ElectricalSeries</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrode_group.html#a41a5e46de5e0105ed72884630e2533aa">AQNWB::NWB::ElectrodeGroup</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrodes_table.html#a86ce3df2575a741dcd413fe27d1135c3">AQNWB::NWB::ElectrodesTable</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_element_identifiers.html#a8793b33175692d985adc438bd769457a">AQNWB::NWB::ElementIdentifiers</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_container.html#abdefb9b990197efa6550ab3b1d1dcf66">AQNWB::NWB::NWBContainer</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_data.html#af415f9629621a1b99bfcf202787d68b1">AQNWB::NWB::NWBData</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_data_interface.html#a5e7c44e6c2e60f4da2154c31a40ce861">AQNWB::NWB::NWBDataInterface</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html#ae22dafcb8cb963103fe0e2b4cbfd5dd8">AQNWB::NWB::NWBFile</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_processing_module.html#a826c9a9889cabdc773e9d105579cfba8">AQNWB::NWB::ProcessingModule</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_spike_event_series.html#a9166033a4ff6e69f79ca64adbe591ae4">AQNWB::NWB::SpikeEventSeries</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_time_series.html#aceff608228b87017b836a4a97f5b470d">AQNWB::NWB::TimeSeries</a>, and <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html#a9e1ef6be8f543a60dd03eef09d648c36">AQNWB::NWB::VectorData</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_a150f881ad61cb8352eea7ddba47bc6ad_icgraph.svg" width="482" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae66a9bc325b1ddb2c6a5f537feb8591a" name="ae66a9bc325b1ddb2c6a5f537feb8591a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66a9bc325b1ddb2c6a5f537feb8591a">&#9670;&#160;</a></span>isRegisteredRecordingObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AQNWB::NWB::RegisteredType::isRegisteredRecordingObject </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> object is registered in the RecordingObjects manager object of the I/O. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the object is registered, false otherwise. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_ae66a9bc325b1ddb2c6a5f537feb8591a_cgraph.svg" width="100%" height="376"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a07451eb27d98493d2d362129a3934a4d" name="a07451eb27d98493d2d362129a3934a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07451eb27d98493d2d362129a3934a4d">&#9670;&#160;</a></span>readField() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">AQNWB::NWB::RegisteredType</a> &gt; AQNWB::NWB::RegisteredType::readField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fieldPath</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a field that is itself a <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldPath</td><td>The relative path of the field within the current type, i.e., relative to m_path. The field must itself be <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique_ptr to the created instance of the subclass. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_a07451eb27d98493d2d362129a3934a4d_cgraph.svg" width="100%" height="443"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="adc5ba3d9e27c74f8181944e505bba6e5" name="adc5ba3d9e27c74f8181944e505bba6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5ba3d9e27c74f8181944e505bba6e5">&#9670;&#160;</a></span>readField() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_a_q_n_w_b_1_1_types.html#a778ba605df5dabb117ede12e41111915">StorageObjectType</a> SOT, typename VTYPE, typename std::enable_if&lt; <a class="el" href="struct_a_q_n_w_b_1_1_types_1_1_is_data_storage_object_type.html">Types::IsDataStorageObjectType</a>&lt; SOT &gt;::value, int &gt;::type = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">AQNWB::IO::ReadDataWrapper</a>&lt; SOT, VTYPE &gt; &gt; AQNWB::NWB::RegisteredType::readField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fieldPath</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Support reading of arbitrary fields by their relative path. </p>
<p>This function provided as a general "backup" to support reading of arbitrary fields even if the sub-class may not have an explicit DEFINE_FIELD specified for the field. If a DEFINE_FIELD exists then the corresponding read method should be used as it avoids the need for specifying most (if not all) of the function an template parameters needed by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldPath</td><td>The relative path of the field within the current type, i.e., relative to <span class="tt"><a class="el" href="#a2c2954495607eb4afe4e9ab8eff3a08b" title="The path of the registered type.">m_path</a></span> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SOT</td><td>The storage object type. This must be a either StorageObjectType::Dataset or StorageObjectType::Attribute </td></tr>
    <tr><td class="paramname">VTYPE</td><td>The value type of the field to be read. </td></tr>
    <tr><td class="paramname">Enable</td><td>SFINAE (Substitution Failure Is Not An Error) mechanism to enable this function only if SOT is a Dataset or Attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ReadDataWrapper object for lazy reading of the field </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_adc5ba3d9e27c74f8181944e505bba6e5_cgraph.svg" width="482" height="102"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a9114e761cf006ec16c3733b9f8915f9d" name="a9114e761cf006ec16c3733b9f8915f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9114e761cf006ec16c3733b9f8915f9d">&#9670;&#160;</a></span>registerRecordingObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> RegisteredType::registerRecordingObject </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register this <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> object with the RecordingObjects manager object of the I/O. </p>
<p>This method should be called when this <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> object is being used for recording data. Usually this should be done when the initialize() function of the type is being called. <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html" title="Abstract data type for a group storing collections of data and metadata.">AQNWB::NWB::Container</a> and <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data.html" title="An abstract data type for a dataset.">AQNWB::NWB::Data</a> classes automatically in the initialize() function so most subclasses do not need to call this method explicitly.</p>
<dl class="section return"><dt>Returns</dt><dd>The index at which the object was registered. The sentinel value std::numeric_limits&lt;SizeType&gt;::max(); is returned if the object could not be registered (e.g., if the lookup for the <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html" title="The namespace for IO components of AqNWB.">IO</a> or RecordingObjects failed for some unspecified reason). </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_a9114e761cf006ec16c3733b9f8915f9d_cgraph.svg" width="482" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ab20cf389f4f512056d7755ec23d6d0a9" name="ab20cf389f4f512056d7755ec23d6d0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20cf389f4f512056d7755ec23d6d0a9">&#9670;&#160;</a></span>registerSubclass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RegisteredType::registerSubclass </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fullClassName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::shared_ptr&lt; <a class="el" href="#aa1e04074725b7331d725bbda8156bc2d">RegisteredType</a> &gt;(const std::string &amp;, std::shared_ptr&lt; <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">AQNWB::IO::BaseIO</a> &gt;)&gt;</td>          <td class="paramname"><span class="paramname"><em>factoryFunction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>typeName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>typeNamespace</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a subclass name and its factory function in the registry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fullClassName</td><td>The combined namespace and class name to register. </td></tr>
    <tr><td class="paramname">factoryFunction</td><td>The factory function to create instances of the subclass. </td></tr>
    <tr><td class="paramname">typeName</td><td>The name of the type (usually the class name). </td></tr>
    <tr><td class="paramname">typeNamespace</td><td>The namespace of the type. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_ab20cf389f4f512056d7755ec23d6d0a9_cgraph.svg" width="482" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a30cc61d9d6b91dd6bd767ceccf35fb7f" name="a30cc61d9d6b91dd6bd767ceccf35fb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30cc61d9d6b91dd6bd767ceccf35fb7f">&#9670;&#160;</a></span>m_defaultUnregisteredDatasetTypeClass</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string RegisteredType::m_defaultUnregisteredDatasetTypeClass</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">                                                                    =</div>
<div class="line"><span class="stringliteral">&quot;hdmf-common::Data&quot;</span></div>
</div><!-- fragment -->
<p>Save the default <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> to use for reading Dataset types that are not registered. </p>

</div>
</div>
<a id="ac3e284613a1e28db9875fb06b66b0c19" name="ac3e284613a1e28db9875fb06b66b0c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e284613a1e28db9875fb06b66b0c19">&#9670;&#160;</a></span>m_defaultUnregisteredGroupTypeClass</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string RegisteredType::m_defaultUnregisteredGroupTypeClass</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">                                                                  =</div>
<div class="line"><span class="stringliteral">&quot;hdmf-common::Container&quot;</span></div>
</div><!-- fragment -->
<p>Save the default <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> to use for reading Group types that are not registered. </p>
<p>Set the default <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> to use for unregistered Group and Dataset types </p>

</div>
</div>
<a id="a73f9bb35022892941b8b46a1669605da" name="a73f9bb35022892941b8b46a1669605da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f9bb35022892941b8b46a1669605da">&#9670;&#160;</a></span>m_io</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::weak_ptr&lt;<a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">IO::BaseIO</a>&gt; AQNWB::NWB::RegisteredType::m_io</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A weak pointer to the <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html" title="The namespace for IO components of AqNWB.">IO</a> object. </p>
<p>We use weak_ptr here because the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">RegisteredType</a> object should not own or keep the I/O alive. The users owns the I/O object. Using a weak pointer allows us to access the I/O object without extending its lifetime. This is important to avoid circular dependencies and memory leaks. To ensure safe usage we should always for <a class="el" href="#ab614b1609f536e88ed1f32762dc3894b" title="Get a shared pointer to the IO object.">getIO()</a> to retrieve a shared pointer to the <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html" title="The namespace for IO components of AqNWB.">IO</a> object before using it. </p>

</div>
</div>
<a id="a2c2954495607eb4afe4e9ab8eff3a08b" name="a2c2954495607eb4afe4e9ab8eff3a08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2954495607eb4afe4e9ab8eff3a08b">&#9670;&#160;</a></span>m_path</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string AQNWB::NWB::RegisteredType::m_path</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The path of the registered type. </p>

</div>
</div>
<a id="a549f4d2169ae451bda8d959c9a11dbc3" name="a549f4d2169ae451bda8d959c9a11dbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549f4d2169ae451bda8d959c9a11dbc3">&#9670;&#160;</a></span>m_recordingDataCache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, std::shared_ptr&lt;<a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_recording_data.html">IO::BaseRecordingData</a>&gt; &gt; AQNWB::NWB::RegisteredType::m_recordingDataCache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache for BaseRecordingData objects for datasets to retain recording state. </p>
<p>This map stores shared pointers to BaseRecordingData objects that have been previously requested, using the field path as the key. This allows us to reuse the same object when it is requested multiple times, improving performance and more importantly, retaining the recording position so that we can append to the dataset from the last position that we recorded to. This is important for writing data to the dataset in a streaming fashion. The cache is mutable to allow modification in const methods. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/nwb/<a class="el" href="_registered_type_8hpp_source.html">RegisteredType.hpp</a></li>
<li>src/nwb/<a class="el" href="_registered_type_8cpp.html">RegisteredType.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespace_a_q_n_w_b.html">AQNWB</a></li><li class="navelem"><a href="namespace_a_q_n_w_b_1_1_n_w_b.html">NWB</a></li><li class="navelem"><a href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.1 </li>
  </ul>
</div>
</body>
</html>
