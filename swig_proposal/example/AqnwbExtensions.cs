/*
 * AqnwbExtensions.cs - C# Extension Library for Generic-like Interface
 * 
 * This library provides C# generic methods that map to the type-specific
 * methods generated by SWIG. This gives users the convenience of generic
 * syntax while maintaining the performance of direct type-specific calls.
 * 
 * Usage:
 *   // Direct SWIG methods (fastest)
 *   var data1 = ts.readDataFloat();
 *   
 *   // Generic extension methods (convenient)
 *   var data2 = ts.ReadData<float>();
 *   
 *   // Default method (simple)
 *   var data3 = ts.readData();
 */

using System;

namespace AqnwbExtensions
{
    /// <summary>
    /// Extension methods for TimeSeries that provide generic-like interface
    /// on top of SWIG-generated type-specific methods.
    /// </summary>
    public static class TimeSeriesExtensions
    {
        /// <summary>
        /// Generic data reader that maps to type-specific SWIG methods.
        /// Provides C# generic syntax while using optimized type-specific methods under the hood.
        /// </summary>
        /// <typeparam name="T">The data type to read</typeparam>
        /// <param name="ts">The TimeSeries instance</param>
        /// <returns>ReadDataWrapper for the specified type</returns>
        /// <exception cref="NotSupportedException">Thrown when the type T is not supported</exception>
        public static object ReadData<T>(this TimeSeries ts)
        {
            var type = typeof(T);
            
            // All data types supported by BaseRecordingData (from BaseDataType::Type enum)
            if (type == typeof(byte) || type == typeof(uint8_t))
                return ts.readDataUint8_T();
            else if (type == typeof(ushort) || type == typeof(uint16_t))
                return ts.readDataUint16_T();
            else if (type == typeof(uint) || type == typeof(uint32_t))
                return ts.readDataUint32_T();
            else if (type == typeof(ulong) || type == typeof(uint64_t))
                return ts.readDataUint64_T();
            else if (type == typeof(sbyte) || type == typeof(int8_t))
                return ts.readDataInt8_T();
            else if (type == typeof(short) || type == typeof(int16_t))
                return ts.readDataInt16_T();
            else if (type == typeof(int) || type == typeof(int32_t))
                return ts.readDataInt32_T();
            else if (type == typeof(long) || type == typeof(int64_t))
                return ts.readDataInt64_T();
            else if (type == typeof(float))
                return ts.readDataFloat();
            else if (type == typeof(double))
                return ts.readDataDouble();
            else if (type == typeof(string))
                return ts.readDataStd_String();
            else if (type == typeof(object) || type == typeof(System.Object))
                return ts.readData(); // Default std::any version
            else
                throw new NotSupportedException(
                    $"Type {type.Name} is not supported. " +
                    $"Supported types: byte/uint8_t, ushort/uint16_t, uint/uint32_t, ulong/uint64_t, " +
                    $"sbyte/int8_t, short/int16_t, int/int32_t, long/int64_t, float, double, string, object");
        }

        /// <summary>
        /// Generic timestamp reader that maps to type-specific SWIG methods.
        /// </summary>
        /// <typeparam name="T">The timestamp data type (typically double)</typeparam>
        /// <param name="ts">The TimeSeries instance</param>
        /// <returns>ReadDataWrapper for timestamps</returns>
        public static object ReadTimestamps<T>(this TimeSeries ts)
        {
            var type = typeof(T);
            
            if (type == typeof(double))
                return ts.readTimestamps();
            else if (type == typeof(float))
                // Could add readTimestampsFloat if needed in SWIG generation
                throw new NotSupportedException("Float timestamps not currently supported. Use double.");
            else
                throw new NotSupportedException(
                    $"Type {type.Name} is not supported for timestamps. Use double.");
        }

        /// <summary>
        /// Generic control data reader.
        /// </summary>
        /// <typeparam name="T">The control data type (typically uint8_t/byte)</typeparam>
        /// <param name="ts">The TimeSeries instance</param>
        /// <returns>ReadDataWrapper for control data</returns>
        public static object ReadControl<T>(this TimeSeries ts)
        {
            var type = typeof(T);
            
            if (type == typeof(byte) || type == typeof(uint8_t))
                return ts.readControl();
            else
                throw new NotSupportedException(
                    $"Type {type.Name} is not supported for control data. Use byte/uint8_t.");
        }

        /// <summary>
        /// Generic attribute reader for string attributes.
        /// </summary>
        /// <typeparam name="T">The attribute type (must be string for most attributes)</typeparam>
        /// <param name="ts">The TimeSeries instance</param>
        /// <param name="attributeName">Name of the attribute to read</param>
        /// <returns>ReadDataWrapper for the attribute</returns>
        public static object ReadAttribute<T>(this TimeSeries ts, string attributeName)
        {
            var type = typeof(T);
            
            switch (attributeName.ToLower())
            {
                case "description":
                    if (type == typeof(string))
                        return ts.readDescription();
                    break;
                    
                case "comments":
                    if (type == typeof(string))
                        return ts.readComments();
                    break;
                    
                case "unit":
                    if (type == typeof(string))
                        return ts.readDataUnit();
                    break;
                    
                case "conversion":
                    if (type == typeof(float))
                        return ts.readDataConversion();
                    break;
                    
                default:
                    throw new ArgumentException($"Unknown attribute: {attributeName}");
            }
            
            throw new NotSupportedException(
                $"Type {type.Name} is not supported for attribute {attributeName}");
        }
    }

    /// <summary>
    /// Fluent interface builder for type-safe data access.
    /// Provides a more object-oriented approach to data reading.
    /// </summary>
    /// <typeparam name="T">The data type</typeparam>
    public class TypedDataReader<T>
    {
        private readonly TimeSeries _timeSeries;

        public TypedDataReader(TimeSeries timeSeries)
        {
            _timeSeries = timeSeries ?? throw new ArgumentNullException(nameof(timeSeries));
        }

        /// <summary>
        /// Read the main data with the specified type.
        /// </summary>
        public object Data => _timeSeries.ReadData<T>();

        /// <summary>
        /// Read timestamps (if T is double).
        /// </summary>
        public object Timestamps
        {
            get
            {
                if (typeof(T) == typeof(double))
                    return _timeSeries.ReadTimestamps<T>();
                else
                    return _timeSeries.readTimestamps(); // Default double version
            }
        }

        /// <summary>
        /// Read control data (if T is byte/uint8_t).
        /// </summary>
        public object Control
        {
            get
            {
                if (typeof(T) == typeof(byte))
                    return _timeSeries.ReadControl<T>();
                else
                    return _timeSeries.readControl(); // Default uint8_t version
            }
        }
    }

    /// <summary>
    /// Factory class for creating typed data readers.
    /// </summary>
    public static class DataReaderFactory
    {
        /// <summary>
        /// Create a typed data reader for the specified type.
        /// </summary>
        /// <typeparam name="T">The data type</typeparam>
        /// <param name="timeSeries">The TimeSeries instance</param>
        /// <returns>A typed data reader</returns>
        public static TypedDataReader<T> CreateReader<T>(TimeSeries timeSeries)
        {
            return new TypedDataReader<T>(timeSeries);
        }

        /// <summary>
        /// Create a float data reader.
        /// </summary>
        public static TypedDataReader<float> CreateFloatReader(TimeSeries timeSeries)
        {
            return new TypedDataReader<float>(timeSeries);
        }

        /// <summary>
        /// Create a double data reader.
        /// </summary>
        public static TypedDataReader<double> CreateDoubleReader(TimeSeries timeSeries)
        {
            return new TypedDataReader<double>(timeSeries);
        }

        /// <summary>
        /// Create an integer data reader.
        /// </summary>
        public static TypedDataReader<int> CreateIntReader(TimeSeries timeSeries)
        {
            return new TypedDataReader<int>(timeSeries);
        }
    }
}

/*
 * Example Usage:
 * 
 * using AqnwbExtensions;
 * 
 * // Method 1: Direct SWIG methods (fastest)
 * var directFloat = ts.readDataFloat();
 * var directDouble = ts.readDataDouble();
 * 
 * // Method 2: Generic extension methods (convenient)
 * var genericFloat = ts.ReadData<float>();
 * var genericDouble = ts.ReadData<double>();
 * var genericTimestamps = ts.ReadTimestamps<double>();
 * 
 * // Method 3: Fluent typed reader (object-oriented)
 * var floatReader = DataReaderFactory.CreateFloatReader(ts);
 * var data = floatReader.Data;
 * var timestamps = floatReader.Timestamps;
 * 
 * // Method 4: Generic typed reader
 * var reader = DataReaderFactory.CreateReader<float>(ts);
 * var typedData = reader.Data;
 * 
 * // Method 5: Attribute reading with generics
 * var description = ts.ReadAttribute<string>("description");
 * var conversion = ts.ReadAttribute<float>("conversion");
 */
