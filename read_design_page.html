<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>aqnwb: Implementation of Data Read ðŸ“¤</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom-modern.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="aqnwb-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">aqnwb<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td></tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('read_design_page.html','',''); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
</script>
<div id="main-nav"></div>
<div id="container"><div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Implementation of Data Read ðŸ“¤ </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page focuses on the software architecture of AqNWB for implementing data read and is mainly aimed at software developers. See <a class="el" href="read_page.html">Reading Data ðŸ“¤</a> if you want to learn more about how read is used in practice. The read system in AqNWB is built around several key concepts:</p>
<ol type="1">
<li><b>Lazy loading of datasets and attributes through wrapper objects</b>, discussed in <a class="el" href="#read_design_sec_read_date">Reading datasets and attributes</a></li>
<li><b>Dynamic type creation through a registration system</b>, discussed in <a class="el" href="#reading_neurodata_type_objects">Reading neurodata_type objects</a></li>
<li><b>Field access through generated accessor methods</b>. See the <a class="el" href="registered_type_page.html">Implementing a Registered Type ðŸ”§</a> page to learn more about the macros used to generate accessor methods.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="read_design_sec_read_date"></a>
Reading datasets and attributes</h1>
<p>AqNWB reads datasets and attributes lazily via wrappers. The main components involved in reading data from an NWB file via AqNWB are:</p>
<ol type="1">
<li><a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html">Container</a><ul>
<li><a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html">Container</a> type classes represent Groups with an assigned <span class="tt">neurodata_type</span> (e.g., <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html">ElectricalSeries</a> or <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html">NWBFile</a>) and expose read access to their specific datasets and attributes via corresponding functions, which return <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a> objects for lazily reading from the dataset/attribute.</li>
</ul>
</li>
<li><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a><ul>
<li><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a> is a simple wrapper class that represents a dataset/attribute for read, enabling lazy data read and allowing for transparent use of different I/O backends. The <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a> then calls the I/O backend to retrieve data lazily when the user requests access.</li>
<li>To create a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a> object a user will typically use either pre-definied read methods created via the <a class="el" href="_registered_type_8hpp.html#a9f1005a8dc218dba0592fe5d5aaedb0c">DEFINE_ATTRIBUTE_FIELD</a> or <a class="el" href="_registered_type_8hpp.html#aeb21020579ca18f10e64fac9689a7ef6">DEFINE_DATASET_FIELD</a> macros (see also <a class="el" href="registered_type_page.html#use_the_define_attribute_field_macro">DEFINE_ATTRIBUTE_FIELD: Creating read methods for attributes</a> and <a class="el" href="registered_type_page.html#use_the_define_dataset_field_macro">DEFINE_DATASET_FIELD: Creating read and write methods for datasets</a>) or the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#adc5ba3d9e27c74f8181944e505bba6e5">RegisteredType::readField</a> method.</li>
</ul>
</li>
<li><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">BaseIO</a><ul>
<li><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">BaseIO</a>, <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_i_o.html">HDF5IO</a> is then responsible for reading data from disk and allocating memory for data on read. Read methods, e.g., <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a59ab1d7c744d05623aa8626643e37a74">readDataset</a> and <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#aa9b3fc349e4149f6b1c75bb854deae07">readAttribute</a>, then return data as <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block_generic.html">DataBlockGeneric</a>. This has the advantage that we can let the backend handle memory allocation and typing for us and load data even if we don't know the type yet.</li>
</ul>
</li>
<li><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block_generic.html">DataBlockGeneric</a><ul>
<li><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block_generic.html">DataBlockGeneric</a> represents a generic, n-dimensional block of data loaded from a file, storing the data as a generic <span class="tt">std::any</span> along with the <span class="tt">shape</span> of the data. Users will create <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block_generic.html">DataBlockGeneric</a> objects usually via <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html#a87906c320c5ca820768eacc98e8b09ca">ReadDatasetWrapper.valuesGeneric</a> and <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_i_o.html#a805558f3372cd322dd8bb109151670d8">HDF5IO.readDataset</a>.</li>
</ul>
</li>
<li><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html">DataBlock</a><ul>
<li><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html">DataBlock</a> represents a typed, n-dimensional block of data, derived from a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block_generic.html">DataBlockGeneric</a> usually via the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#a20df6af7d661de38f4b8cb3baba48339">DataBlock.fromGeneric</a> factory method. <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html">DataBlock</a> is templated on the specific data type, and stores the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#a7e084bd163c177f45c41cdf93b61f2b6">data</a> as an appropriately typed 1-dimensional <span class="tt">std::vector</span> along with the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#adcd06e1ef4d9ab65081f8e5ab49eec36">shape</a> of the data.</li>
</ul>
</li>
<li><a href="https://www.boost.org/doc/libs/1_83_0/libs/multi_array/doc/user.html">BOOST::multi_array</a><ul>
<li><span class="tt">BOOST::multi_array</span> can also be used simplify access to multi-dimensional data. The <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#a39c4d437721b818aac335f3c9a57dc97">DataBlock.as_multi_array</a> convenience method generates a <span class="tt">boost::const_multi_array_ref&lt;DTYPE, NDIMS&gt;</span> for us.</li>
</ul>
</li>
<li><a href="https://en.cppreference.com/w/cpp/utility/variant">std::variant</a><ul>
<li>`<span class="tt">std::variant</span> can also be used when we want to compute on the data in a type-safe manner but do not know the data type beforehand (e.g., when reading NWB data from a third party).</li>
</ul>
</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#a20df6af7d661de38f4b8cb3baba48339">DataBlock.fromGeneric</a>, <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#a39c4d437721b818aac335f3c9a57dc97">DataBlock.as_multi_array</a>, and <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block_generic.html#a957ab6f55f6be707def1ae317948a6eb">DataBlockGeneric.as_variant</a> methods use casting and referencing to transform the data without making additional copies of the data.</dd></dl>
<div class="dotgraph">
<iframe scrolling="no" loading="lazy" frameborder="0" src="dot_inline_dotgraph_2.svg" width="982" height="826"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<h1 class="doxsection"><a class="anchor" id="reading_neurodata_type_objects"></a>
Reading neurodata_type objects</h1>
<p>NWB <span class="tt">neurodata_types</span> are represented in AqNWB as classes that inherit from <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> (see also <a class="el" href="registered_type_page.html">Implementing a Registered Type ðŸ”§</a>). <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> in turn maintains a registry of all available registered types that it uses to support convenient read of <span class="tt">neurodata_type</span> objects from an NWB file. For read, a user then typically uses either:</p><ul>
<li>Pre-defined read methods created via the <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a> or <a class="el" href="_registered_type_8hpp.html#aee89c439c94a4a8aa1f42024d063e4c0">DEFINE_UNNAMED_REGISTERED_FIELD</a> macros (see also <a class="el" href="registered_type_page.html#use_the_define_registered_field_macro">DEFINE_REGISTERED_FIELD: Defining read methods for neurodata_type objects</a>).</li>
<li><a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#adc5ba3d9e27c74f8181944e505bba6e5">RegisteredType::readField</a> to read arbitrary registered fields.</li>
<li><a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">RegisteredType::create</a> to manually create a <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> from a file.</li>
<li>Construct the specific class directly using a known <span class="tt">path</span> and <span class="tt">io</span> object.</li>
</ul>
<p>The main components involved in reading typed objects from an NWB file via AqNWB are:</p>
<ul>
<li><a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> as the main base class for all classes implementing a type, e.g., <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html">Container</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data.html">Data</a> and all their subtypes. <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> is responsible for managing all type classes and provides the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">create</a> factory methods for creating instances of subclasses from a file.</li>
<li><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">BaseIO</a>, <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_i_o.html">HDF5IO</a> are responsible for i) reading type attribute and group information, ii) searching the file for typed objects via <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a788603f4c9c2698aad610134ab89f8e1">findTypes()</a> methods, and iii) retrieving the paths of all object associated with a storage object (e.g., a Group) via <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a981d7a455b4c057f8ade5c511afbb2ba">getStorageObjects()</a></li>
</ul>
<p>Here we focus mainly on the design of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> itself. If you want to learn more about how to implement a new subclass of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> then please see <a class="el" href="registered_type_page.html">Implementing a Registered Type ðŸ”§</a>.</p>
<div class="dotgraph">
<iframe scrolling="no" loading="lazy" frameborder="0" src="dot_inline_dotgraph_3.svg" width="772" height="515"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<h2 class="doxsection"><a class="anchor" id="type_registry"></a>
How the Type Registry in RegisteredType Works</h2>
<p>The type registry in <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> allows for dynamic creation of registered subclasses by name. Here is how it works:</p>
<ol type="1">
<li><b>Registry Storage</b>:<ul>
<li>The registry is stored as static members within the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> class and is implemented using 1) an <span class="tt">std::unordered_set</span> to store subclass names (which can be accessed via <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#ab7e3361637885fe601cc20cb342bf01c">getRegistry()</a>) and 2) an <span class="tt">std::unordered_map</span> to store factory functions for creating instances of the subclasses (which can be accessed via <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#ac83aa589b9c3ab5a00bab462e58fdbd5">getFactoryMap()</a>). The factory methods are the required constructor that uses the io and path as input.</li>
</ul>
</li>
<li><b>Preparing for Registration</b>: <a class="el" href="_registered_type_8hpp.html#a48542bb43b1d1c733f729eb3f123c9dd">REGISTER_SUBCLASS</a><ul>
<li>The <a class="el" href="_registered_type_8hpp.html#a48542bb43b1d1c733f729eb3f123c9dd">REGISTER_SUBCLASS</a> macro macro modifies the class to make it ready for registration by:<ul>
<li>Creating the <span class="tt">_registered</span> field to trigger the registration when the subclass is loaded</li>
<li>Defining a static method <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#ab20cf389f4f512056d7755ec23d6d0a9">registerSubclass</a>, which is used to add a subclass name and its corresponding factory function to the registry.</li>
<li>Adding <span class="tt">getTypeName</span> and <span class="tt">getNamespace</span> functions for defining the <span class="tt">neurodata_type</span> name</li>
</ul>
</li>
<li><a class="el" href="_registered_type_8hpp.html#a9401c336dd314b808058449cf8567033">REGISTER_SUBCLASS_WITH_TYPENAME</a> is a special version of the <a class="el" href="_registered_type_8hpp.html#a48542bb43b1d1c733f729eb3f123c9dd">REGISTER_SUBCLASS</a> macro, which allows setting the typename explicitly as a third argument. This is for the <b>special case</b> where the name of the class cannot be the same as the name of the type (see also <a class="el" href="registered_type_page.html#using_registered_subclass_with_typename">How to implement a RegisteredType with a custom type name</a>)</li>
</ul>
</li>
<li><b>Actual automatic Registration</b>: <a class="el" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a><ul>
<li>The <a class="el" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a> macro initializes the static member (<span class="tt">registered_</span>), which triggers the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#ab20cf389f4f512056d7755ec23d6d0a9">registerSubclass</a> method and ensures that the subclass is registered when the program starts.</li>
</ul>
</li>
<li><b>Dynamic Creation</b>:<ul>
<li>The <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">RegisteredType::create</a> method is used to create an instance of a registered subclass by name. This method looks up the subclass name in the registry and calls the corresponding factory function to create an instance.</li>
</ul>
</li>
<li><b>Class Name and Namespace Retrieval</b>:<ul>
<li>The <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a150f881ad61cb8352eea7ddba47bc6ad">getTypeName</a> and <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a651f3d7e5cc28dc93888e8a821c5aa1c">getNamespace</a> return the string name of the class and namespace, respectively. The <span class="tt"><a class="el" href="_registered_type_8hpp.html#a48542bb43b1d1c733f729eb3f123c9dd" title="Macro to register a subclass with the RegisteredType class registry.">REGISTER_SUBCLASS</a></span> macro implements an automatic override of the methods to ensure the appropriate type and namespace string are returned. These methods should, hence, not be manually overridden by subclasses, to ensure consistency in type identification.</li>
</ul>
</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="use_registered_type_registry"></a>
How to Use the RegisteredType Registry</h2>
<p>The <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> registry allows for dynamic creation and management of registered subclasses. Here is how you can use it:</p>
<ol type="1">
<li><b>Creating Instances Dynamically</b>:<ul>
<li>Use the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">create</a> method to create an instance of a registered subclass by name.</li>
<li>This method takes the subclass name, path, and a shared pointer to the IO object as arguments. This illustrates how we can read a specific typed object in an NWB file. <div class="fragment"><div class="line">    <span class="comment">// Create an instance of an TimeSeries in a file.</span></div>
<div class="line">    <span class="keyword">auto</span> instance =</div>
<div class="line">        <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">AQNWB::NWB::RegisteredType::create</a>(<span class="stringliteral">&quot;core::TimeSeries&quot;</span>, dataPath, io);</div>
<div class="line">    REQUIRE(instance != <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --></li>
</ul>
</li>
<li><b>Retrieving Registered Subclass Names</b>:<ul>
<li>Use the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#ab7e3361637885fe601cc20cb342bf01c">getRegistry</a> method to retrieve the set of registered subclass names. <div class="fragment"><div class="line">    <span class="comment">// Retrieve and print registered subclass names</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; registry = <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#ab7e3361637885fe601cc20cb342bf01c">AQNWB::NWB::RegisteredType::getRegistry</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Registered subclasses:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; subclassName : registry) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; subclassName &lt;&lt; std::endl;</div>
<div class="line">    }</div>
</div><!-- fragment --></li>
</ul>
</li>
<li><b>Retrieving the Factory Map</b>:<ul>
<li>Use the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#ac83aa589b9c3ab5a00bab462e58fdbd5">getFactoryMap</a> method to retrieve the map of factory functions for creating instances of registered subclasses. <div class="fragment"><div class="line">    <span class="comment">// Retrieve and print factory map</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; factoryMap = <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#ac83aa589b9c3ab5a00bab462e58fdbd5">AQNWB::NWB::RegisteredType::getFactoryMap</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Factory functions for registered subclasses:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pair : factoryMap) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; pair.first &lt;&lt; std::endl;</div>
<div class="line">    }</div>
</div><!-- fragment --></li>
</ul>
</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="read_design_templates"></a>
Reading templated RegisteredType classes</h2>
<p>To facilitate the reading of data arrays and handle data types in a type-safe manner, AqNWB utilizes templated classes. For instance, the <span class="tt">VectorData</span> type in NWB may represent data arrays with varying data types (e.g., <span class="tt">int</span>, <span class="tt">string</span>, etc.). Accordingly, AqNWB implements the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> class, which exposes the data as <span class="tt">std::any</span> via the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data.html#a7dad9d54ec248dda4cc9a168659382bf">VectorData::readData</a> method for reading.</p>
<p>In some cases, the data type for <span class="tt">VectorData</span> may be predetermined in the schema. For example, the <span class="tt">location</span> column of the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrodes_table.html">ElectrodesTable</a> requires string data. To simplify reading in such cases where the data type is fixed, AqNWB defines <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a>, which inherits from <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a>. This class allows the data type to be specified at compile time via the class template, enabling <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;::readData</a> to expose the data with the type already set at compile time. When used in combination with the <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a> macro, this approach allows <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrodes_table.html#a12b45f8a1b32e2e5f38f731497f55ca0">ElectrodesTable::readLocationColumn</a> to return the data to the user with the type already set. The same approach is also applied in the case of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data.html">Data</a> and its derived class <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data_typed.html">DataTyped</a>.</p>
<p>For further details and alternative approaches for implementing templated <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> classes, see <a class="el" href="registered_type_page.html#implement_templated_registered_type">Templated RegisteredType Classes</a>. <br  />
</p>
<div class="fragment"><div class="line">    <span class="comment">// Read as generic RegisteredType and case to VectorData</span></div>
<div class="line">    <span class="keyword">auto</span> readDataUntyped = <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">NWB::RegisteredType::create</a>(dataPath, io);</div>
<div class="line">    <span class="keyword">auto</span> readVectorData =</div>
<div class="line">        std::dynamic_pointer_cast&lt;NWB::VectorData&gt;(readDataUntyped);</div>
<div class="line">    <span class="comment">// Read data as DataBlock&lt;std::any&gt;</span></div>
<div class="line">    <span class="keyword">auto</span> dataAny = readVectorData-&gt;readData();</div>
<div class="line">    <span class="keyword">auto</span> dataBlock = dataAny-&gt;valuesGeneric();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create VectorDataTyped&lt;int&gt; from VectorData and read the</span></div>
<div class="line">    <span class="comment">// data as typed DataBlock&lt;int&gt;</span></div>
<div class="line">    <span class="keyword">auto</span> readVectorDataTyped =</div>
<div class="line">        <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html#ab5c4d5084bb6134318dce6637fdd13e4">NWB::VectorDataTyped&lt;int&gt;::fromVectorData</a>(readVectorData);</div>
<div class="line">    <span class="keyword">auto</span> dataInt = readVectorDataTyped-&gt;readData();</div>
<div class="line">    <span class="keyword">auto</span> dataBlockInt = dataInt-&gt;values();</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="use_registered_type_registry_example"></a>
Example: Using the type registry</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_base_i_o_8hpp.html">io/BaseIO.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_h_d_f5_i_o_8hpp.html">io/hdf5/HDF5IO.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_h_d_f5_recording_data_8hpp.html">io/hdf5/HDF5RecordingData.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_registered_type_8hpp.html">nwb/RegisteredType.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_time_series_8hpp.html">nwb/base/TimeSeries.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;testUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_a_q_n_w_b_1_1_n_w_b.html">AQNWB::NWB</a>;</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;RegisterType Example&quot;</span>, <span class="stringliteral">&quot;[base]&quot;</span>)</div>
<div class="line">{</div>
<div class="line">  SECTION(<span class="stringliteral">&quot;Example to illustrate how the RegisterType registry is working&quot;</span>)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// [example_RegisterType_setup_file]</span></div>
<div class="line">    <span class="comment">// Mock data</span></div>
<div class="line">    <a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> numSamples = 10;</div>
<div class="line">    std::string dataPath = <span class="stringliteral">&quot;/tsdata&quot;</span>;</div>
<div class="line">    std::vector&lt;SizeType&gt; dataShape = {numSamples};</div>
<div class="line">    std::vector&lt;SizeType&gt; positionOffset = {0};</div>
<div class="line">    BaseDataType dataType = BaseDataType::F32;</div>
<div class="line">    std::vector&lt;float&gt; data = getMockData1D(numSamples);</div>
<div class="line">    std::vector&lt;double&gt; timestamps = getMockTimestamps(numSamples, 1);</div>
<div class="line"> </div>
<div class="line">    std::string filename = getTestFilePath(<span class="stringliteral">&quot;testRegisteredTypeExample.h5&quot;</span>);</div>
<div class="line">    std::shared_ptr&lt;BaseIO&gt; io = std::make_unique&lt;IO::HDF5::HDF5IO&gt;(filename);</div>
<div class="line">    io-&gt;open();</div>
<div class="line">    <span class="keyword">auto</span> ts = <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_time_series.html#aa6524a59a8162352e8117f5382186ce4">NWB::TimeSeries::create</a>(dataPath, io);</div>
<div class="line">    <a class="code hl_class" href="class_a_q_n_w_b_1_1_i_o_1_1_array_data_set_config.html">IO::ArrayDataSetConfig</a> config(</div>
<div class="line">        dataType, <a class="code hl_typedef" href="_base_i_o_8hpp.html#ae7b9f006e82f06f4fc09caf38bd47460">SizeArray</a> {numSamples}, <a class="code hl_typedef" href="_base_i_o_8hpp.html#ae7b9f006e82f06f4fc09caf38bd47460">SizeArray</a> {numSamples});</div>
<div class="line">    ts-&gt;initialize(config, <span class="stringliteral">&quot;unit&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Write data to file</span></div>
<div class="line">    <a class="code hl_typedef" href="_base_i_o_8hpp.html#a38fce1d86c801b13b6860d3346276776">Status</a> writeStatus = ts-&gt;writeData(</div>
<div class="line">        dataShape, positionOffset, data.data(), timestamps.data());</div>
<div class="line">    REQUIRE(writeStatus == Status::Success);</div>
<div class="line">    io-&gt;flush();</div>
<div class="line">    <span class="comment">// [example_RegisterType_setup_file]</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// [example_RegisterType_get_type_instance]</span></div>
<div class="line">    <span class="comment">// Create an instance of an TimeSeries in a file.</span></div>
<div class="line">    <span class="keyword">auto</span> instance =</div>
<div class="line">        <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">AQNWB::NWB::RegisteredType::create</a>(<span class="stringliteral">&quot;core::TimeSeries&quot;</span>, dataPath, io);</div>
<div class="line">    REQUIRE(instance != <span class="keyword">nullptr</span>);</div>
<div class="line">    <span class="comment">// [example_RegisterType_get_type_instance]</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// [example_RegisterType_get_registered_names]</span></div>
<div class="line">    <span class="comment">// Retrieve and print registered subclass names</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; registry = <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#ab7e3361637885fe601cc20cb342bf01c">AQNWB::NWB::RegisteredType::getRegistry</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Registered subclasses:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; subclassName : registry) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; subclassName &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// [example_RegisterType_get_registered_names]</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// [example_RegisterType_get_registered_factories]</span></div>
<div class="line">    <span class="comment">// Retrieve and print factory map</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; factoryMap = <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#ac83aa589b9c3ab5a00bab462e58fdbd5">AQNWB::NWB::RegisteredType::getFactoryMap</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Factory functions for registered subclasses:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pair : factoryMap) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; pair.first &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// [example_RegisterType_get_registered_factories]</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="read_design_example"></a>
Example Implementation Details</h1>
<p>For implementation examples and detailed code snippets, see the following sections:</p>
<h2 class="doxsection"><a class="anchor" id="read_design_example_create"></a>
Creating and Writing Data</h2>
<div class="fragment"><div class="line">    <span class="comment">// setup mock data for writing</span></div>
<div class="line">    <a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> numSamples = 100;</div>
<div class="line">    <a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> numChannels = 2;</div>
<div class="line">    std::vector&lt;Types::ChannelVector&gt; mockArrays = getMockChannelArrays();</div>
<div class="line">    BaseDataType dataType = BaseDataType::F32;</div>
<div class="line">    std::vector&lt;std::string&gt; mockChannelNames =</div>
<div class="line">        getMockChannelArrayNames(<span class="stringliteral">&quot;esdata&quot;</span>);</div>
<div class="line">    std::vector&lt;std::vector&lt;float&gt;&gt; mockData =</div>
<div class="line">        getMockData2D(numSamples, numChannels);</div>
<div class="line">    std::vector&lt;double&gt; mockTimestamps = getMockTimestamps(numSamples, 1);</div>
<div class="line">    <span class="comment">// To verify that the data was written correctly, we here transpose the</span></div>
<div class="line">    <span class="comment">// mockData (which is per channel) to the (time x channel) layout used</span></div>
<div class="line">    <span class="comment">// in the ElectricalSeries in the NWB file so we can compare</span></div>
<div class="line">    std::vector&lt;std::vector&lt;float&gt;&gt; mockDataTransposed;</div>
<div class="line">    mockDataTransposed.resize(numSamples);</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> s = 0; s &lt; numSamples; s++) {</div>
<div class="line">      mockDataTransposed[s].resize(numChannels);</div>
<div class="line">      <span class="keywordflow">for</span> (<a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> c = 0; c &lt; numChannels; c++) {</div>
<div class="line">        mockDataTransposed[s][c] = mockData[c][s];</div>
<div class="line">      }</div>
<div class="line">    }</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">// setup io object</span></div>
<div class="line">    std::string path = getTestFilePath(<span class="stringliteral">&quot;ElectricalSeriesReadExample.h5&quot;</span>);</div>
<div class="line">    std::shared_ptr&lt;BaseIO&gt; io = <a class="code hl_function" href="namespace_a_q_n_w_b.html#aae4545d930db6f70b4438e0167c500d0">createIO</a>(<span class="stringliteral">&quot;HDF5&quot;</span>, path);</div>
<div class="line">    io-&gt;open();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// setup the NWBFile</span></div>
<div class="line">    <span class="keyword">auto</span> nwbfile = <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html#a84f0f21cd7bd9745b1eeb508b747fb4b">NWB::NWBFile::create</a>(io);</div>
<div class="line">    <a class="code hl_typedef" href="_base_i_o_8hpp.html#a38fce1d86c801b13b6860d3346276776">Status</a> initStatus = nwbfile-&gt;initialize(<a class="code hl_function" href="namespace_a_q_n_w_b.html#a7a202ee50288eeca65b9b98370226a82">generateUuid</a>());</div>
<div class="line">    REQUIRE(initStatus == Status::Success);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// RecordingObjects are now automatically managed by the IO object</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// create a new ElectricalSeries</span></div>
<div class="line">    <span class="keyword">auto</span> electrodesTable = nwbfile-&gt;createElectrodesTable(mockArrays);</div>
<div class="line">    std::vector&lt;SizeType&gt; containerIndexes = {};</div>
<div class="line">    <a class="code hl_typedef" href="_base_i_o_8hpp.html#a38fce1d86c801b13b6860d3346276776">Status</a> resultCreate = nwbfile-&gt;createElectricalSeries(</div>
<div class="line">        mockArrays, mockChannelNames, dataType, containerIndexes);</div>
<div class="line">    REQUIRE(resultCreate == Status::Success);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// get the new ElectricalSeries</span></div>
<div class="line">    <span class="keyword">auto</span> recordingObjects = io-&gt;getRecordingObjects();</div>
<div class="line">    <span class="keyword">auto</span> registeredTypePtr =</div>
<div class="line">        recordingObjects-&gt;getRecordingObject(containerIndexes[0]);</div>
<div class="line">    REQUIRE(registeredTypePtr != <span class="keyword">nullptr</span>);</div>
<div class="line">    REQUIRE(registeredTypePtr-&gt;getFullTypeName() == <span class="stringliteral">&quot;core::ElectricalSeries&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> electricalSeries =</div>
<div class="line">        std::dynamic_pointer_cast&lt;NWB::ElectricalSeries&gt;(registeredTypePtr);</div>
<div class="line">    REQUIRE(electricalSeries != <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// start recording</span></div>
<div class="line">    <a class="code hl_typedef" href="_base_i_o_8hpp.html#a38fce1d86c801b13b6860d3346276776">Status</a> resultStart = io-&gt;startRecording();</div>
<div class="line">    REQUIRE(resultStart == Status::Success);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// write channel data</span></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> ch = 0; ch &lt; numChannels; ++ch) {</div>
<div class="line">      electricalSeries-&gt;writeChannel(</div>
<div class="line">          ch, numSamples, mockData[ch].data(), mockTimestamps.data());</div>
<div class="line">    }</div>
<div class="line">    io-&gt;flush();</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="read_design_example_read"></a>
Reading and Processing Data</h2>
<div class="fragment"><div class="line">    <span class="comment">// Get a ReadDatasetWrapper&lt;float&gt; for lazy reading of ElectricalSeries.data</span></div>
<div class="line">    <span class="comment">// By specifying the value type as a template parameter allows us to read</span></div>
<div class="line">    <span class="comment">// typed data. However, in the particular case of ElectricalSeries.data, we</span></div>
<div class="line">    <span class="comment">// could also have used readData() with &lt;float&gt; as the template parameter</span></div>
<div class="line">    <span class="comment">// is already set to float by default for ElectricalSeries.readData()</span></div>
<div class="line">    <span class="keyword">auto</span> readDataWrapper = electricalSeries-&gt;readData&lt;<span class="keywordtype">float</span>&gt;();</div>
</div><!-- fragment --><div class="fragment"><div class="line">    REQUIRE(readDataWrapper-&gt;exists());</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">// Read the full  ElectricalSeries.data back</span></div>
<div class="line">    DataBlock&lt;float&gt; dataValues = readDataWrapper-&gt;values();</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">// Check that the data we read has the expected size and shape</span></div>
<div class="line">    REQUIRE(dataValues.data.size() == (numSamples * numChannels));</div>
<div class="line">    REQUIRE(dataValues.shape[0] == numSamples);</div>
<div class="line">    REQUIRE(dataValues.shape[1] == numChannels);</div>
<div class="line">    REQUIRE(dataValues.typeIndex == <span class="keyword">typeid</span>(<span class="keywordtype">float</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Iterate through all the time steps</span></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> t = 0; t &lt; numSamples; t++) {</div>
<div class="line">      <span class="comment">// Get the data for the single time step t from the DataBlock</span></div>
<div class="line">      std::vector&lt;float&gt; selectedRange(</div>
<div class="line">          dataValues.data.begin()</div>
<div class="line">              + <span class="keyword">static_cast&lt;</span>std::vector&lt;float&gt;::difference_type<span class="keyword">&gt;</span>(t</div>
<div class="line">                                                                 * numChannels),</div>
<div class="line">          dataValues.data.begin()</div>
<div class="line">              + <span class="keyword">static_cast&lt;</span>std::vector&lt;float&gt;::difference_type<span class="keyword">&gt;</span>(</div>
<div class="line">                  (t + 1) * numChannels));</div>
<div class="line">      <span class="comment">// Check that the values are correct</span></div>
<div class="line">      REQUIRE_THAT(selectedRange,</div>
<div class="line">                   Catch::Matchers::Approx(mockDataTransposed[t]).margin(1));</div>
<div class="line">    }</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">// Use the boost multi-array feature to simply interaction with data</span></div>
<div class="line">    <span class="keyword">auto</span> boostMultiArray = dataValues.as_multi_array&lt;2&gt;();</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">// Iterate through all the time steps again, but now using the boost array</span></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> t = 0; t &lt; numSamples; t++) {</div>
<div class="line">      <span class="comment">// Access [t, :], i.e., get a 1D array with the data</span></div>
<div class="line">      <span class="comment">// from all channels for time step t.</span></div>
<div class="line">      <span class="keyword">auto</span> row_t = boostMultiArray[<span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>(t)];</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Compare to check that the data is correct.</span></div>
<div class="line">      std::vector&lt;float&gt; row_t_vector(</div>
<div class="line">          row_t.begin(), row_t.end());  <span class="comment">// convert to std::vector for comparison</span></div>
<div class="line">      REQUIRE_THAT(row_t_vector,</div>
<div class="line">                   Catch::Matchers::Approx(mockDataTransposed[t]).margin(1));</div>
<div class="line">    }</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">// Get a ReadDataWrapper&lt;ReadObjectType::Attribute, float&gt; to read data</span></div>
<div class="line">    <span class="comment">// lazily</span></div>
<div class="line">    <span class="keyword">auto</span> readDataResolutionWrapper = electricalSeries-&gt;readDataResolution();</div>
<div class="line">    <span class="comment">// Read the data values as a DataBlock&lt;float&gt;</span></div>
<div class="line">    <span class="keyword">auto</span> resolutionValueFloat = readDataResolutionWrapper-&gt;values();</div>
<div class="line">    REQUIRE(resolutionValueFloat.shape.empty());  <span class="comment">// Scalar</span></div>
<div class="line">    REQUIRE(resolutionValueFloat.data.size() == 1);</div>
<div class="line">    REQUIRE(<span class="keywordtype">int</span>(resolutionValueFloat.data[0]) == -1);</div>
<div class="line">    REQUIRE(resolutionValueFloat.typeIndex == <span class="keyword">typeid</span>(<span class="keywordtype">float</span>));</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">// Get a generic ReadDatasetWrapper&lt;std::any&gt; for lazy reading of</span></div>
<div class="line">    <span class="comment">// ElectricalSeries.data</span></div>
<div class="line">    <span class="keyword">auto</span> readDataWrapperGeneric = electricalSeries-&gt;readData();</div>
<div class="line">    <span class="comment">// Instead of using values() to read typed data, we can read data as generic</span></div>
<div class="line">    <span class="comment">// data first via valuesGeneric</span></div>
<div class="line">    DataBlockGeneric dataValuesGeneric =</div>
<div class="line">        readDataWrapperGeneric-&gt;valuesGeneric();</div>
<div class="line">    <span class="comment">// Note that the I/O backend determines the data type and allocates</span></div>
<div class="line">    <span class="comment">// the memory for us. The std::type_index is stored in our data block as</span></div>
<div class="line">    <span class="comment">// well</span></div>
<div class="line">    REQUIRE(dataValuesGeneric.typeIndex == <span class="keyword">typeid</span>(<span class="keywordtype">float</span>));</div>
<div class="line">    <span class="comment">// We can then later convert the data block to a typed data block</span></div>
<div class="line">    DataBlock&lt;float&gt; dataValueFloat =</div>
<div class="line">        DataBlock&lt;float&gt;::fromGeneric(dataValuesGeneric);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>In most cases, we should not need runtime checking of types in the context of specific data acquisition systems. This is mostly likely relevant if one wants to consume arbitrary NWB files that may use different data types. One approach is to use <span class="tt">std::variant</span> as described in <a class="el" href="read_page.html#read_example_variant_data">Working with fields with unknown data type</a>. Using <span class="tt">std::variant</span> helps avoid complex code for checking data types at runtime. <br  />
 If for some reason we cannot easily use the <span class="tt">std:variant</span> approach (e.g., in case we need to use data types not natively supported by AqNWB), an alternative approach would be to define a mapping of the type information to the corresponding statically typedVector functionality, e.g., via `switch/case`` logic or by using a map for lookup, such as: <div class="fragment"><div class="line">DataBlockGeneric dataValuesGeneric = readDataWrapperGeneric-&gt;valuesGeneric();</div>
<div class="line"><span class="comment">// Map to associate std::type_index with corresponding type-specific functions</span></div>
<div class="line">std::unordered_map&lt;std::type_index, std::function&lt;void(<span class="keyword">const</span> DataBlockGeneric&amp;)&gt;&gt; typeMap = {</div>
<div class="line">      {<span class="keyword">typeid</span>(float), processData&lt;float&gt;},</div>
<div class="line">      {<span class="keyword">typeid</span>(int), processData&lt;&lt;<span class="keywordtype">int</span>&gt;},</div>
<div class="line">      <span class="comment">// Add more types as needed</span></div>
<div class="line">};</div>
<div class="line"><span class="comment">// Use the map to process the data with the approbriate type</span></div>
<div class="line"><span class="keyword">auto</span> it = typeMap.find(dataValuesGeneric.typeIndex);</div>
<div class="line"><span class="keywordflow">if</span> (it != typeMap.end()) {</div>
<div class="line">      it-&gt;second(dataValuesGeneric); <span class="comment">// call the correct processData function</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Unsupported type&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="devdocs.html">For Developers</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
