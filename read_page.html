<!-- HTML header for doxygen 1.11.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>aqnwb: Reading data</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow" >
  <td id="projectlogo"><img alt="Logo" src="aqnwb-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">aqnwb<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('read_page.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Reading data</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1">
    <a href="#read_design_intro">Introduction</a>
  </li>
  <li class="level1">
    <a href="#read_design_sec">Software Design</a>
    <ul>
      <li class="level2">
        <a href="#read_design_sec_read_date">Reading datasets and attributes</a>
        <ul>
          <li class="level3">
            <a href="#read_design_wrapper_container">Container</a>
          </li>
          <li class="level3">
            <a href="#read_design_wrapper_propos">ReadDataWrapper</a>
          </li>
          <li class="level3">
            <a href="#read_design_data_block">DataBlockGeneric and DataBlock</a>
            <ul>
              <li class="level4">
                <a href="#read_design_data_block_typed">DataBlock with typed data</a>
              </li>
              <li class="level4">
                <a href="#read_design_data_block_multiarray">Using Boost Multi Array for N-Dimensional Data</a>
              </li>
            </ul>
          </li>
          <li class="level3">
            <a href="#read_design_wrapper_io">I/O</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#read_design_sec_read_types">Reading typed objects</a>
        <ul>
          <li class="level3">
            <a href="#read_design_wrapper_registeredType">RegisteredType</a>
          </li>
          <li class="level3">
            <a href="#read_design_wrapper_subtypes">Child classes of RegisteredType (e.g., Container)</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#read_design_example">Example</a>
    <ul>
      <li class="level2">
        <a href="#read_design_example_create">Create a NWB file as usual</a>
        <ul>
          <li class="level3">
            <a href="#read_design_example_step_1">Setup mock data for write</a>
          </li>
          <li class="level3">
            <a href="#read_design_example_step_1_2">Create the NWBFile and record data</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#read_design_example_read_during">Reading Datasets and Attributes</a>
        <ul>
          <li class="level3">
            <a href="#read_design_example_lazy_read">Lazy data access</a>
          </li>
          <li class="level3">
            <a href="#read_design_example_check_exists">Check that the object exists</a>
          </li>
          <li class="level3">
            <a href="#read_design_example_load_data">Read data into memory</a>
          </li>
          <li class="level3">
            <a href="#read_design_example_boostarray">Accessing multi-dimensional data as Boost multi-array</a>
          </li>
          <li class="level3">
            <a href="#read_design_example_attribute">Reading an attribute</a>
          </li>
          <li class="level3">
            <a href="#read_design_example_readgeneric">Reading data with unknown type</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#read_design_example_stop_recording">Finalize the recording</a>
      </li>
      <li class="level2">
        <a href="#read_design_example_read_from_existing_file">Reading from an existing file</a>
        <ul>
          <li class="level3">
            <a href="#read_design_example_read_create_io">Opening an existing file for reading</a>
          </li>
          <li class="level3">
            <a href="#read_predefined_registered_field">Reading known RegisteredType object</a>
          </li>
          <li class="level3">
            <a href="#read_design_example_read_posthoc_search">Searching for Registered Type objects (e.g.,ElectricalSeries)</a>
          </li>
          <li class="level3">
            <a href="#read_design_example_read_posthoc_read">Reading the Registered Type Objects</a>
          </li>
          <li class="level3">
            <a href="#read_design_example_read_posthoc_read_field">Reading data fields</a>
          </li>
          <li class="level3">
            <a href="#read_design_example_read_arbitrary_field">Reading arbitrary fields</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="read_design_intro"></a>
Introduction</h1>
<p>Reading data from an open NWB file via AqNWB consists of the following main steps.</p>
<ol type="1">
<li>Create the I/O object to read the file</li>
<li>Construct the container object for the <code>neurodata_type</code> (e.g., a <code>TimeSeries</code>) for read via the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a01354d1b4230f7495203cc526eae418f">RegisteredType::create</a> factory method, e.g., <code>auto electricalSeries = RegisteredType::create&lt;ElectricalSeries&gt;(electricalSeriesPath, io);</code></li>
<li>Access a dataset or attribute for read by retrieving a wrapper object that provides lazy read access to the particular dataset or attribute: <div class="fragment"><div class="line">    <span class="comment">// Get a ReadDatasetWrapper&lt;float&gt; for lazy reading of ElectricalSeries.data</span></div>
<div class="line">    <span class="comment">// By specifying the value type as a template parameter allows us to read</span></div>
<div class="line">    <span class="comment">// typed data</span></div>
<div class="line">    <span class="keyword">auto</span> readDataWrapper = electricalSeries-&gt;<a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html#a0e3139dbc00e4b143e1695e870532c15">readData</a>&lt;<span class="keywordtype">float</span>&gt;();</div>
</div><!-- fragment --></li>
<li>Request the parts of the data of interest,at which point the data is being loaded from disk. <div class="fragment"><div class="line">    <span class="comment">// Read the full  ElectricalSeries.data back</span></div>
<div class="line">    DataBlock&lt;float&gt; dataValues = readDataWrapper-&gt;values();</div>
</div><!-- fragment --></li>
</ol>
<p>In the following sections we dive deeper into the <a class="el" href="#read_design_sec">Software Design</a>, describing the different classes involved in reading data and their responsibilities. We then show a more detailed <a class="el" href="#read_design_example">Example</a> to illustrate how read works in the overall context of data acquisition.</p>
<h1><a class="anchor" id="read_design_sec"></a>
Software Design</h1>
<h2><a class="anchor" id="read_design_sec_read_date"></a>
Reading datasets and attributes</h2>
<p>The following figure shows the main classes involved with reading data from a dataset or attribute.</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_4.svg" width="982" height="826"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p>The main components involved in reading data from an NWB file via AqNWB are:</p>
<ul>
<li><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">BaseIO</a>, <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_i_o.html">HDF5IO</a> responsible for reading data from disk and allocating memory for data on read</li>
<li><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block_generic.html">DataBlockGeneric</a> represents a generic, n-dimensional block of data loaded from a file, storing the data as a generic <code>std::any</code> along with the <code>shape</code> of the data.<ul>
<li><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html">DataBlock</a> represents a typed, n-dimensional block of data, derived from a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block_generic.html">DataBlockGeneric</a></li>
</ul>
</li>
<li><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a>, is a simple wrapper class that represents a dataset/attribute for read, enabling lazy data read and allowing for transparent use of different I/O backends.</li>
<li><a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html">Container</a> type classes represent Groups with an assigned <code>neurodata_type</code> in the NWB format, and are responsible for providing access to the datasets/attributes that they own. To provide access, these classes create <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a> objects for the user for lazy read access to the data.</li>
</ul>
<p>We will discuss these different components in a bit more detail next.</p>
<h3><a class="anchor" id="read_design_wrapper_container"></a>
Container</h3>
<p>The <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html">Container</a> class (e.g., <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html">ElectricalSeries</a> or <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html">NWBFile</a>) is responsible for exposing read access to its specific datasets and attributes by providing appropriate access functions, which return <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper&lt;AQNWB::Types::StorageObjectType::Dataset&gt;</a> or <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper&lt;AQNWB::Types::StorageObjectType::Attribute&gt;</a> objects for lazily reading from the dataset/attribute.</p>
<h3><a class="anchor" id="read_design_wrapper_propos"></a>
ReadDataWrapper</h3>
<p>The <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a> stores a shared pointer <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html#a5bfc01eda06786d2a1d986bb56a7f530">m_io</a> to the I/O object and the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html#a5293c9c5c438c43d9f31ac91f206dad8">path</a> to the dataset.</p>
<p>The <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html#a87906c320c5ca820768eacc98e8b09ca">valuesGeneric</a> method then allows us to read all or parts of the dataset into memory as <code>std::any</code>. This function uses the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a59ab1d7c744d05623aa8626643e37a74">readDataset</a> method of the I/O backend (e.g., <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_i_o.html#a805558f3372cd322dd8bb109151670d8">HDF5IO.readDataset</a>) to load the data. The I/O backend in turn takes care of allocating the memory for the appropriate data type and loading the data from disk.</p>
<p>We can retrieve data directly with the appropriate type by using the templated <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html#a6f847556dc94dc001eb66dda402f72c0">values</a> function instead, which uses <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html#a87906c320c5ca820768eacc98e8b09ca">valuesGeneric</a> and then automatically casts the data to a typed <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html">DataBlock&lt;DTYPE&gt;</a> instead of returning an untyped <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html">DataBlockGeneric</a>.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a> takes two template parameters: 1) the <code>OTYPE</code> specifying the type of object being wrapped <a class="el" href="class_a_q_n_w_b_1_1_types.html#a778ba605df5dabb117ede12e41111915">AQNWB::Types::StorageObjectType</a> and 2) the <code>VTYPE</code> defining the value type of the data. For attributes, slicing is disabled at compile time, i.e., attributes are always loaded fully into memory since attributes are intended for small data only.</dd></dl>
<h3><a class="anchor" id="read_design_data_block"></a>
DataBlockGeneric and DataBlock</h3>
<p>At first, data values are always represented as a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block_generic.html">DataBlockGeneric</a> object, which stores the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block_generic.html#a7c75a76906f183f7cc79be020823722e">data</a> as <code>std::any</code> along with the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block_generic.html#a1f6ba182a7b2987f7e27dd3cedb652b6">shape</a> of the data. For example, <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html#a87906c320c5ca820768eacc98e8b09ca">ReadDatasetWrapper.valuesGeneric</a> and <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_i_o.html#a805558f3372cd322dd8bb109151670d8">HDF5IO.readDataset</a> return a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block_generic.html">DataBlockGeneric</a>. This has the advantage that we can let the backend handle memory allocation and typing for us and load data even if we don't know the type yet.</p>
<h4><a class="anchor" id="read_design_data_block_typed"></a>
DataBlock with typed data</h4>
<p>To cast the data to the appropriate specific type (e.g., <code>float</code>) we can then create a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html">DataBlock</a> with the appropriate data type via the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#a20df6af7d661de38f4b8cb3baba48339">DataBlock.fromGeneric</a> factory method. <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html">DataBlock</a> is templated on the specific data type, i.e., we call <code>DataBlock&lt;float&gt;.fromGeneric(myGenericDataBlock)</code>. <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html">DataBlock</a> then stores the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#a7e084bd163c177f45c41cdf93b61f2b6">data</a> as an appropriately typed 1-dimensional <code>std::vector</code> along with the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#adcd06e1ef4d9ab65081f8e5ab49eec36">shape</a> of the data.</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#a20df6af7d661de38f4b8cb3baba48339">DataBlock.fromGeneric</a> (and <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#a39c4d437721b818aac335f3c9a57dc97">DataBlock.as_multi_array</a>) use casting and referencing to transform the data without making additional copies of the data.</dd></dl>
<h4><a class="anchor" id="read_design_data_block_multiarray"></a>
Using Boost Multi Array for N-Dimensional Data</h4>
<p>To simplify access to multi-dimensional data, we can then represent the data as a <code>BOOST::multi_array</code>. The <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#a39c4d437721b818aac335f3c9a57dc97">DataBlock.as_multi_array</a> convenience method generates a <code>boost::const_multi_array_ref&lt;DTYPE, NDIMS&gt;</code> for us. Here the <code>DTYPE</code> template parameter is the same as for the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html">DataBlock</a> (so that we don't have to specify it again), and the <code>NDIMS</code> template parameter is the number of dimensions (which is the same as <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#adcd06e1ef4d9ab65081f8e5ab49eec36">shape.size()</a>).</p>
<dl class="section note"><dt>Note</dt><dd>Since we are in a strongly typed language, we here need to know the <code>DTYPE</code> at compile time when using <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html">DataBlock</a>. And if we want to use the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#a39c4d437721b818aac335f3c9a57dc97">DataBlock.as_multi_array</a>, then we also need to know the number of dimensions <code>NDIMS</code> at compile time.</dd></dl>
<h3><a class="anchor" id="read_design_wrapper_io"></a>
I/O</h3>
<p>The I/O backend is responsible for implementing the actual <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a59ab1d7c744d05623aa8626643e37a74">readDataset</a> and <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#aa9b3fc349e4149f6b1c75bb854deae07">readAttribute</a> methods used for reading data from disk. The methods are also responsible for allocating appropriate memory with the respective data type. The functions return the data as <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block_generic.html">DataBlockGeneric</a>, which stores the data as untyped <code>std::any</code>. The user can then cast the data to the appropriate type as discussed in <a class="el" href="#read_design_data_block_typed">DataBlock with typed data</a>.</p>
<h2><a class="anchor" id="read_design_sec_read_types"></a>
Reading typed objects</h2>
<p>Objects with an assigned <code>neurodata_type</code> are represented by corresponding classes in AqNWB. To read objects with an assigned type, we therefore need to be able to instantiate the corresponding classes in AqNWB based on the data from a file. The following figure illustrates the main components of this process.</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_5.svg" width="772" height="515"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p>The main components involved in reading typed objects from an NWB file via AqNWB are:</p>
<ul>
<li><a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> as the main base class for all classes implementing a type, e.g., <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html">Container</a>, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data.html">Data</a> and all their subtypes. <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> is responsible for managing all type classes and provides the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a01354d1b4230f7495203cc526eae418f">create</a> factory methods for creating instances of subclasses from a file.</li>
<li><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html">BaseIO</a>, <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_i_o.html">HDF5IO</a> are responsible for i) reading type attribute and group information, ii) searching the file for typed objects via <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a985277d47989d7cba0f1020a3166da2b">findTypes()</a> methods, and iii) retrieving the paths of all object associated with a storage object (e.g., a Group) via <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a981d7a455b4c057f8ade5c511afbb2ba">getStorageObjects()</a></li>
</ul>
<h3><a class="anchor" id="read_design_wrapper_registeredType"></a>
RegisteredType</h3>
<p><a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> maintains a registry of all classes that inherit from it and the types they represent. We can retrieve the full registry via the static method <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a8792fccbd49f9d441b1f6d5a1b06b4cf">getFactoryMap</a> and a list of just the full type names that are in the registry via <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#ab7e3361637885fe601cc20cb342bf01c">getRegistry</a>. Importantly, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> provides static <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a01354d1b4230f7495203cc526eae418f">create</a> methods that we can use to instantiate any registered subclass just using the <code>io</code> object and <code>path</code> for the object in the file. <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> can read the type information from the corresponding <code>namespace</code> and <code>neurodata_type</code> attributes to determine the full type, then look up the corresponding class in its registry, and then create the type. Using <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#ae0fb6e951eb0000e4a4fba81db8d466f">RegisteredType::readField</a> also provides a general mechanism for reading arbitrary fields.</p>
<h3><a class="anchor" id="read_design_wrapper_subtypes"></a>
Child classes of RegisteredType (e.g., Container)</h3>
<p>Child classes of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> (e.g., <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html">Container</a> or <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data.html">Data</a>), then implement specific <code>neurodata_types</code> defined in the NWB schema. The subclasses register with <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a>, such that we can look them up and determine which class represents which <code>neurodata_type</code>.</p>
<dl class="section note"><dt>Note</dt><dd>For more details about the design of the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> class and the various components involved with creating and managing the type registry, please see developer docs on <a class="el" href="registered_type_page.html">Implementing a new Neurodata Type</a> .</dd></dl>
<h1><a class="anchor" id="read_design_example"></a>
Example</h1>
<h2><a class="anchor" id="read_design_example_create"></a>
Create a NWB file as usual</h2>
<h3><a class="anchor" id="read_design_example_step_1"></a>
Setup mock data for write</h3>
<div class="fragment"><div class="line">    <span class="comment">// setup mock data for writing</span></div>
<div class="line">    <a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> numSamples = 100;</div>
<div class="line">    <a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> numChannels = 2;</div>
<div class="line">    std::vector&lt;Types::ChannelVector&gt; mockArrays = getMockChannelArrays();</div>
<div class="line">    BaseDataType dataType = BaseDataType::F32;</div>
<div class="line">    std::vector&lt;std::string&gt; mockChannelNames =</div>
<div class="line">        getMockChannelArrayNames(<span class="stringliteral">&quot;esdata&quot;</span>);</div>
<div class="line">    std::vector&lt;std::vector&lt;float&gt;&gt; mockData =</div>
<div class="line">        getMockData2D(numSamples, numChannels);</div>
<div class="line">    std::vector&lt;double&gt; mockTimestamps = getMockTimestamps(numSamples, 1);</div>
<div class="line">    <span class="comment">// To verify that the data was written correctly, we here transpose the</span></div>
<div class="line">    <span class="comment">// mockData (which is per channel) to the (time x channel) layout used</span></div>
<div class="line">    <span class="comment">// in the ElectricalSeries in the NWB file so we can compare</span></div>
<div class="line">    std::vector&lt;std::vector&lt;float&gt;&gt; mockDataTransposed;</div>
<div class="line">    mockDataTransposed.resize(numSamples);</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> s = 0; s &lt; numSamples; s++) {</div>
<div class="line">      mockDataTransposed[s].resize(numChannels);</div>
<div class="line">      <span class="keywordflow">for</span> (<a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> c = 0; c &lt; numChannels; c++) {</div>
<div class="line">        mockDataTransposed[s][c] = mockData[c][s];</div>
<div class="line">      }</div>
<div class="line">    }</div>
</div><!-- fragment --><h3><a class="anchor" id="read_design_example_step_1_2"></a>
Create the NWBFile and record data</h3>
<div class="fragment"><div class="line">    <span class="comment">// setup io object</span></div>
<div class="line">    std::string path = getTestFilePath(<span class="stringliteral">&quot;ElectricalSeriesReadExample.h5&quot;</span>);</div>
<div class="line">    std::shared_ptr&lt;BaseIO&gt; io = <a class="code hl_function" href="namespace_a_q_n_w_b.html#aae4545d930db6f70b4438e0167c500d0">createIO</a>(<span class="stringliteral">&quot;HDF5&quot;</span>, path);</div>
<div class="line">    io-&gt;open();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// setup the NWBFile</span></div>
<div class="line">    <a class="code hl_class" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html">NWB::NWBFile</a> nwbfile(io);</div>
<div class="line">    <a class="code hl_typedef" href="_base_i_o_8hpp.html#a38fce1d86c801b13b6860d3346276776">Status</a> initStatus = nwbfile.initialize(<a class="code hl_function" href="namespace_a_q_n_w_b.html#a7a202ee50288eeca65b9b98370226a82">generateUuid</a>());</div>
<div class="line">    REQUIRE(initStatus == Status::Success);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// create the RecordingContainer for managing recordings</span></div>
<div class="line">    std::unique_ptr&lt;NWB::RecordingContainers&gt; recordingContainers =</div>
<div class="line">        std::make_unique&lt;NWB::RecordingContainers&gt;();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// create a new ElectricalSeries</span></div>
<div class="line">    <a class="code hl_typedef" href="_base_i_o_8hpp.html#a38fce1d86c801b13b6860d3346276776">Status</a> resultCreate = nwbfile.createElectricalSeries(</div>
<div class="line">        mockArrays, mockChannelNames, dataType, recordingContainers.get());</div>
<div class="line">    REQUIRE(resultCreate == Status::Success);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// get the new ElectricalSeries</span></div>
<div class="line">    <a class="code hl_class" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html">NWB::ElectricalSeries</a>* electricalSeries =</div>
<div class="line">        <span class="keyword">static_cast&lt;</span><a class="code hl_class" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html">NWB::ElectricalSeries</a>*<span class="keyword">&gt;</span>(</div>
<div class="line">            recordingContainers-&gt;getContainer(0));</div>
<div class="line">    REQUIRE(electricalSeries != <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// start recording</span></div>
<div class="line">    <a class="code hl_typedef" href="_base_i_o_8hpp.html#a38fce1d86c801b13b6860d3346276776">Status</a> resultStart = io-&gt;startRecording();</div>
<div class="line">    REQUIRE(resultStart == Status::Success);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// write channel data</span></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> ch = 0; ch &lt; numChannels; ++ch) {</div>
<div class="line">      electricalSeries-&gt;<a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html#abd499ff69952a61324f86034ea91111b">writeChannel</a>(</div>
<div class="line">          ch, numSamples, mockData[ch].data(), mockTimestamps.data());</div>
<div class="line">    }</div>
<div class="line">    io-&gt;flush();</div>
</div><!-- fragment --><h2><a class="anchor" id="read_design_example_read_during"></a>
Reading Datasets and Attributes</h2>
<h3><a class="anchor" id="read_design_example_lazy_read"></a>
Lazy data access</h3>
<p>All data read is implemented lazily, i.e., AqNWB does not load data into memory until we make a request to do so. To access data lazily, datasets and attributes are wrapped via <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a> with appropriate <code>OTYPE</code> object type template parameter set. The <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html">Container</a> object that owns the dataset/attribute then provides accessor methods to get access to the dataset/attribute. Here, we access the <code>data</code> dataset of the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html">ElectricalSeries</a>.</p>
<div class="fragment"><div class="line">    <span class="comment">// Get a ReadDatasetWrapper&lt;float&gt; for lazy reading of ElectricalSeries.data</span></div>
<div class="line">    <span class="comment">// By specifying the value type as a template parameter allows us to read</span></div>
<div class="line">    <span class="comment">// typed data</span></div>
<div class="line">    <span class="keyword">auto</span> readDataWrapper = electricalSeries-&gt;<a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html#a0e3139dbc00e4b143e1695e870532c15">readData</a>&lt;<span class="keywordtype">float</span>&gt;();</div>
</div><!-- fragment --><h3><a class="anchor" id="read_design_example_check_exists"></a>
Check that the object exists</h3>
<p>In particular for fields that are optional, it is useful to first check that the field actually exists using the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html#aa67d145711df12192d43d07c3a52546a">exists</a> method of our <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a>.</p>
<div class="fragment"><div class="line">    REQUIRE(readDataWrapper-&gt;exists());</div>
</div><!-- fragment --><h3><a class="anchor" id="read_design_example_load_data"></a>
Read data into memory</h3>
<p>To load the data values, we can then use the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html#a87906c320c5ca820768eacc98e8b09ca">valuesGeneric</a> and <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html#a6f847556dc94dc001eb66dda402f72c0">values</a> methods, which load the data as generic (untyped) or typed data, respectively.</p>
<div class="fragment"><div class="line">    <span class="comment">// Read the full  ElectricalSeries.data back</span></div>
<div class="line">    DataBlock&lt;float&gt; dataValues = readDataWrapper-&gt;values();</div>
</div><!-- fragment --><p>The data is here represented as a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html">DataBlock</a>, which stores the data as a 1-dimensionsal vector along with the shape of the data. E.g, here we validate the data against the original mock data:</p>
<div class="fragment"><div class="line">    <span class="comment">// Check that the data we read has the expected size and shape</span></div>
<div class="line">    REQUIRE(dataValues.data.size() == (numSamples * numChannels));</div>
<div class="line">    REQUIRE(dataValues.shape[0] == numSamples);</div>
<div class="line">    REQUIRE(dataValues.shape[1] == numChannels);</div>
<div class="line">    REQUIRE(dataValues.typeIndex == <span class="keyword">typeid</span>(<span class="keywordtype">float</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Iterate through all the time steps</span></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> t = 0; t &lt; numSamples; t++) {</div>
<div class="line">      <span class="comment">// Get the data for the single time step t from the DataBlock</span></div>
<div class="line">      std::vector&lt;float&gt; selectedRange(</div>
<div class="line">          dataValues.data.begin()</div>
<div class="line">              + <span class="keyword">static_cast&lt;</span>std::vector&lt;float&gt;::difference_type<span class="keyword">&gt;</span>(t</div>
<div class="line">                                                                 * numChannels),</div>
<div class="line">          dataValues.data.begin()</div>
<div class="line">              + <span class="keyword">static_cast&lt;</span>std::vector&lt;float&gt;::difference_type<span class="keyword">&gt;</span>(</div>
<div class="line">                  (t + 1) * numChannels));</div>
<div class="line">      <span class="comment">// Check that the values are correct</span></div>
<div class="line">      REQUIRE_THAT(selectedRange,</div>
<div class="line">                   Catch::Matchers::Approx(mockDataTransposed[t]).margin(1));</div>
<div class="line">    }</div>
</div><!-- fragment --><h3><a class="anchor" id="read_design_example_boostarray"></a>
Accessing multi-dimensional data as Boost multi-array</h3>
<p>To ease interaction with mutli-dimensional data, e.g., the <code>(time x channel)</code> data of our <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html">ElectricalSeries</a>, we can use the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#a39c4d437721b818aac335f3c9a57dc97">DataBlock.as_multi_array</a> method to construct a <code>boost::const_multi_array_ref</code>.</p>
<div class="fragment"><div class="line">    <span class="comment">// Use the boost multi-array feature to simply interaction with data</span></div>
<div class="line">    <span class="keyword">auto</span> boostMultiArray = dataValues.as_multi_array&lt;2&gt;();</div>
</div><!-- fragment --><p>Using boost multi-array simplifies access and interaction with the data as a multi-dimensional array. Here we use this again to validate the data we loaded against the original mock, like we did above.</p>
<div class="fragment"><div class="line">    <span class="comment">// Iterate through all the time steps again, but now using the boost array</span></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_typedef" href="_channel_8hpp.html#aa890fbdbba8cf62d61a471a1f84537e9">SizeType</a> t = 0; t &lt; numSamples; t++) {</div>
<div class="line">      <span class="comment">// Access [t, :], i.e., get a 1D array with the data</span></div>
<div class="line">      <span class="comment">// from all channels for time step t.</span></div>
<div class="line">      <span class="keyword">auto</span> row_t = boostMultiArray[<span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>(t)];</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Compare to check that the data is correct.</span></div>
<div class="line">      std::vector&lt;float&gt; row_t_vector(</div>
<div class="line">          row_t.begin(), row_t.end());  <span class="comment">// convert to std::vector for comparison</span></div>
<div class="line">      REQUIRE_THAT(row_t_vector,</div>
<div class="line">                   Catch::Matchers::Approx(mockDataTransposed[t]).margin(1));</div>
<div class="line">    }</div>
</div><!-- fragment --><h3><a class="anchor" id="read_design_example_attribute"></a>
Reading an attribute</h3>
<p>Reading an <code>Attribute</code> from a file works much in the same way as reading a <code>Dataset</code>. The main differences are when we read an attribute:</p><ol type="1">
<li>The <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a> is created with the <a class="el" href="class_a_q_n_w_b_1_1_types.html#a778ba605df5dabb117ede12e41111915">AQNWB::Types::StorageObjectType::Attribute</a> template type instead of <a class="el" href="class_a_q_n_w_b_1_1_types.html#a778ba605df5dabb117ede12e41111915">AQNWB::Types::StorageObjectType::Dataset</a></li>
<li>The variants of <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html#a87906c320c5ca820768eacc98e8b09ca">valuesGeneric</a> or <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html#a6f847556dc94dc001eb66dda402f72c0">values</a> that accept arguments for slicing are disabled at compile time.</li>
</ol>
<div class="fragment"><div class="line">    <span class="comment">// Get a ReadDataWrapper&lt;ReadObjectType::Attribute, float&gt; to read data</span></div>
<div class="line">    <span class="comment">// lazily</span></div>
<div class="line">    <span class="keyword">auto</span> readDataResolutionWrapper = electricalSeries-&gt;<a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_time_series.html#adf83d074710318ecd17f056deecf6f73">readDataResolution</a>();</div>
<div class="line">    <span class="comment">// Read the data values</span></div>
<div class="line">    DataBlock&lt;float&gt; resolutionValueFloat = readDataResolutionWrapper-&gt;values();</div>
<div class="line">    REQUIRE(resolutionValueFloat.shape.empty());  <span class="comment">// Scalar</span></div>
<div class="line">    REQUIRE(resolutionValueFloat.data.size() == 1);</div>
<div class="line">    REQUIRE(<span class="keywordtype">int</span>(resolutionValueFloat.data[0]) == -1);</div>
<div class="line">    REQUIRE(resolutionValueFloat.typeIndex == <span class="keyword">typeid</span>(<span class="keywordtype">float</span>));</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>In this case, the NWB specifies <code>float32</code> as the dtype for the <code>resolution</code> attribute. As such, the template parameter for the <code>VTYPE</code> (value type) template parameter for <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadAttributeWrapper&lt;OTYPE, VTYPE&gt;</a> is set to <code>float</code> by default, so we do not need to specify it. If for some reason a file should use <code>float64</code> instead, then we can still set the <code>VTYPE</code> accordingly via <code>electricalSeries-&gt;readDataResolution&lt;float64&gt;()</code>.</dd>
<dd>
If we don't want to specify the <code>DataBlock&lt;float&gt;</code>, then we can also infer the return type of the <code>values()</code> function at compile time via <code>decltype(readDataResolutionWrapper-&gt;values()) resolutionValueFloat = readDataResolutionWrapper-&gt;values();</code></dd></dl>
<h3><a class="anchor" id="read_design_example_readgeneric"></a>
Reading data with unknown type</h3>
<p>So far we read data by specifying the <code>VTYPE</code> template parameter of the read wrapper. However, if we do not know (or want to) specify the <code>VTYPE</code> then we can set it to <code>std::any</code>, which is the default for data with variable type, e.g. <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html#a0e3139dbc00e4b143e1695e870532c15">ElectricalSeries::readData</a>. In this case, we can still read the data via the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html#a87906c320c5ca820768eacc98e8b09ca">valuesGeneric</a> to load the data first in untyped form. When loading the data, the I/O backend determines the data type and allocates memory appropriately. The actual data type is then stored in the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block_generic.html#aa3c7c6515f19ee6be64b972ac54421c5">typeIndex</a> variable of our data block. We can then convert our <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block_generic.html">DataBlockGeneric</a> to a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html">DataBlock&lt;DTYPE&gt;</a> with a specific data type via <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#a20df6af7d661de38f4b8cb3baba48339">DataBlock&lt;dtype&gt;::fromGeneric()</a>.</p>
<div class="fragment"><div class="line">    <span class="comment">// Get a generic ReadDatasetWrapper&lt;std::any&gt; for lazy reading of</span></div>
<div class="line">    <span class="comment">// ElectricalSeries.data</span></div>
<div class="line">    <span class="keyword">auto</span> readDataWrapperGeneric = electricalSeries-&gt;<a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html#a0e3139dbc00e4b143e1695e870532c15">readData</a>();</div>
<div class="line">    <span class="comment">// Instead of using values() to read typed data, we can read data as generic</span></div>
<div class="line">    <span class="comment">// data first via valuesGeneric</span></div>
<div class="line">    DataBlockGeneric dataValuesGeneric =</div>
<div class="line">        readDataWrapperGeneric-&gt;valuesGeneric();</div>
<div class="line">    <span class="comment">// Note that the I/O backend determines the data type and allocates</span></div>
<div class="line">    <span class="comment">// the memory for us. The std::type_index is stored in our data block as</span></div>
<div class="line">    <span class="comment">// well</span></div>
<div class="line">    REQUIRE(dataValuesGeneric.typeIndex == <span class="keyword">typeid</span>(<span class="keywordtype">float</span>));</div>
<div class="line">    <span class="comment">// We can then later convert the data block to a typed data block</span></div>
<div class="line">    DataBlock&lt;float&gt; dataValueFloat =</div>
<div class="line">        DataBlock&lt;float&gt;::fromGeneric(dataValuesGeneric);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>In most cases, we should not need runtime checking of types in the context of specific data acquisition systems. This is mostly likely relevant if one wants to consume arbitrary NWB files that may use different data types. One approach to implement behavior for types determined at runtime is to define a mapping of the type information to the corresponding statically type functionality, e.g., via <code>switch/case</code> logic or by using a map for lookup, such as: <div class="fragment"><div class="line">DataBlockGeneric dataValuesGeneric = readDataWrapperGeneric-&gt;valuesGeneric();</div>
<div class="line"><span class="comment">// Map to associate std::type_index with corresponding type-specific functions</span></div>
<div class="line">std::unordered_map&lt;std::type_index, std::function&lt;void(<span class="keyword">const</span> DataBlockGeneric&amp;)&gt;&gt; typeMap = {</div>
<div class="line">      {<span class="keyword">typeid</span>(float), processData&lt;float&gt;},</div>
<div class="line">      {<span class="keyword">typeid</span>(int), processData&lt;&lt;<span class="keywordtype">int</span>&gt;},</div>
<div class="line">      <span class="comment">// Add more types as needed</span></div>
<div class="line">};</div>
<div class="line"><span class="comment">// Use the map to process the data with the approbriate type</span></div>
<div class="line"><span class="keyword">auto</span> it = typeMap.find(dataValuesGeneric.typeIndex);</div>
<div class="line"><span class="keywordflow">if</span> (it != typeMap.end()) {</div>
<div class="line">      it-&gt;second(dataValuesGeneric); <span class="comment">// call the correct processData function</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Unsupported type&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="read_design_example_stop_recording"></a>
Finalize the recording</h2>
<p>Next we stop the recording and close the file so we can show how we can read from the file we just created.</p>
<div class="fragment"><div class="line">    <span class="comment">// Stop the recording</span></div>
<div class="line">    io-&gt;flush();</div>
<div class="line">    io-&gt;stopRecording();</div>
<div class="line">    io-&gt;close();</div>
</div><!-- fragment --><h2><a class="anchor" id="read_design_example_read_from_existing_file"></a>
Reading from an existing file</h2>
<h3><a class="anchor" id="read_design_example_read_create_io"></a>
Opening an existing file for reading</h3>
<div class="fragment"><div class="line">    <span class="comment">// Open a new I/O for reading</span></div>
<div class="line">    std::shared_ptr&lt;BaseIO&gt; readio = <a class="code hl_function" href="namespace_a_q_n_w_b.html#aae4545d930db6f70b4438e0167c500d0">createIO</a>(<span class="stringliteral">&quot;HDF5&quot;</span>, path);</div>
<div class="line">    readio-&gt;open(FileMode::ReadOnly);</div>
</div><!-- fragment --><h3><a class="anchor" id="read_predefined_registered_field"></a>
Reading known RegisteredType object</h3>
<p>When the path and type of objects is fixed in the schema (or we know them based on other conventions), then we can read the types directly from the file. E.g., here we first read the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html">NWBFile</a> directly, which we know exists at the root "/" of the file. We then read the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrode_table.html">ElectrodeTable</a> via the predefined <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html#a9df4c1ed0ddceac775116b0377784a1b">NWBFile::readElectrodeTable</a> method. The advantage of this approach is that we do not need to manually specify paths or object types. Similarlry, when we read the <code>locations</code> columns, we do not need to specify the name or the data type to use.</p>
<div class="fragment"><div class="line">    <span class="comment">// Read the NWBFile</span></div>
<div class="line">    <span class="keyword">auto</span> readNWBFile =</div>
<div class="line">        <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a01354d1b4230f7495203cc526eae418f">NWB::RegisteredType::create&lt;AQNWB::NWB::NWBFile&gt;</a>(<span class="stringliteral">&quot;/&quot;</span>, readio);</div>
<div class="line">    <span class="comment">// Read the ElectrodesTable</span></div>
<div class="line">    <span class="keyword">auto</span> readElectrodeTable = readNWBFile-&gt;readElectrodeTable();</div>
<div class="line">    <span class="comment">// read the location data. Note that both the type of the class and</span></div>
<div class="line">    <span class="comment">// the data values is being set for us, here, VectorData&lt;std::string&gt;</span></div>
<div class="line">    <span class="keyword">auto</span> locationColumn = readElectrodeTable-&gt;readLocationColumn();</div>
<div class="line">    <span class="keyword">auto</span> locationColumnValues = locationColumn-&gt;readData()-&gt;values();</div>
<div class="line">    <span class="comment">// confirm that the values are correct</span></div>
<div class="line">    std::vector&lt;std::string&gt; expectedLocationValues = {</div>
<div class="line">        <span class="stringliteral">&quot;unknown&quot;</span>, <span class="stringliteral">&quot;unknown&quot;</span>, <span class="stringliteral">&quot;unknown&quot;</span>, <span class="stringliteral">&quot;unknown&quot;</span>};</div>
<div class="line">    REQUIRE(locationColumnValues.data == expectedLocationValues);</div>
</div><!-- fragment --><h3><a class="anchor" id="read_design_example_read_posthoc_search"></a>
Searching for Registered Type objects (e.g.,ElectricalSeries)</h3>
<p>When paths are not fixed, we can use the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a985277d47989d7cba0f1020a3166da2b">findType()</a> function of our I/O object to conveniently search for objects with a given type.</p>
<div class="fragment"><div class="line">    std::unordered_set&lt;std::string&gt; typesToSearch = {<span class="stringliteral">&quot;core::ElectricalSeries&quot;</span>};</div>
<div class="line">    std::unordered_map&lt;std::string, std::string&gt; found_electrical_series =</div>
<div class="line">        readio-&gt;findTypes(</div>
<div class="line">            <span class="stringliteral">&quot;/&quot;</span>,  <span class="comment">// start search at the root of the file</span></div>
<div class="line">            typesToSearch,  <span class="comment">// search for all ElectricalSeries</span></div>
<div class="line">            <a class="code hl_enumvalue" href="namespace_a_q_n_w_b_1_1_i_o.html#af7fd0e43e0ffc4d765046020e6929035aec2c6b5e5e8c3b3810251e9974647ef8">IO::SearchMode::CONTINUE_ON_TYPE</a>  <span class="comment">// search also within types</span></div>
<div class="line">        );</div>
<div class="line"> </div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a985277d47989d7cba0f1020a3166da2b">findType()</a> supports two main search modes. Using <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html#af7fd0e43e0ffc4d765046020e6929035aec2c6b5e5e8c3b3810251e9974647ef8">CONTINUE_ON_TYPE</a> mode we can search recursively through all types (here the whole file since we started at the root <code>"/"</code>). Using <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html#af7fd0e43e0ffc4d765046020e6929035a0bce90db02919671dbe161b9bd8cef05">STOP_ON_TYPE</a> does not recurse further into defined types, hence, this mode is useful if we only want to search for objects that the object at the starting path manages directly.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The current implementation of <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a985277d47989d7cba0f1020a3166da2b">findType()</a> is not aware of inheritance but searches for exact matches of types only. However, we can search for objects of multiple different times at the same time by specifying multiple types to search for in our <code>typesToSearch</code>.</dd></dl>
<p>The returned <code>std::unordered_map</code> uses the full to object as key and the full type (i.e., <code>namepspace::neurodata_type</code>) as value, which is all we need to read the objects.</p>
<div class="fragment"><div class="line">    <span class="comment">// We should have esdata1 and esdata2</span></div>
<div class="line">    REQUIRE(found_electrical_series.size() == 2);</div>
<div class="line">    <span class="comment">// Print the path and type of the found objects</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pair : found_electrical_series) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Path=&quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="stringliteral">&quot; Full type=&quot;</span> &lt;&lt; pair.second</div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">    }</div>
</div><!-- fragment --><h3><a class="anchor" id="read_design_example_read_posthoc_read"></a>
Reading the Registered Type Objects</h3>
<p>To read from a <code>neurodata_type</code> object from an existing file, we can use the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a01354d1b4230f7495203cc526eae418f">RegisteredType::create</a> factory methods to conveniently construct an instance of the corresponding class in AqNWB.</p>
<div class="fragment"><div class="line">    <span class="comment">// Read the ElectricalSeries from the file.</span></div>
<div class="line">    std::string esdata_path = <span class="stringliteral">&quot;/acquisition/esdata0&quot;</span>;</div>
<div class="line">    <span class="keyword">auto</span> readElectricalSeries =</div>
<div class="line">        <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a01354d1b4230f7495203cc526eae418f">NWB::RegisteredType::create&lt;AQNWB::NWB::ElectricalSeries&gt;</a>(esdata_path,</div>
<div class="line">                                                                  readio);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a01354d1b4230f7495203cc526eae418f">RegisteredType::create</a> comes in a few different flavors:<ol type="1">
<li>When passing only 1) <code>path</code> and 2) <code>io</code> (as in the example above), AqNWB reads the <code>neurodata_type</code> and <code>namespace</code> attributes from the NWB file to automatically determine the class to use to represent the type.</li>
<li>When passing the 1) <code>fullname</code> (e.g., <code>core::ElectricalSeries</code>), 2) <code>path</code> and 3) <code>io</code> AqNWB looks up the class to use in <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType's</a> type registry (see also <a class="el" href="registered_type_page.html#use_registered_type_registry">How to Use the RegisteredType Registry</a> )</li>
<li>When passing the class to use as template parameter, e.g., <code>create&lt;<a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html" title="General purpose time series.">AQNWB::NWB::ElectricalSeries</a>&gt;(path, io);</code> the instance is being constructed using the common constructor, i.e., this is equivalent to creating the object via <code>ElectricalSeries(path, io)</code> Option 1 and 2 instantiates the specific type (e.g., <code>ElectricalSeries</code>) but return a generic <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> pointer that we can cast to the specific type if necessary, e.g., via <code>auto readElectricalSeries = std::dynamic_pointer_cast&lt;<a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html" title="General purpose time series.">AQNWB::NWB::ElectricalSeries</a>&gt;(readRegisteredType);</code>. Option 3 creates and returns a pointer to the specific type directly.</li>
</ol>
</dd></dl>
<h3><a class="anchor" id="read_design_example_read_posthoc_read_field"></a>
Reading data fields</h3>
<p>Now we can read fields and subsets of data from the fields as before.</p>
<div class="fragment"><div class="line">    <span class="comment">// Now we can read the data in the same way we did during write</span></div>
<div class="line">    <span class="keyword">auto</span> readElectricalSeriesData = readElectricalSeries-&gt;readData&lt;<span class="keywordtype">float</span>&gt;();</div>
<div class="line">    DataBlock&lt;float&gt; readDataValues = readElectricalSeriesData-&gt;values();</div>
<div class="line">    <span class="keyword">auto</span> readBoostMultiArray = readDataValues.as_multi_array&lt;2&gt;();</div>
<div class="line">    REQUIRE(readDataValues.data.size() == (numSamples * numChannels));</div>
<div class="line">    REQUIRE(readDataValues.shape[0] == numSamples);</div>
<div class="line">    REQUIRE(readDataValues.shape[1] == numChannels);</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">// We can also read just subsets of the data, e.g., the first 10 time steps</span></div>
<div class="line">    <span class="comment">// for the first channel</span></div>
<div class="line">    <span class="comment">// TODO getting the object again is just for debugging Windows issues</span></div>
<div class="line">    <span class="keyword">auto</span> readElectricalSeriesData2 = readElectricalSeries-&gt;readData&lt;<span class="keywordtype">float</span>&gt;();</div>
<div class="line">    std::vector&lt;SizeType&gt; start = {0, 0};</div>
<div class="line">    std::vector&lt;SizeType&gt; count = {9, 1};</div>
<div class="line">    DataBlock&lt;float&gt; dataSlice =</div>
<div class="line">        readElectricalSeriesData2-&gt;values(start, count);</div>
<div class="line">    <span class="comment">// Validate that the slice was read correctly</span></div>
<div class="line">    REQUIRE(dataSlice.data.size() == 9);</div>
<div class="line">    REQUIRE(dataSlice.shape[0] == 9);</div>
<div class="line">    REQUIRE(dataSlice.shape[1] == 1);</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">// Or read a string attribute, e.g., the unit</span></div>
<div class="line">    std::string esUnitValue =</div>
<div class="line">        readElectricalSeries-&gt;readDataUnit()-&gt;values().data[0];</div>
<div class="line">    REQUIRE(esUnitValue == std::string(<span class="stringliteral">&quot;volts&quot;</span>));</div>
</div><!-- fragment --><h3><a class="anchor" id="read_design_example_read_arbitrary_field"></a>
Reading arbitrary fields</h3>
<p>Even if there is no dedicated <code>DEFINE_FIELD</code> definition available, we can still read any arbitrary sub-field associated with a particular <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> via the generic <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#ae0fb6e951eb0000e4a4fba81db8d466f">RegisteredType::readField</a> method. The main difference is that for datasets and attributes we need to specify all the additional information (e.g., the relative path, object type, and data type) ourselves, whereas using <code>DEFINE_FIELD</code> this information has already been specified for us. For example, to read the data from the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html">ElectricalSeries</a> we can call:</p>
<div class="fragment"><div class="line">    <span class="comment">// Read the data field via the generic readField method</span></div>
<div class="line">    <span class="keyword">auto</span> readElectricalSeriesData3 =</div>
<div class="line">        readElectricalSeries-&gt;readField&lt;StorageObjectType::Dataset, <span class="keywordtype">float</span>&gt;(</div>
<div class="line">            std::string(<span class="stringliteral">&quot;data&quot;</span>));</div>
<div class="line">    <span class="comment">// Read the data values as usual</span></div>
<div class="line">    DataBlock&lt;float&gt; readDataValues3 = readElectricalSeriesData3-&gt;values();</div>
<div class="line">    REQUIRE(readDataValues3.data.size() == (numSamples * numChannels));</div>
</div><!-- fragment --><p>Similarly, we can also read any sub-fields that are itself <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> objects via <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#ae0fb6e951eb0000e4a4fba81db8d466f">RegisteredType::readField</a> (e.g., to read custom <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> columns of a <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_dynamic_table.html">DynamicTable</a>). In contrast to dataset and attribute fields, we here only need to specify the relative path of the field. <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> in turn can read the type information from the <code>neurodata_type</code> and <code>namespace</code> attributes in the file directly.</p>
<div class="fragment"><div class="line">    <span class="comment">// read the ElectricalSeries from the NWBFile object via the readField</span></div>
<div class="line">    <span class="comment">// method returning a generic std::shared_ptr&lt;RegisteredType&gt;</span></div>
<div class="line">    <span class="keyword">auto</span> readRegisteredType = readNWBFile-&gt;readField(esdata_path);</div>
<div class="line">    <span class="comment">// cast the generic pointer to the more specific ElectricalSeries</span></div>
<div class="line">    std::shared_ptr&lt;AQNWB::NWB::ElectricalSeries&gt; readElectricalSeries2 =</div>
<div class="line">        std::dynamic_pointer_cast&lt;AQNWB::NWB::ElectricalSeries&gt;(</div>
<div class="line">            readRegisteredType);</div>
<div class="line">    REQUIRE(readElectricalSeries2 != <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="userdocs.html">For Users</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
