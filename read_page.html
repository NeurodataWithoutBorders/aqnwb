<!-- HTML header for doxygen 1.11.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>aqnwb: Reading data</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow" >
  <td id="projectlogo"><img alt="Logo" src="aqnwb-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">aqnwb<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('read_page.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Reading data</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1">
    <a href="#read_example_open">Opening an existing file for reading</a>
  </li>
  <li class="level1">
    <a href="#read_example_registered_type">Reading NWB neurodata_types</a>
    <ul>
      <li class="level2">
        <a href="#read_example_predefined_registered_type">Reading known RegisteredType objects</a>
      </li>
      <li class="level2">
        <a href="#read_example_search">Searching for RegisteredType objects</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#read_example_read">Reading data from RegisteredType objects</a>
    <ul>
      <li class="level2">
        <a href="#read_design_example_read_posthoc_read_field">Reading predefined data fields</a>
      </li>
      <li class="level2">
        <a href="#read_example_arbitrary">Reading arbitrary fields</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#read_further_reading">Further reading</a>
  </li>
</ul>
</div>
<div class="textblock"><p>Reading data from an existing NWB file via AqNWB consists of the following main steps:</p>
<ol type="1">
<li><a class="el" href="#read_example_open">Opening an existing file for reading</a> by creating and opening a read I/O object for the file.</li>
<li><a class="el" href="#read_example_registered_type">Reading NWB neurodata_types</a> by constructing the corresponding <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> class to represent the <code>neurodata_type</code> , e.g., <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html">NWBFile</a> or <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html">ElectricalSeries</a>. <br  />
</li>
<li><a class="el" href="#read_example_read">Reading data from RegisteredType objects</a> by creating a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a> wrapper object for lazy read access to the particular dataset or attribute field.</li>
<li>Using <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html#a6f847556dc94dc001eb66dda402f72c0">ReadDataWrapper::values</a> we can then request the parts of the data of interest, at which point the data is being loaded from disk and returned as a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html">DataBlock</a>, which contains a 1D vector with the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#a7e084bd163c177f45c41cdf93b61f2b6">data</a> and the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#adcd06e1ef4d9ab65081f8e5ab49eec36">shape</a> of the data.</li>
</ol>
<h1><a class="anchor" id="read_example_open"></a>
Opening an existing file for reading</h1>
<div class="fragment"><div class="line">    <span class="comment">// Open a new I/O for reading</span></div>
<div class="line">    std::shared_ptr&lt;BaseIO&gt; readio = <a class="code hl_function" href="namespace_a_q_n_w_b.html#aae4545d930db6f70b4438e0167c500d0">createIO</a>(<span class="stringliteral">&quot;HDF5&quot;</span>, path);</div>
<div class="line">    readio-&gt;open(FileMode::ReadOnly);</div>
</div><!-- fragment --><dl class="section user"><dt>References:</dt><dd>See <a class="el" href="namespace_a_q_n_w_b.html#aae4545d930db6f70b4438e0167c500d0">createIO</a> and <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_i_o.html">HDF5IO</a></dd></dl>
<h1><a class="anchor" id="read_example_registered_type"></a>
Reading NWB neurodata_types</h1>
<h2><a class="anchor" id="read_example_predefined_registered_type"></a>
Reading known RegisteredType objects</h2>
<p>When the path and type of objects is fixed in the schema (or we know them based on other conventions), then we can read the types directly from the file. E.g., here we first read the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html">NWBFile</a> directly, which we know exists at the root "/" of the file. We then read the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrode_table.html">ElectrodeTable</a> via the predefined <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html#a9df4c1ed0ddceac775116b0377784a1b">NWBFile::readElectrodeTable</a> method. The advantage of this approach is that we do not need to manually specify paths or object types. Similarly, when we read the <code>locations</code> columns, we do not need to specify the name or the data type to use.</p>
<div class="fragment"><div class="line">    <span class="comment">// Read the NWBFile</span></div>
<div class="line">    <span class="keyword">auto</span> readNWBFile =</div>
<div class="line">        <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a01354d1b4230f7495203cc526eae418f">NWB::RegisteredType::create&lt;AQNWB::NWB::NWBFile&gt;</a>(<span class="stringliteral">&quot;/&quot;</span>, readio);</div>
<div class="line">    <span class="comment">// Read the ElectrodesTable</span></div>
<div class="line">    <span class="keyword">auto</span> readElectrodeTable = readNWBFile-&gt;readElectrodeTable();</div>
<div class="line">    <span class="comment">// read the location data. Note that both the type of the class and</span></div>
<div class="line">    <span class="comment">// the data values is being set for us, here, VectorData&lt;std::string&gt;</span></div>
<div class="line">    <span class="keyword">auto</span> locationColumn = readElectrodeTable-&gt;readLocationColumn();</div>
<div class="line">    <span class="keyword">auto</span> locationColumnValues = locationColumn-&gt;readData()-&gt;values();</div>
<div class="line">    <span class="comment">// confirm that the values are correct</span></div>
<div class="line">    std::vector&lt;std::string&gt; expectedLocationValues = {</div>
<div class="line">        <span class="stringliteral">&quot;unknown&quot;</span>, <span class="stringliteral">&quot;unknown&quot;</span>, <span class="stringliteral">&quot;unknown&quot;</span>, <span class="stringliteral">&quot;unknown&quot;</span>};</div>
<div class="line">    REQUIRE(locationColumnValues.data == expectedLocationValues);</div>
</div><!-- fragment --><h2><a class="anchor" id="read_example_search"></a>
Searching for RegisteredType objects</h2>
<p>When paths are not fixed, we can use the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a985277d47989d7cba0f1020a3166da2b">findType()</a> function of our I/O object to conveniently search for objects with a given type.</p>
<div class="fragment"><div class="line">    std::unordered_set&lt;std::string&gt; typesToSearch = {<span class="stringliteral">&quot;core::ElectricalSeries&quot;</span>};</div>
<div class="line">    std::unordered_map&lt;std::string, std::string&gt; found_electrical_series =</div>
<div class="line">        readio-&gt;findTypes(</div>
<div class="line">            <span class="stringliteral">&quot;/&quot;</span>,  <span class="comment">// start search at the root of the file</span></div>
<div class="line">            typesToSearch,  <span class="comment">// search for all ElectricalSeries</span></div>
<div class="line">            <a class="code hl_enumvalue" href="namespace_a_q_n_w_b_1_1_i_o.html#af7fd0e43e0ffc4d765046020e6929035aec2c6b5e5e8c3b3810251e9974647ef8">IO::SearchMode::CONTINUE_ON_TYPE</a>  <span class="comment">// search also within types</span></div>
<div class="line">        );</div>
<div class="line"> </div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a985277d47989d7cba0f1020a3166da2b">findType()</a> supports two main search modes. Using <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html#af7fd0e43e0ffc4d765046020e6929035aec2c6b5e5e8c3b3810251e9974647ef8">CONTINUE_ON_TYPE</a> mode we can search recursively through all types (here the whole file since we started at the root <code>"/"</code>). Using <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html#af7fd0e43e0ffc4d765046020e6929035a0bce90db02919671dbe161b9bd8cef05">STOP_ON_TYPE</a> does not recurse further into defined types, hence, this mode is useful if we only want to search for objects that the object at the starting path manages directly.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The current implementation of <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a985277d47989d7cba0f1020a3166da2b">findTypes()</a> is not aware of inheritance but searches for exact matches of types only. However, we can search for objects of multiple different times at the same time by specifying multiple types to search for in our <code>typesToSearch</code>.</dd></dl>
<p>The <code>found_electrical_series</code> provides us with a map where each key is the path to an object and its corresponding value is the type of the object. Using this information we can read the <code>neurodata_type</code> objects from the file via the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a01354d1b4230f7495203cc526eae418f">RegisteredType::create</a> factory methods to conveniently construct an instance of the corresponding class in AqNWB.</p>
<div class="fragment"><div class="line">    <span class="comment">// Read the ElectricalSeries from the file.</span></div>
<div class="line">    std::string esdata_path = <span class="stringliteral">&quot;/acquisition/esdata0&quot;</span>;</div>
<div class="line">    <span class="keyword">auto</span> readElectricalSeries =</div>
<div class="line">        <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a01354d1b4230f7495203cc526eae418f">NWB::RegisteredType::create&lt;AQNWB::NWB::ElectricalSeries&gt;</a>(esdata_path,</div>
<div class="line">                                                                  readio);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a985277d47989d7cba0f1020a3166da2b">findTypes</a> does not guarantee that objects are returned in any particular order. Instead of retrieving the first object via <code>found_electrical_series.begin()-&gt;first;</code> we here fix the <code>esdata_path</code> path variable to ensure consistent behavior of the tutorial across platforms.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a01354d1b4230f7495203cc526eae418f">RegisteredType::create</a> comes in a few different flavors:<ol type="1">
<li>When passing the 1) <code>path</code> and 2) <code>io</code>, and 3) specifying the type as a template parameter (as in the example above), the instance is being constructed using the common constructor and we get a pointer to the specific type directly. I.e., the above example is equivalent to creating the object via <code>auto readElectricalSeries = ElectricalSeries(path, io)</code>.</li>
<li>When passing only 1) <code>path</code> and 2) <code>io</code>, AqNWB reads the <code>neurodata_type</code> and <code>namespace</code> attributes from the NWB file to determine the type to use (e.g., <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html">ElectricalSeries</a>) and then returns generated instance is then returned as a generic <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> pointer that we can then cast to the specific type if necessary, e.g., via <code>auto readElectricalSeries = std::dynamic_pointer_cast&lt;<a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html" title="General purpose time series.">AQNWB::NWB::ElectricalSeries</a>&gt;(readRegisteredType);</code>.</li>
<li>When passing the 1) <code>fullname</code> (e.g., <code>core::ElectricalSeries</code>), 2) <code>path</code> and 3) <code>io</code>, the behavior is the same as in option 2, but we avoid reading the type <code>neurodata_type</code> and <code>namespace</code> attributes from the file to determine the type. This option is useful when we used <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a985277d47989d7cba0f1020a3166da2b">findTypes</a>, since we have already determined the type information during the search, so that we can use <code>found_electrical_series.begin()-&gt;second</code> to set the <code>fullname</code>.</li>
</ol>
</dd></dl>
<h1><a class="anchor" id="read_example_read"></a>
Reading data from RegisteredType objects</h1>
<p>Now we can read fields and subsets of data from the fields</p>
<h2><a class="anchor" id="read_design_example_read_posthoc_read_field"></a>
Reading predefined data fields</h2>
<p>For fields with a predefined, fixed name in the schema, <a class="el" href="namespace_a_q_n_w_b.html" title="The main namespace for AqNWB.">AQNWB</a> provides read methods for convenient access to such common data fields.</p>
<div class="fragment"><div class="line">    <span class="comment">// Now we can read the data in the same way we did during write</span></div>
<div class="line">    <span class="keyword">auto</span> readElectricalSeriesData = readElectricalSeries-&gt;readData();</div>
<div class="line">    <span class="keyword">auto</span> readDataValues = readElectricalSeriesData-&gt;values();</div>
<div class="line">    <span class="keyword">auto</span> readBoostMultiArray = readDataValues.as_multi_array&lt;2&gt;();</div>
<div class="line">    REQUIRE(readDataValues.data.size() == (numSamples * numChannels));</div>
<div class="line">    REQUIRE(readDataValues.shape[0] == numSamples);</div>
<div class="line">    REQUIRE(readDataValues.shape[1] == numChannels);</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">// We can also read just subsets of the data, e.g., the first 10 time steps</span></div>
<div class="line">    <span class="comment">// for the first channel. &quot;auto dataSlice&quot; is again of type DataBlock&lt;float&gt;</span></div>
<div class="line">    std::vector&lt;SizeType&gt; start = {0, 0};</div>
<div class="line">    std::vector&lt;SizeType&gt; count = {9, 1};</div>
<div class="line">    <span class="keyword">auto</span> dataSlice = readElectricalSeriesData-&gt;values(start, count);</div>
<div class="line">    <span class="comment">// Validate that the slice was read correctly</span></div>
<div class="line">    REQUIRE(dataSlice.data.size() == 9);</div>
<div class="line">    REQUIRE(dataSlice.shape[0] == 9);</div>
<div class="line">    REQUIRE(dataSlice.shape[1] == 1);</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">// Or read a string attribute, e.g., the unit</span></div>
<div class="line">    std::string esUnitValue =</div>
<div class="line">        readElectricalSeries-&gt;readDataUnit()-&gt;values().data[0];</div>
<div class="line">    REQUIRE(esUnitValue == std::string(<span class="stringliteral">&quot;volts&quot;</span>));</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>When working with data in AqNWB, you need to know the data type (e.g., <code>float</code>, <code>int</code>) at compile time since C++ is a strongly typed language. For example, when using <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html">DataBlock</a>, you need to specify the data type. And if you want to use <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#a39c4d437721b818aac335f3c9a57dc97">DataBlock.as_multi_array</a>, you also need to know the number of dimensions at compile time.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>For attributes, slicing is disabled at compile time since attributes are intended for small data only.</dd></dl>
<h2><a class="anchor" id="read_example_arbitrary"></a>
Reading arbitrary fields</h2>
<p>Even if there is no dedicated <code>DEFINE_FIELD</code> definition available, we can still read any arbitrary sub-field associated with a particular <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> via the generic <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#ae0fb6e951eb0000e4a4fba81db8d466f">RegisteredType::readField</a> method. For example, to read the data from the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html">ElectricalSeries</a>:</p>
<div class="fragment"><div class="line">    <span class="comment">// Read the data field via the generic readField method</span></div>
<div class="line">    <span class="keyword">auto</span> readElectricalSeriesData3 =</div>
<div class="line">        readElectricalSeries-&gt;readField&lt;StorageObjectType::Dataset, <span class="keywordtype">float</span>&gt;(</div>
<div class="line">            std::string(<span class="stringliteral">&quot;data&quot;</span>));</div>
<div class="line">    <span class="comment">// Read the data values as usual</span></div>
<div class="line">    <span class="keyword">auto</span> readDataValues3 = readElectricalSeriesData3-&gt;values();</div>
<div class="line">    REQUIRE(readDataValues3.data.size() == (numSamples * numChannels));</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Using this approach, we need to specify the template parameters to use with the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a>, i.e.:<ul>
<li><code>OTYPE</code>: specifies the type of object being wrapped (<a class="el" href="class_a_q_n_w_b_1_1_types.html#a778ba605df5dabb117ede12e41111915">AQNWB::Types::StorageObjectType</a>)</li>
<li><code>VTYPE</code>: defines the value type of the data</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In particular for fields that are optional, it is useful to first check that the field actually exists via <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html#aa67d145711df12192d43d07c3a52546a">ReadDataWrapper::exists</a>.</dd></dl>
<p>Similarly, we can also read any sub-fields that are themselves <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> objects:</p>
<div class="fragment"><div class="line">    <span class="comment">// read the ElectricalSeries from the NWBFile object via the readField</span></div>
<div class="line">    <span class="comment">// method returning a generic std::shared_ptr&lt;RegisteredType&gt;</span></div>
<div class="line">    <span class="keyword">auto</span> readRegisteredType = readNWBFile-&gt;readField(esdata_path);</div>
<div class="line">    <span class="comment">// cast the generic pointer to the more specific ElectricalSeries</span></div>
<div class="line">    std::shared_ptr&lt;AQNWB::NWB::ElectricalSeries&gt; readElectricalSeries2 =</div>
<div class="line">        std::dynamic_pointer_cast&lt;AQNWB::NWB::ElectricalSeries&gt;(</div>
<div class="line">            readRegisteredType);</div>
<div class="line">    REQUIRE(readElectricalSeries2 != <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Even though we here do not specify the template parameter for <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a01354d1b4230f7495203cc526eae418f">RegisteredType::create</a>, the function still creates the correct type by reading the type information from the NWB file, however, because we do not specify the type, the function returns the object as a pointer of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a>, that we can then subsequently cast to the approbriate type if necessary.</dd></dl>
<h1><a class="anchor" id="read_further_reading"></a>
Further reading</h1>
<ul>
<li><a class="el" href="read_design_page.html">Implementation of data read</a> discusses the underlying software design of AqNWB for data read</li>
<li><a class="el" href="registered_type_page.html">Implementing a new Neurodata Type</a> discusses how to implement your own <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> classes for reading and writing data </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="userdocs.html">For Users</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
