<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>aqnwb: Reading Data ðŸ“¤</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom-modern.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="aqnwb-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">aqnwb<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td></tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('read_page.html','',''); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
</script>
<div id="main-nav"></div>
<div id="container"><div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Reading Data ðŸ“¤ </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Reading data from an existing NWB file via AqNWB consists of the following main steps:</p>
<ol type="1">
<li><a class="el" href="#read_example_open">Opening an existing file for reading</a> by creating and opening a read I/O object for the file.</li>
<li><a class="el" href="#read_example_registered_type">Reading NWB neurodata_types</a> by constructing the corresponding <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> class to represent the <span class="tt">neurodata_type</span> , e.g., <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html">NWBFile</a> or <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html">ElectricalSeries</a>. <br  />
</li>
<li><a class="el" href="#read_example_read">Reading data from RegisteredType objects</a> by creating a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a> wrapper object for lazy read access to the particular dataset or attribute field.</li>
<li>Using <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html#a6f847556dc94dc001eb66dda402f72c0">ReadDataWrapper::values</a> we can then request the parts of the data of interest, at which point the data is being loaded from disk and returned as a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html">DataBlock</a>, which contains a 1D vector with the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#a7e084bd163c177f45c41cdf93b61f2b6">data</a> and the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html#adcd06e1ef4d9ab65081f8e5ab49eec36">shape</a> of the data.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="read_example_open"></a>
Opening an existing file for reading</h1>
<div class="fragment"><div class="line">    <span class="comment">// Open a new I/O for reading</span></div>
<div class="line">    std::shared_ptr&lt;BaseIO&gt; readio = <a class="code hl_function" href="namespace_a_q_n_w_b.html#aae4545d930db6f70b4438e0167c500d0">createIO</a>(<span class="stringliteral">&quot;HDF5&quot;</span>, path);</div>
<div class="line">    readio-&gt;open(FileMode::ReadOnly);</div>
</div><!-- fragment --><dl class="section user"><dt>References:</dt><dd>See <a class="el" href="namespace_a_q_n_w_b.html#aae4545d930db6f70b4438e0167c500d0">createIO</a> and <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_h_d_f5_1_1_h_d_f5_i_o.html">HDF5IO</a></dd></dl>
<h1 class="doxsection"><a class="anchor" id="read_example_registered_type"></a>
Reading NWB neurodata_types</h1>
<h2 class="doxsection"><a class="anchor" id="read_example_predefined_registered_type"></a>
Reading known RegisteredType objects</h2>
<p>When the path and type of objects is fixed in the schema (or we know them based on other conventions), then we can read the types directly from the file. E.g., here we first read the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html">NWBFile</a> directly, which we know exists at the root "/" of the file. We then read the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrode_table.html">ElectrodeTable</a> via the predefined <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html#a9df4c1ed0ddceac775116b0377784a1b">NWBFile::readElectrodeTable</a> method. The advantage of this approach is that we do not need to manually specify paths or object types. Similarly, when we read the <span class="tt">locations</span> columns, we do not need to specify the name or the data type to use.</p>
<div class="fragment"><div class="line">    <span class="comment">// Read the NWBFile</span></div>
<div class="line">    <span class="keyword">auto</span> readNWBFile =</div>
<div class="line">        <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">NWB::RegisteredType::create&lt;AQNWB::NWB::NWBFile&gt;</a>(<span class="stringliteral">&quot;/&quot;</span>, readio);</div>
<div class="line">    <span class="comment">// Read the ElectrodesTable</span></div>
<div class="line">    <span class="keyword">auto</span> readElectrodeTable = readNWBFile-&gt;readElectrodeTable();</div>
<div class="line">    <span class="comment">// read the location data. Note that both the type of the class and</span></div>
<div class="line">    <span class="comment">// the data values is being set for us, here, VectorDataTyped&lt;std::string&gt;</span></div>
<div class="line">    <span class="keyword">auto</span> locationColumn = readElectrodeTable-&gt;readLocationColumn();</div>
<div class="line">    <span class="keyword">auto</span> locationColumnValues = locationColumn-&gt;readData()-&gt;values();</div>
<div class="line">    <span class="comment">// confirm that the values are correct</span></div>
<div class="line">    std::vector&lt;std::string&gt; expectedLocationValues = {</div>
<div class="line">        <span class="stringliteral">&quot;unknown&quot;</span>, <span class="stringliteral">&quot;unknown&quot;</span>, <span class="stringliteral">&quot;unknown&quot;</span>, <span class="stringliteral">&quot;unknown&quot;</span>};</div>
<div class="line">    REQUIRE(locationColumnValues.data == expectedLocationValues);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="read_example_search"></a>
Searching for RegisteredType objects</h2>
<p>When paths are not fixed, we can use the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a788603f4c9c2698aad610134ab89f8e1">findTypes()</a> function of our I/O object to conveniently search for objects with a given type.</p>
<div class="fragment"><div class="line">    std::unordered_set&lt;std::string&gt; typesToSearch = {<span class="stringliteral">&quot;core::ElectricalSeries&quot;</span>};</div>
<div class="line">    std::unordered_map&lt;std::string, std::string&gt; found_electrical_series =</div>
<div class="line">        readio-&gt;findTypes(</div>
<div class="line">            <span class="stringliteral">&quot;/&quot;</span>,  <span class="comment">// start search at the root of the file</span></div>
<div class="line">            typesToSearch,  <span class="comment">// search for all ElectricalSeries</span></div>
<div class="line">            <a class="code hl_enumvalue" href="namespace_a_q_n_w_b_1_1_i_o.html#af7fd0e43e0ffc4d765046020e6929035aec2c6b5e5e8c3b3810251e9974647ef8">IO::SearchMode::CONTINUE_ON_TYPE</a>  <span class="comment">// search also within types</span></div>
<div class="line">        );</div>
<div class="line"> </div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Any <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> (such as our <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html">NWBFile</a>) object) provides the convenience method <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a8a83a775f6a8a94d6ae3428e05ef9bfc">findOwnedTypes</a> which uses <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a788603f4c9c2698aad610134ab89f8e1">findTypes()</a> to search within the given object (so that we don't need to specify the path argument). By default, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a8a83a775f6a8a94d6ae3428e05ef9bfc">findOwnedTypes</a> uses the <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html#af7fd0e43e0ffc4d765046020e6929035a0bce90db02919671dbe161b9bd8cef05">STOP_ON_TYPE</a> mode, i.e., the search does not recurse further into defined types (hence, returning only data elements that the object owns directly). Alternatively, we can set the search mode to <a class="el" href="namespace_a_q_n_w_b_1_1_i_o.html#af7fd0e43e0ffc4d765046020e6929035aec2c6b5e5e8c3b3810251e9974647ef8">CONTINUE_ON_TYPE</a> to search recursively through all types (here the whole file since we started at the root <span class="tt">"/"</span>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The current implementation of <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a788603f4c9c2698aad610134ab89f8e1">findTypes()</a> is not aware of inheritance but searches for exact matches of types only. However, we can search for objects of multiple different times at the same time by specifying multiple types to search for in our <span class="tt">typesToSearch</span>.</dd></dl>
<p>The <span class="tt">found_electrical_series</span> provides us with a map where each key is the path to an object and its corresponding value is the type of the object. Using this information we can read the <span class="tt">neurodata_type</span> objects from the file via the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">RegisteredType::create</a> factory methods to conveniently construct an instance of the corresponding class in AqNWB.</p>
<div class="fragment"><div class="line">    <span class="comment">// Read the ElectricalSeries from the file.</span></div>
<div class="line">    std::string esdata_path = <span class="stringliteral">&quot;/acquisition/esdata0&quot;</span>;</div>
<div class="line">    <span class="keyword">auto</span> readElectricalSeries =</div>
<div class="line">        <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">NWB::RegisteredType::create&lt;AQNWB::NWB::ElectricalSeries&gt;</a>(esdata_path,</div>
<div class="line">                                                                  readio);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a788603f4c9c2698aad610134ab89f8e1">findTypes</a> does not guarantee that objects are returned in any particular order. Instead of retrieving the first object via <span class="tt">found_electrical_series.begin()-&gt;first;</span> we here fix the <span class="tt">esdata_path</span> path variable to ensure consistent behavior of the tutorial across platforms.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">RegisteredType::create</a> comes in a few different flavors:<ol type="1">
<li>When passing the 1) <span class="tt">path</span> and 2) <span class="tt">io</span>, and 3) specifying the type as a template parameter (as in the example above), the instance is being constructed using the common constructor and we get a pointer to the specific type directly. I.e., the above example is equivalent to creating the object via <span class="tt">auto readElectricalSeries = ElectricalSeries(path, io)</span>.</li>
<li>When passing only 1) <span class="tt">path</span> and 2) <span class="tt">io</span>, AqNWB reads the <span class="tt">neurodata_type</span> and <span class="tt">namespace</span> attributes from the NWB file to determine the type to use (e.g., <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html">ElectricalSeries</a>) and then returns generated instance is then returned as a generic <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> pointer that we can then cast to the specific type if necessary, e.g., via <span class="tt">auto readElectricalSeries = std::dynamic_pointer_cast&lt;<a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html" title="General purpose time series.">AQNWB::NWB::ElectricalSeries</a>&gt;(readRegisteredType);</span>.</li>
<li>When passing the 1) <span class="tt">fullname</span> (e.g., <span class="tt">core::ElectricalSeries</span>), 2) <span class="tt">path</span> and 3) <span class="tt">io</span>, the behavior is the same as in option 2, but we avoid reading the type <span class="tt">neurodata_type</span> and <span class="tt">namespace</span> attributes from the file to determine the type. This option is useful when we used <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html#a788603f4c9c2698aad610134ab89f8e1">findTypes</a>, since we have already determined the type information during the search, so that we can use <span class="tt">found_electrical_series.begin()-&gt;second</span> to set the <span class="tt">fullname</span>.</li>
</ol>
</dd></dl>
<h1 class="doxsection"><a class="anchor" id="read_example_read"></a>
Reading data from RegisteredType objects</h1>
<p>Now we can read fields and subsets of data from the fields</p>
<h2 class="doxsection"><a class="anchor" id="read_design_example_read_posthoc_read_field"></a>
Reading predefined data fields</h2>
<p>For fields with a predefined, fixed name in the schema, <a class="el" href="namespace_a_q_n_w_b.html" title="The main namespace for AqNWB.">AQNWB</a> provides read methods for convenient access to such common data fields.</p>
<div class="fragment"><div class="line">    <span class="comment">// Now we can read the data in the same way we did during write</span></div>
<div class="line">    <span class="keyword">auto</span> readElectricalSeriesData = readElectricalSeries-&gt;readData();</div>
<div class="line">    <span class="keyword">auto</span> readDataValues = readElectricalSeriesData-&gt;values();</div>
<div class="line">    <span class="keyword">auto</span> readBoostMultiArray = readDataValues.as_multi_array&lt;2&gt;();</div>
<div class="line">    REQUIRE(readDataValues.data.size() == (numSamples * numChannels));</div>
<div class="line">    REQUIRE(readDataValues.shape[0] == numSamples);</div>
<div class="line">    REQUIRE(readDataValues.shape[1] == numChannels);</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">// We can also read just subsets of the data, e.g., the first 10 time steps</span></div>
<div class="line">    <span class="comment">// for the first channel. &quot;auto dataSlice&quot; is again of type DataBlock&lt;float&gt;</span></div>
<div class="line">    std::vector&lt;SizeType&gt; start = {0, 0};</div>
<div class="line">    std::vector&lt;SizeType&gt; count = {9, 1};</div>
<div class="line">    <span class="keyword">auto</span> dataSlice = readElectricalSeriesData-&gt;values(start, count);</div>
<div class="line">    <span class="comment">// Validate that the slice was read correctly</span></div>
<div class="line">    REQUIRE(dataSlice.data.size() == 9);</div>
<div class="line">    REQUIRE(dataSlice.shape[0] == 9);</div>
<div class="line">    REQUIRE(dataSlice.shape[1] == 1);</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">// Or read a string attribute, e.g., the unit</span></div>
<div class="line">    std::string esUnitValue =</div>
<div class="line">        readElectricalSeries-&gt;readDataUnit()-&gt;values().data[0];</div>
<div class="line">    REQUIRE(esUnitValue == std::string(<span class="stringliteral">&quot;volts&quot;</span>));</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>For attributes, slicing is disabled at compile time since attributes are intended for small data only.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="read_example_arbitrary"></a>
Reading arbitrary fields</h2>
<p>Even if there is no dedicated <span class="tt">DEFINE_ATTRIBUTE_FIELD</span> or <span class="tt">DEFINE_DATASET_FIELD</span> definition available, we can still read any arbitrary sub-field associated with a particular <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> via the generic <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#adc5ba3d9e27c74f8181944e505bba6e5">RegisteredType::readField</a> method. For example, to read the data from the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html">ElectricalSeries</a>:</p>
<div class="fragment"><div class="line">    <span class="comment">// Read the data field via the generic readField method</span></div>
<div class="line">    <span class="keyword">auto</span> readElectricalSeriesData3 =</div>
<div class="line">        readElectricalSeries-&gt;readField&lt;StorageObjectType::Dataset, <span class="keywordtype">float</span>&gt;(</div>
<div class="line">            std::string(<span class="stringliteral">&quot;data&quot;</span>));</div>
<div class="line">    <span class="comment">// Read the data values as usual</span></div>
<div class="line">    <span class="keyword">auto</span> readDataValues3 = readElectricalSeriesData3-&gt;values();</div>
<div class="line">    REQUIRE(readDataValues3.data.size() == (numSamples * numChannels));</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Using this approach, we need to specify the template parameters to use with the <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a>, i.e.:<ul>
<li><span class="tt">OTYPE</span>: specifies the type of object being wrapped (<a class="el" href="class_a_q_n_w_b_1_1_types.html#a778ba605df5dabb117ede12e41111915">AQNWB::Types::StorageObjectType</a>)</li>
<li><span class="tt">VTYPE</span>: defines the value type of the data</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In particular for fields that are optional, it is useful to first check that the field actually exists via <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html#aa67d145711df12192d43d07c3a52546a">ReadDataWrapper::exists</a>.</dd></dl>
<p>Similarly, we can also read any sub-fields that are themselves <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> objects:</p>
<div class="fragment"><div class="line">    <span class="comment">// read the ElectricalSeries from the NWBFile object via the readField</span></div>
<div class="line">    <span class="comment">// method returning a generic std::shared_ptr&lt;RegisteredType&gt;</span></div>
<div class="line">    <span class="keyword">auto</span> readRegisteredType = readNWBFile-&gt;readField(esdata_path);</div>
<div class="line">    <span class="comment">// cast the generic pointer to the more specific ElectricalSeries</span></div>
<div class="line">    std::shared_ptr&lt;AQNWB::NWB::ElectricalSeries&gt; readElectricalSeries2 =</div>
<div class="line">        std::dynamic_pointer_cast&lt;AQNWB::NWB::ElectricalSeries&gt;(</div>
<div class="line">            readRegisteredType);</div>
<div class="line">    REQUIRE(readElectricalSeries2 != <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Even though we here do not specify the template parameter for <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">RegisteredType::create</a>, the function still creates the correct type by reading the type information from the NWB file, however, because we do not specify the type, the function returns the object as a pointer of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a>, that we can then subsequently cast to the approbriate type if necessary.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="read_example_variant_data"></a>
Working with fields with unknown data type</h2>
<p>C++ is a statically typed language, i.e., we need to know the type of every variable at compile time. This can be particularly challenging when reading data from disk where the data type may not be known before-hand. AqNWB helps us here by allocating memory and determining data types for us when reading data fields. However, when we want to compute on the data, we still need to know the data type, e.g., to use the typed <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block.html">DataBlock&lt;DTYPE&gt;</a> we need to know the DTYPE.</p>
<p>Using <a href="https://en.cppreference.com/w/cpp/utility/variant">std::variant</a> with <a href="https://en.cppreference.com/w/cpp/utility/variant/visit">std::visit</a> (introduced in C++17) provides an alternative approach, that can help us avoid having to write complex <span class="tt">switch/case</span> statements to check for all possible types when we don't know the data type beforehand. E.g., using <span class="tt">std::visit</span> we can define a set of functions to compute the mean for any 1D <span class="tt">std::vector</span>:</p>
<div class="fragment"><div class="line"><span class="comment">// Helper function to compute the mean of a vector</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">double</span> compute_mean(<span class="keyword">const</span> T&amp; data)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (data.empty()) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Data vector is empty&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">double</span> sum = std::accumulate(data.begin(), data.end(), 0.0);</div>
<div class="line">  <span class="keywordflow">return</span> sum / data.size();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Function to compute the mean using std::visit</span></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">double</span> compute_mean(<span class="keyword">const</span> BaseDataType::BaseDataVectorVariant&amp; variant)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> std::visit(</div>
<div class="line">      [](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">double</span></div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">using </span>T = std::decay_t&lt;<span class="keyword">decltype</span>(arg)&gt;;</div>
<div class="line">        <span class="comment">// Check that the variant represents a BaseDataType we can compute on</span></div>
<div class="line">        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;T, std::monostate&gt;) {</div>
<div class="line">          <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Invalid data type&quot;</span>);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;T, std::vector&lt;std::string&gt;&gt;) {</div>
<div class="line">          <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Cannot compute mean of string data&quot;</span>);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">return</span> compute_mean(arg);  <span class="comment">// Compute the mean</span></div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line">      variant);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Using <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_data_block_generic.html#a957ab6f55f6be707def1ae317948a6eb">DataBlockGeneric::as_variant</a> we can then cast our data to a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_data_type.html#ace36552e3d3f31981bfd32a4d9540312">BaseDataVectorVariant</a>, which is am <span class="tt">std::variant</span> representing a 1D <span class="tt">std::vector</span> containing values of any valid <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_data_type.html">BaseDataType</a>. We can then using our <span class="tt">compute_mean</span> methods to conveniently compute on the data without having to explicitly specify the type of the data ourselves.</p>
<div class="fragment"><div class="line">    <span class="comment">// Compute the mean using the std::variant approach. We specify</span></div>
<div class="line">    <span class="comment">// the types of variables for clarity, but could us &quot;auto&quot; instead</span></div>
<div class="line">    DataBlockGeneric genericDataBlock =</div>
<div class="line">        readElectricalSeriesData-&gt;valuesGeneric();</div>
<div class="line">    BaseDataType::BaseDataVectorVariant variantData =</div>
<div class="line">        genericDataBlock.as_variant();</div>
<div class="line">    <span class="keywordtype">double</span> meanFromVariant = compute_mean(variantData);</div>
<div class="line">    <span class="comment">// Compare with computing the mean from the typed DataBlock&lt;float&gt;. We</span></div>
<div class="line">    <span class="comment">// specify the template type for clarity although the compiler can infer it.</span></div>
<div class="line">    <span class="keywordtype">double</span> meanFromTypedVector =</div>
<div class="line">        compute_mean&lt;std::vector&lt;float&gt;&gt;(readDataValues.data);</div>
<div class="line">    REQUIRE(meanFromVariant == Catch::Approx(meanFromTypedVector));</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="read_further_reading"></a>
Further reading</h1>
<ul>
<li><a class="el" href="read_design_page.html">Implementation of Data Read ðŸ“¤</a> discusses the underlying software design of AqNWB for data read</li>
<li><a class="el" href="registered_type_page.html">Implementing a Registered Type ðŸ”§</a> discusses how to implement your own <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> classes for reading and writing data</li>
<li><span class="tt">demo/inspect_electrical_series</span> in the <a href="https://github.com/NeurodataWithoutBorders/aqnwb">AqNWB repo</a> contains a demo program that illustrates the use of AqNWB for inspecticing <span class="tt">ElectricalSeries</span> data in an arbitrary NWB file. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="userdocs.html">For Users</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
