<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>aqnwb: Implementing a new Neurodata Type</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom-modern.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="aqnwb-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">aqnwb<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td></tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('registered_type_page.html','',''); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
</script>
<div id="main-nav"></div>
<div id="container"><div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Implementing a new Neurodata Type </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>New neurodata_types typically inherit from at least either <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html">Container</a> or <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data.html">Data</a>, or a more specialized type of the two. In any case, all classes that represent a <span class="tt">neurodata_type</span> defined in the schema should be implemented as a subtype of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a>. Here we focus on how to implement new subclasses of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a>. If you want to learn more about the how <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> manages types and implements data read then please see <a class="el" href="read_design_page.html">Implementation of data read</a>.</p>
<h1 class="doxsection"><a class="anchor" id="implement_registered_type"></a>
How to Implement a RegisteredType</h1>
<p>To implement a subclass of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a>, follow these steps:</p>
<ol type="1">
<li>Include the <span class="tt"><a class="el" href="_registered_type_8hpp.html">RegisteredType.hpp</a></span> header file in your subclass header file (or the header of your more specific parent class that inherits from <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a>). <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_registered_type_8hpp.html">nwb/RegisteredType.hpp</a>&quot;</span></div>
<div class="ttc" id="a_registered_type_8hpp_html"><div class="ttname"><a href="_registered_type_8hpp.html">RegisteredType.hpp</a></div></div>
</div><!-- fragment --> Also include the schema header file with the definition of the namespace schema. E.g., in the case of a type from the NWB core schema: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="core_8hpp.html">spec/core.hpp</a>&quot;</span></div>
<div class="ttc" id="acore_8hpp_html"><div class="ttname"><a href="core_8hpp.html">core.hpp</a></div></div>
</div><!-- fragment --></li>
<li>Define your subclass by inheriting from <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> (or one of its child classes). Ensure that your subclass implements a constructor with the arguments <span class="tt">(const std::string&amp; path, std::shared_ptr&lt;IO::BaseIO&gt; io)</span>, as the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">RegisteredType::create</a> method expects this constructor signature. <div class="fragment"><div class="line"><span class="keyword">class </span>MySubClass : <span class="keyword">public</span> <a class="code hl_class" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">AQNWB::NWB::RegisteredType</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MySubClass(<span class="keyword">const</span> std::string&amp; path, std::shared_ptr&lt;IO::BaseIO&gt; io)</div>
<div class="line">        : RegisteredType(path, io) {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Implement any additional methods or overrides here</span></div>
<div class="line">};</div>
<div class="ttc" id="aclass_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_html"><div class="ttname"><a href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">AQNWB::NWB::RegisteredType</a></div><div class="ttdoc">Base class for types defined in the NWB schema.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:48</div></div>
</div><!-- fragment --></li>
<li>Use the <a class="el" href="_registered_type_8hpp.html#a9c1f79aa46baaf33d1bf885cf7484aa1">REGISTER_SUBCLASS</a> macro to prepare your subclass for registration with the class registry defined by <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a>. This should usually appear in the header (<span class="tt">hpp</span>) file as part of the class definition: <div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#a9c1f79aa46baaf33d1bf885cf7484aa1">REGISTER_SUBCLASS</a>(MySubClass,  <a class="code hl_variable" href="namespace_a_q_n_w_b_1_1_s_p_e_c_1_1_c_o_r_e.html#a1aeb5d31d5889e9b9b104dcaef2bb323">AQNWB::SPEC::CORE::namespaceName</a>)</div>
<div class="ttc" id="a_registered_type_8hpp_html_a9c1f79aa46baaf33d1bf885cf7484aa1"><div class="ttname"><a href="_registered_type_8hpp.html#a9c1f79aa46baaf33d1bf885cf7484aa1">REGISTER_SUBCLASS</a></div><div class="ttdeci">#define REGISTER_SUBCLASS(T, NAMESPACE)</div><div class="ttdoc">Macro to register a subclass with the RegisteredType class registry.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:373</div></div>
<div class="ttc" id="anamespace_a_q_n_w_b_1_1_s_p_e_c_1_1_c_o_r_e_html_a1aeb5d31d5889e9b9b104dcaef2bb323"><div class="ttname"><a href="namespace_a_q_n_w_b_1_1_s_p_e_c_1_1_c_o_r_e.html#a1aeb5d31d5889e9b9b104dcaef2bb323">AQNWB::SPEC::CORE::namespaceName</a></div><div class="ttdeci">const std::string namespaceName</div><div class="ttdef"><b>Definition</b> core.hpp:12</div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Using the <a class="el" href="namespace_a_q_n_w_b_1_1_s_p_e_c_1_1_c_o_r_e.html#a1aeb5d31d5889e9b9b104dcaef2bb323">namespaceName</a> variable to define the name of our namespace has two main advantages: 1) it ensure that the namespace name is consistent, and 2) it ensures that we include the schema header file which ensures that that the schema is registered with the <a class="el" href="class_a_q_n_w_b_1_1_s_p_e_c_1_1_namespace_registry.html">NamespaceRegistry</a> and cached in the file by <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html#a5fe5d0aba7a050db86d5caa5b8cf4a04">NWBFile::initialize</a> when creating a new NWB file.</dd></dl>
</li>
<li>In the corresponding source (<span class="tt">cpp</span>) file, initialize the static member to trigger the registration using the <a class="el" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a> macro: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;MySubClass.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize the static member to trigger registration</span></div>
<div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a>(MySubClass)</div>
<div class="ttc" id="a_registered_type_8hpp_html_a54ea7671d2bcf5bae392b8ba1824961e"><div class="ttname"><a href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a></div><div class="ttdeci">#define REGISTER_SUBCLASS_IMPL(T)</div><div class="ttdoc">Macro to initialize the static member registered_ to trigger registration.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:385</div></div>
</div><!-- fragment --></li>
<li>To define getter methods for lazy read access to datasets and attributes that belong to our type, we can use the <a class="el" href="_registered_type_8hpp.html#acd3c876a1c357333cd4a8ff27300ee08">DEFINE_FIELD</a> macro. This macro creates a standard method for retrieving a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a> for lazy reading for the field: <div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#acd3c876a1c357333cd4a8ff27300ee08">DEFINE_FIELD</a>(getData, DatasetField, <span class="keywordtype">float</span>, <span class="stringliteral">&quot;data&quot;</span>, The main data)</div>
<div class="ttc" id="a_registered_type_8hpp_html_acd3c876a1c357333cd4a8ff27300ee08"><div class="ttname"><a href="_registered_type_8hpp.html#acd3c876a1c357333cd4a8ff27300ee08">DEFINE_FIELD</a></div><div class="ttdeci">#define DEFINE_FIELD(name, storageObjectType, default_type, fieldPath, description)</div><div class="ttdoc">Defines a lazy-loaded field accessor function.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:407</div></div>
</div><!-- fragment --></li>
<li>Similarly, we use the <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a> macro to define getter methods for other <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> objects that we own, such as a <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrode_table.html">ElectrodeTable</a> that owns predefined <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> columns: <div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a>(readGroupNameColumn, VectorData&lt;std::string&gt;, <span class="stringliteral">&quot;group_name&quot;</span>, <span class="stringliteral">&quot;the name of the ElectrodeGroup&quot;</span>)</div>
<div class="ttc" id="a_registered_type_8hpp_html_af374245a4f6d5a00540e9fdba52a652a"><div class="ttname"><a href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a></div><div class="ttdeci">#define DEFINE_REGISTERED_FIELD(name, registeredType, fieldPath, description)</div><div class="ttdoc">Defines a lazy-loaded accessor function for reading fields that are RegisteredTypes.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:439</div></div>
</div><!-- fragment --></li>
<li>When inheriting from the more specific <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html">Container</a> or <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data.html">Data</a> types, then we will typically also need to implement an <span class="tt">initialize</span> method, which is responsible for creating the relevant Groups, Datasets, and Attributes in the file for data write. Remember to also call the <span class="tt">initialize</span> method of the parent class.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd><span class="tt">DEFINE_FIELD</span> and <span class="tt">DEFINE_REGISTERED_FIELD</span> create templated, non-virtual read functions. This means if we want to "redefine" a field in a child class by calling <span class="tt">DEFINE_FIELD</span> again, then the function will be "hidden" instead of "override". This is important to remember when casting a pointer to a base type, as in this case the implementation from the base type will be used since the function created by <span class="tt">DEFINE_FIELD</span> is not virtual.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="implement_registered_type_example"></a>
Example: Implementing a new type</h2>
<p><em>MySubClass.hpp</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_registered_type_8hpp.html">RegisteredType.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;spec/my_namespace.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MySubClass : <span class="keyword">public</span> <a class="code hl_class" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">AQNWB::NWB::RegisteredType</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MySubClass(<span class="keyword">const</span> std::string&amp; path, std::shared_ptr&lt;IO::BaseIO&gt; io)</div>
<div class="line">        : RegisteredType(path, io) {}</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="_registered_type_8hpp.html#acd3c876a1c357333cd4a8ff27300ee08">DEFINE_FIELD</a>(getData, DatasetField, <span class="keywordtype">float</span>, <span class="stringliteral">&quot;data&quot;</span>, The main data)</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="_registered_type_8hpp.html#a9c1f79aa46baaf33d1bf885cf7484aa1">REGISTER_SUBCLASS</a>(MySubClass, AQNWB::SPEC::MYNAMESPACE::namespaceName)</div>
<div class="line">};</div>
</div><!-- fragment --><p><em>MySubClass.cpp</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;MySubClass.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize the static member to trigger registration</span></div>
<div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a>(MySubClass)</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>To ensure proper function on read, the name of the class should match the name of the <span class="tt">neurodata_type</span> as defined in the schema. Similarly, "my-namespace" should match the name of the namespace in the schema (e.g., "core", "hdmf-common"). In this way we can look up the corresponding class for an object in a file based on the <span class="tt">neurodata_type</span> and <span class="tt">namespace</span> attributes stored in the file. A special version of the <span class="tt">REGISTER_SUBCLASS</span> macro, called <span class="tt">REGISTER_SUBCLASS_WITH_TYPENAME</span>, allows setting the typename explicitly as a third argument. This is for the <b>special case</b> where the name of the class cannot be the same as the name of the type (e.g,. when implementing a class that doesn't have an assigned type in the schema or a class that requires template parameters that are not part of the type name). See <a class="el" href="#using_registered_subclass_with_typename">How to implement a RegisteredType with a custom type name</a> for details.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="use_the_define_field_macro"></a>
DEFINE_FIELD: Creating read methods for datasets and attributes</h2>
<p>The <a class="el" href="_registered_type_8hpp.html#acd3c876a1c357333cd4a8ff27300ee08">DEFINE_FIELD</a> macro takes the following main inputs:</p>
<ul>
<li><span class="tt">name</span>: The name of the function to generate.</li>
<li><span class="tt">storageObjectType</span> : One of either <a class="el" href="namespace_a_q_n_w_b_1_1_n_w_b.html#acfd896b65a7f56c25b3730a6e8dc80ca">DatasetField</a> or <a class="el" href="namespace_a_q_n_w_b_1_1_n_w_b.html#a4a7413b10eb1a838f0349fc59b5a333f">AttributeField</a> to define the type of storage object used to store the field.</li>
<li><span class="tt">default_type</span> : The default data type to use. If not known, we can use <span class="tt">std::any</span>.</li>
<li><span class="tt">fieldPath</span> : Literal string with the relative path to the field within the schema of the respective neurodata_type. This is automatically being expanded at runtime to the full path.</li>
<li><span class="tt">description</span> : Description of the field to include in the docstring for the docs</li>
</ul>
<p>All of these inputs are required. A typical example will look as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#acd3c876a1c357333cd4a8ff27300ee08">DEFINE_FIELD</a>(getData, DatasetField, <span class="keywordtype">float</span>, <span class="stringliteral">&quot;data&quot;</span>, The main data)</div>
</div><!-- fragment --><p>The compiler will then expand this definition to create a new method (here called <span class="tt">getData</span>) that will return a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a> for lazy reading for the field. The corresponding expanded function will look something like:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VTYPE = <span class="keywordtype">float</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> std::unique_ptr&lt;IO::ReadDataWrapper&lt;DatasetField, VTYPE&gt;&gt; getData()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unique&lt;IO::ReadDataWrapper&lt;DatasetField, VTYPE&gt;&gt;(</div>
<div class="line">         m_io,</div>
<div class="line">         <a class="code hl_function" href="namespace_a_q_n_w_b.html#a31983dbaaa85c2e355b9687fc0ef1881">AQNWB::mergePaths</a>(m_path, fieldPath));</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_a_q_n_w_b_html_a31983dbaaa85c2e355b9687fc0ef1881"><div class="ttname"><a href="namespace_a_q_n_w_b.html#a31983dbaaa85c2e355b9687fc0ef1881">AQNWB::mergePaths</a></div><div class="ttdeci">static std::string mergePaths(const std::string &amp;path1, const std::string &amp;path2)</div><div class="ttdoc">Merge two paths into a single path, handling extra trailing and starting &quot;/&quot;.</div><div class="ttdef"><b>Definition</b> Utils.hpp:112</div></div>
</div><!-- fragment --><p>See <a class="el" href="read_page.html">Reading data</a> for an example of how to use such methods (e.g., <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_time_series.html#a8a43d4c249f6865ee4f77c58a91b6546">TimeSeries::readData</a> ) for reading data fields from a file.</p>
<h2 class="doxsection"><a class="anchor" id="use_the_define_registered_field_macro"></a>
DEFINE_REGISTERED_FIELD: Defining read methods for neurodata_type objects</h2>
<p>The <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a> macro works much like the <a class="el" href="_registered_type_8hpp.html#acd3c876a1c357333cd4a8ff27300ee08">DEFINE_FIELD</a> macro macro but returns instances of specific subtypes of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a>, rather than <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a>. As such the main inputs for <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a> are as follows:</p>
<ul>
<li><span class="tt">name</span>: The name of the function to generate.</li>
<li><span class="tt">registeredType</span> : The specific subclass of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> to use</li>
<li><span class="tt">fieldPath</span> : Literal string with the relative path to the field within the schema of the respective neurodata_type. This is automatically being expanded at runtime to the full path.</li>
<li><span class="tt">description</span> : Description of the field to include in the docstring for the docs</li>
</ul>
<p>All of these inputs are required. A typical example will look as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a>(getMyTable, DynamicTable, <span class="stringliteral">&quot;my_table&quot;</span>, My data table)</div>
</div><!-- fragment --><p>The compiler will then expand this definition to create a new read method, in this called <span class="tt">getMyTable</span> that returns a <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_dynamic_table.html">DynamicTable</a> for reading "my_table". The corresponding expanded function will look something like:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RTYPE = DynamicTable&gt; </div>
<div class="line"><span class="keyword">inline</span> std::shared_ptr&lt;RTYPE&gt; getMyTable()<span class="keyword"> const </span></div>
<div class="line"><span class="keyword"></span>{ </div>
<div class="line">  std::string objectPath = <a class="code hl_function" href="namespace_a_q_n_w_b.html#a31983dbaaa85c2e355b9687fc0ef1881">AQNWB::mergePaths</a>(m_path, fieldPath); </div>
<div class="line">  <span class="keywordflow">if</span> (m_io-&gt;objectExists(objectPath)) { </div>
<div class="line">    <span class="keywordflow">return</span> RegisteredType::create&lt;RTYPE&gt;(objectPath, m_io); </div>
<div class="line">  } </div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">nullptr</span>; </div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="use_the_define_referenced_registered_field_macro"></a>
DEFINE_REFERENCED_REGISTERED_FIELD: Defining read methods for references to neurodata_type objects</h2>
<p>The <a class="el" href="_registered_type_8hpp.html#a3b2c847e459e9e30e65e38897303a9a5">DEFINE_REFERENCED_REGISTERED_FIELD</a> macro works exactly like the <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a> macro, but the underlying data is an attribute that stores a reference to an instances of a specific subtype of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> rather than the instance of the object directly. I.e., <span class="tt">fieldPath</span> here is the relative path to the attribute that stores the reference, rather than the relative path of the object itself. The generated read method then resolves the reference first and then returns the instance of the object that is being referenced.</p>
<h1 class="doxsection"><a class="anchor" id="using_registered_subclass_with_typename"></a>
How to implement a RegisteredType with a custom type name</h1>
<p>In most cases, the name of our <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> class should be the same as the <span class="tt">neurodata_type</span>. However, in some cases this may not be possible. In this case, we need to use <a class="el" href="_registered_type_8hpp.html#af20769bbf87fb10f70c36fe248deaf4d">REGISTER_SUBCLASS_WITH_TYPENAME</a> macro instead of <a class="el" href="_registered_type_8hpp.html#a9c1f79aa46baaf33d1bf885cf7484aa1">REGISTER_SUBCLASS</a>. E.g. using <span class="tt">REGISTER_SUBCLASS_WITH_TYPENAME(ElectrodeTable, "core", "DynamicTable")</span>, the class will be registered in the registry, under the <span class="tt">core::ElectrodesTable</span> key, but with "DynamicTable" as the typename value and the <span class="tt">ElectrodesTable.getTypeName</span> automatic override returning the indicated typename instead of the classname. The main use cases for this are to implement:</p>
<ol type="1">
<li>Templated child classes of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> where the template parameters required in C++ are not part of the <span class="tt">neurodata_type</span> name in NWB. An example is <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> which uses a template parameter to define the data type of data that is manages.</li>
<li>A class for a modified type that does not have its own <span class="tt">neurodata_type</span> in the NWB schema. An example is <span class="tt">ElectrodesTable</span> in NWB &lt;v2.7, which did not have an assigned <span class="tt">neurodata_type</span>, but was implemented as a regular <span class="tt">DynamicTable</span>. To allow us to define a class <span class="tt">ElectrodeTable</span> to help with writing the table we can then use <span class="tt">REGISTER_SUBCLASS_WITH_TYPENAME(ElectrodeTable, "core", "DynamicTable")</span> in the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrode_table.html">ElectrodeTable</a> class. This ensures that the <span class="tt">neurodata_type</span> attribute is set correctly to <span class="tt">DynamicTable</span> on write instead of <span class="tt">ElectrodeTable</span>.</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="implement_templated_registered_type"></a>
Templated RegisteredType Classes</h2>
<p>In some cases, we may want to use templated classes to handle data types in a type-safe way. AqNWB uses templated neurodata_type classes for <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a> and <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data_typed.html">DataTyped&lt;DTYPE&gt;</a> as these classes manage a particular dataset. Using this approach, we specify the data types to use with the class directly as part of <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a> macro so that the user doesn't need to manually specify the data type for read. To implement the use of templated classes for read, we can take two main approaches by either <a class="el" href="#implement_templated_registered_type_two_class">Using a base class and templated child class</a> or <a class="el" href="#implement_templated_registered_type_single_class">Using a single templated class</a> .</p>
<h3 class="doxsection"><a class="anchor" id="implement_templated_registered_type_two_class"></a>
Using a base class and templated child class</h3>
<p>For the <span class="tt">VectorData</span> type (and <span class="tt">Data</span> type), AqNWB implements the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> class, which exposes the data as <span class="tt">std::any</span> via the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data.html#afe2d2e01b7ade2a1089e8cc051d7f49e">VectorData::readData</a> method for read. To simplify read, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a> inherits from <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> but allows the data type to be fixed at compile time via the class template, such that <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;::readData</a> can expose the data with the type already set at compile time.</p>
<p>Using this approach where we have a non-templated base class <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> with a templated child class <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a>, only the base type <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> is being registered with the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> registry via the <a class="el" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a> macro. This is because on read <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">RegisteredType::create</a> can only determine the base type based on the <span class="tt">namespace</span> and <span class="tt">neurodata_type</span> attribute stored in the file.</p>
<p>However, even though <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a> is not being added to the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> registry, it does inherit from <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> and as such, a user may chose to use <br  />
 <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a> anywhere <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> is being used. In particular, by using <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a> as part of the <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a> macro, we can set the data type for read at compile time, simplifying read.</p>
<dl class="section note"><dt>Note</dt><dd>The <span class="tt">std::unique_ptr&lt;..&gt;</span> template type is not covariant, i.e., <span class="tt">std::unique_ptr&lt;DerivedClass&gt;</span> does not automatically convert to <span class="tt">std::unique_ptr&lt;BaseClass&gt;</span>. I.e., while <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a> can be used anywhere <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> is being used, when using <span class="tt">std::unique_ptr&lt;..&gt;</span> we cannot rely on the compiler to automatically upcast for us, but we will need to explicitly release and upcast <span class="tt">std::unique_ptr&lt;VectorDataTyped&lt;DTYPE&gt;</span> if <span class="tt">std::unique_ptr&lt;VectorData&gt;</span> is required. Since defining the <span class="tt">DTYPE</span> is primarily useful for read, we therefore typically use <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a> on read while using <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> otherwise.</dd></dl>
<h3 class="doxsection"><a class="anchor" id="implement_templated_registered_type_single_class"></a>
Using a single templated class</h3>
<p>Alternatively to the above approach, where we have two classes <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> and <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a>, we could also just use a single templated class <span class="tt">VectorData&lt;DTYPE&gt;</span> and then register only the generic version <span class="tt">VectorData&lt;std::any&gt;</span> with the type registry via the <a class="el" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a> macro. However, there are a few additional considerations to keep in mind with this approach, which is why in AqNWB we generally recommend the above approach using two classes instead.</p>
<ol type="1">
<li><b>Preparing for Registration</b> <div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#af20769bbf87fb10f70c36fe248deaf4d">REGISTER_SUBCLASS_WITH_TYPENAME</a>(VectorData&lt;DTYPE&gt;, <span class="stringliteral">&quot;hdmf-common&quot;</span>, <span class="stringliteral">&quot;VectorData&quot;</span>)</div>
<div class="ttc" id="a_registered_type_8hpp_html_af20769bbf87fb10f70c36fe248deaf4d"><div class="ttname"><a href="_registered_type_8hpp.html#af20769bbf87fb10f70c36fe248deaf4d">REGISTER_SUBCLASS_WITH_TYPENAME</a></div><div class="ttdeci">#define REGISTER_SUBCLASS_WITH_TYPENAME(T, NAMESPACE_VAR, TYPENAME)</div><div class="ttdoc">Macro to register a subclass with the RegisteredType class registry.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:341</div></div>
</div><!-- fragment --> We use <span class="tt">VectorData&lt;DTYPE&gt;</span> with the template parameter because we want to prepare all possible instantiations (e.g., <span class="tt">VectorData&lt;int&gt;</span>, <span class="tt">VectorData&lt;double&gt;</span>, etc.) for registration</li>
<li><p class="startli"><b>Actual Registration</b> </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt; <a class="code hl_define" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a>(VectorData&lt;std::any&gt;)</div>
</div><!-- fragment --><p> This performs the actual registration in the type system. We only register the most generic type (<span class="tt">std::any</span>) because in the NWB file, we only store <span class="tt">namespace=hdmf-common</span> and <span class="tt">neurodata_type=VectorData</span> (i.e., the NWB file doesn't have the notion of templates) and the generic type serves as the default registration. Note, that we need to use <span class="tt">template&lt;&gt;</span> as this is a template specialization.</p>
<dl class="section note"><dt>Note</dt><dd>In C++ the implementation of templated classes is not easily separate into <span class="tt">.hpp</span> and <span class="tt">.cpp</span> files. However, the <span class="tt">template&lt;&gt; REGISTER_SUBCLASS_IMPL(VectorData&lt;std::any&gt;)</span> cannot be part of the <span class="tt">.hpp</span> file where the class is being defined. Also, the compiler will only include the call if the <span class="tt">VectorData&lt;std::any&gt;</span> is actually being instantiated. A simple instantiation of <span class="tt">template class VectorData&lt;std::any&gt;;</span> in the <span class="tt"><a class="el" href="_vector_data_8cpp.html">VectorData.cpp</a></span> may not be sufficient for this. As a work-around, the <span class="tt">template&lt;&gt; REGISTER_SUBCLASS_IMPL(VectorData&lt;std::any&gt;)</span> may need to be placed in a different <span class="tt">.cpp</span> file that we know is going to be built (the need for this workaround is one reason why we recommend the two-class approach in AqNWB). <br  />
</dd></dl>
</li>
<li><b>Template Instantiation</b> In <span class="tt"><a class="el" href="_vector_data_8cpp.html">VectorData.cpp</a></span>: <div class="fragment"><div class="line"><span class="keyword">template</span> <span class="keyword">class </span>VectorData&lt;std::any&gt;;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>VectorData&lt;uint8_t&gt;;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>VectorData&lt;int16_t&gt;;</div>
<div class="line"><span class="comment">// ... other types ...</span></div>
</div><!-- fragment --> This is an optimization that pre-instantiates all the types we expect to use and makes these instantiations part of the AqNWB library. This allows users to use these types directly and prevents the compiler from having to generate these as part of the user's code build.</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="limitations_registered_subclass_with_typename"></a>
Limitations of REGISTER_SUBCLASS_WITH_TYPENAME</h2>
<p>The main limitaton of the <a class="el" href="_registered_type_8hpp.html#af20769bbf87fb10f70c36fe248deaf4d">REGISTER_SUBCLASS_WITH_TYPENAME</a> approach is that on read, AqNWB will use the default class associated with the <span class="tt">neurodata_type</span>. E.g., in the case of the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrode_table.html">ElectrodeTable</a> class, by default the regular <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_dynamic_table.html">DynamicTable</a> class will be used since that is what the schema is indicating to use. Similarly, for <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> the default <span class="tt">VectorData&lt;std::any&gt;</span> will be used on read. To support reading using the more specific types, we can use the <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a> macro to define read methods that will return the approbriate type, e.g.:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a>(readElectrodeTable,</div>
<div class="line">                        ElectrodeTable,</div>
<div class="line">                        ElectrodeTable::electrodeTablePath,</div>
<div class="line">                        <span class="stringliteral">&quot;table with the extracellular electrodes&quot;</span>)</div>
</div><!-- fragment --><p>in <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html">NWBFile</a> to read the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrode_table.html">ElectrodeTable</a>, or</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a>(</div>
<div class="line">    readGroupNameColumn,</div>
<div class="line">    VectorData&lt;std::string&gt;,</div>
<div class="line">    <span class="stringliteral">&quot;group_name&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;the name of the ElectrodeGroup this electrode is a part of&quot;</span>)</div>
</div><!-- fragment --><p>in the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrode_table.html">ElectrodeTable</a> to read the <span class="tt">group_name</span> column as <span class="tt">VectorData&lt;std::string&gt;</span> with the data type already specified as <span class="tt">std::string</span> at compile time.</p>
<h1 class="doxsection"><a class="anchor" id="implement_registered_type_unit_tests"></a>
Testing RegisteredTypes</h1>
<p>As with all code, it is good practice to create appropriate unit tests to validate that our new class is functioning correctly. In the case of subclasses of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> we should pay attention to:</p>
<ul>
<li>Test that the registration is being executed correctly and the type has been registered with the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> type registry, e.g. via: <div class="fragment"><div class="line">  SECTION(<span class="stringliteral">&quot;test VectorData is registered as a subclass of RegisteredType&quot;</span>)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">auto</span> registry = <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#ab7e3361637885fe601cc20cb342bf01c">AQNWB::NWB::RegisteredType::getRegistry</a>();</div>
<div class="line">    <span class="comment">// check that hdfm-common::VectorData is in the registry</span></div>
<div class="line">    REQUIRE(registry.find(<span class="stringliteral">&quot;hdmf-common::VectorData&quot;</span>) != registry.end());</div>
<div class="line">  }</div>
</div><!-- fragment --></li>
<li>Test that <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">RegisteredType::create</a> works as expected for reading our new type, e.g. via: <div class="fragment"><div class="line">    <span class="keyword">auto</span> readDataUntyped = <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">NWB::RegisteredType::create</a>(dataPath, io);</div>
<div class="line">    <span class="keyword">auto</span> readVectorData =</div>
<div class="line">        std::dynamic_pointer_cast&lt;NWB::VectorData&gt;(readDataUntyped);</div>
<div class="line">    REQUIRE(readVectorData != <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --></li>
<li>Test that every read method created via the <a class="el" href="_registered_type_8hpp.html#acd3c876a1c357333cd4a8ff27300ee08">DEFINE_FIELD</a> and <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a> macros is working as expected, e.g. via: <div class="fragment"><div class="line">    <span class="comment">// Read the &quot;namespace&quot; attribute via the readNamespace field</span></div>
<div class="line">    <span class="keyword">auto</span> namespaceData = readVectorData-&gt;readNamespace();</div>
<div class="line">    std::string namespaceStr = namespaceData-&gt;values().data[0];</div>
<div class="line">    REQUIRE(namespaceStr == <span class="stringliteral">&quot;hdmf-common&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Read the &quot;neurodata_type&quot; attribute via the readNeurodataType field</span></div>
<div class="line">    <span class="keyword">auto</span> neurodataTypeData = readVectorData-&gt;readNeurodataType();</div>
<div class="line">    std::string neurodataTypeStr = neurodataTypeData-&gt;values().data[0];</div>
<div class="line">    REQUIRE(neurodataTypeStr == <span class="stringliteral">&quot;VectorData&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Read the &quot;description&quot; attribute via the readDescription field</span></div>
<div class="line">    <span class="keyword">auto</span> descriptionData = readVectorData-&gt;readDescription();</div>
<div class="line">    std::string descriptionStr = descriptionData-&gt;values().data[0];</div>
<div class="line">    REQUIRE(descriptionStr == description);</div>
</div><!-- fragment --></li>
<li>Test that the <span class="tt">initialize</span> method is working as expected (if included). </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="devdocs.html">For Developers</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
