<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>aqnwb: Implementing a Registered Type ðŸ”§</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom-modern.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="aqnwb-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">aqnwb<span id="projectnumber">&#160;0.2.0</span>
   </div>
  </td>
 </tr>
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td></tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('registered_type_page.html','',''); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
</script>
<div id="main-nav"></div>
<div id="container"><div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Implementing a Registered Type ðŸ”§ </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>New neurodata_types typically inherit from at least either <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html" title="AQNWB::NWB::Container">Container</a> or <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data.html" title="AQNWB::NWB::Data">Data</a>, or a more specialized type of the two. In any case, all classes that represent a <span class="tt">neurodata_type</span> defined in the schema should be implemented as a subtype of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="AQNWB::NWB::RegisteredType">RegisteredType</a>. Here we focus on how to implement new subclasses of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="AQNWB::NWB::RegisteredType">RegisteredType</a>. If you want to learn more about the how <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="AQNWB::NWB::RegisteredType">RegisteredType</a> manages types and implements data read then please see <a class="el" href="read_design_page.html" title="Implementation of Data Read ðŸ“¤">Implementation of Data Read ðŸ“¤</a>.</p>
<h1 class="doxsection"><a class="anchor" id="implement_registered_type"></a>
How to Implement a RegisteredType</h1>
<p>To implement a subclass of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="AQNWB::NWB::RegisteredType">RegisteredType</a>, follow the steps below. Understanding these steps is important. <a class="el" href="#using_schematype_to_aqnwb" title="Using the generate-types command">Using the generate-types command</a> then provides additional help by helping you generate skeleton C++ classes automatically from the JSON/YAML schema and based on the steps outlined here.</p>
<ol type="1">
<li>Include the <span class="tt"><a class="el" href="_registered_type_8hpp.html">RegisteredType.hpp</a></span> header file in your subclass header file (or the header of your more specific parent class that inherits from <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="AQNWB::NWB::RegisteredType">RegisteredType</a>). <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_registered_type_8hpp.html">nwb/RegisteredType.hpp</a>&quot;</span></div>
<div class="ttc" id="a_registered_type_8hpp_html"><div class="ttname"><a href="_registered_type_8hpp.html">RegisteredType.hpp</a></div></div>
</div><!-- fragment --> Also include the schema header file with the definition of the namespace schema. E.g., in the case of a type from the NWB core schema: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="core_8hpp.html">spec/core.hpp</a>&quot;</span></div>
<div class="ttc" id="acore_8hpp_html"><div class="ttname"><a href="core_8hpp.html">core.hpp</a></div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><br  />
 If the neurodata_type you wish to integrate is not part of the NWB or HDMF namespaces that ship with AqNWB, and you have not yet integrated your extension namespace, then see <a class="el" href="integrating_extensions_page.html" title="Integrating NWB Extensions ðŸ§©">Integrating NWB Extensions ðŸ§©</a> for details on how to create your schema header file(s) to integrate your extension namespace with AqNWB first. <br  />
</dd></dl>
</li>
<li>Define your subclass by inheriting from <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="AQNWB::NWB::RegisteredType">RegisteredType</a> (or one of its child classes). Ensure that your subclass implements a protected constructor with the arguments <span class="tt">(const std::string&amp; path, std::shared_ptr&lt;IO::BaseIO&gt; io)</span>, as the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a" title="AQNWB::NWB::RegisteredType::create">RegisteredType::create</a> method expects this constructor signature. The constructor must be <span class="tt">protected</span> to ensure proper management as <span class="tt">std:smart_ptr</span> and enforce use of the <span class="tt">create</span> factory to construct new objects. <div class="fragment"><div class="line"><span class="keyword">class </span>MySubClass : <span class="keyword">public</span> <a class="code hl_class" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">AQNWB::NWB::RegisteredType</a> {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    MySubClass(<span class="keyword">const</span> std::string&amp; path, std::shared_ptr&lt;IO::BaseIO&gt; io)</div>
<div class="line">        : RegisteredType(path, io) {}</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Implement any additional methods or overrides here</span></div>
<div class="line">};</div>
<div class="ttc" id="aclass_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_html"><div class="ttname"><a href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">AQNWB::NWB::RegisteredType</a></div><div class="ttdoc">Base class for types defined in the NWB schema.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:48</div></div>
</div><!-- fragment --></li>
<li>Use the <a class="el" href="_registered_type_8hpp.html#a48542bb43b1d1c733f729eb3f123c9dd" title="REGISTER_SUBCLASS">REGISTER_SUBCLASS</a> macro to prepare your subclass for registration with the class registry defined by <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="AQNWB::NWB::RegisteredType">RegisteredType</a>. This should usually appear in the header (<span class="tt">hpp</span>) file as part of the class definition: <div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#a48542bb43b1d1c733f729eb3f123c9dd">REGISTER_SUBCLASS</a>(MySubClass, BaseClass, <a class="code hl_variable" href="namespace_a_q_n_w_b_1_1_s_p_e_c_1_1_c_o_r_e.html#a1aeb5d31d5889e9b9b104dcaef2bb323">AQNWB::SPEC::CORE::namespaceName</a>)</div>
<div class="ttc" id="a_registered_type_8hpp_html_a48542bb43b1d1c733f729eb3f123c9dd"><div class="ttname"><a href="_registered_type_8hpp.html#a48542bb43b1d1c733f729eb3f123c9dd">REGISTER_SUBCLASS</a></div><div class="ttdeci">#define REGISTER_SUBCLASS(T, BASE, NAMESPACE)</div><div class="ttdoc">Macro to register a subclass with the RegisteredType class registry.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:501</div></div>
<div class="ttc" id="anamespace_a_q_n_w_b_1_1_s_p_e_c_1_1_c_o_r_e_html_a1aeb5d31d5889e9b9b104dcaef2bb323"><div class="ttname"><a href="namespace_a_q_n_w_b_1_1_s_p_e_c_1_1_c_o_r_e.html#a1aeb5d31d5889e9b9b104dcaef2bb323">AQNWB::SPEC::CORE::namespaceName</a></div><div class="ttdeci">const std::string namespaceName</div><div class="ttdef"><b>Definition</b> core.hpp:21</div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Using the <a class="el" href="namespace_a_q_n_w_b_1_1_s_p_e_c_1_1_c_o_r_e.html#a1aeb5d31d5889e9b9b104dcaef2bb323" title="AQNWB::SPEC::CORE::namespaceName">namespaceName</a> variable to define the name of our namespace has two main advantages: 1) it ensure that the namespace name is consistent, and 2) it ensures that we include the schema header file which ensures that that the schema is registered with the <a class="el" href="class_a_q_n_w_b_1_1_s_p_e_c_1_1_namespace_registry.html" title="AQNWB::SPEC::NamespaceRegistry">NamespaceRegistry</a> and cached in the file by <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html#a5fe5d0aba7a050db86d5caa5b8cf4a04" title="AQNWB::NWB::NWBFile::initialize">NWBFile::initialize</a> when creating a new NWB file.</dd></dl>
</li>
<li>In the corresponding source (<span class="tt">cpp</span>) file, initialize the static member to trigger the registration using the <a class="el" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e" title="REGISTER_SUBCLASS_IMPL">REGISTER_SUBCLASS_IMPL</a> macro: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;MySubClass.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize the static member to trigger registration</span></div>
<div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a>(MySubClass)</div>
<div class="ttc" id="a_registered_type_8hpp_html_a54ea7671d2bcf5bae392b8ba1824961e"><div class="ttname"><a href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a></div><div class="ttdeci">#define REGISTER_SUBCLASS_IMPL(T)</div><div class="ttdoc">Macro to initialize the static member registered_ to trigger registration.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:513</div></div>
</div><!-- fragment --></li>
<li>To define getter methods for lazy read access to datasets and attributes that belong to our type, we can use the <a class="el" href="_registered_type_8hpp.html#a9f1005a8dc218dba0592fe5d5aaedb0c" title="DEFINE_ATTRIBUTE_FIELD">DEFINE_ATTRIBUTE_FIELD</a> or <a class="el" href="_registered_type_8hpp.html#aeb21020579ca18f10e64fac9689a7ef6" title="DEFINE_DATASET_FIELD">DEFINE_DATASET_FIELD</a> macros. These macros create standard methods for retrieving a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html" title="AQNWB::IO::ReadDataWrapper">ReadDataWrapper</a> for lazy reading for the field: <div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#a9f1005a8dc218dba0592fe5d5aaedb0c">DEFINE_ATTRIBUTE_FIELD</a>(getDescription, std::string, <span class="stringliteral">&quot;description&quot;</span>, Description of the data)</div>
<div class="ttc" id="a_registered_type_8hpp_html_a9f1005a8dc218dba0592fe5d5aaedb0c"><div class="ttname"><a href="_registered_type_8hpp.html#a9f1005a8dc218dba0592fe5d5aaedb0c">DEFINE_ATTRIBUTE_FIELD</a></div><div class="ttdeci">#define DEFINE_ATTRIBUTE_FIELD(name, default_type, fieldPath, description)</div><div class="ttdoc">Defines a lazy-loaded attribute field accessor function.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:534</div></div>
</div><!-- fragment --> and in for datasets also a method for retrieving a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_recording_data.html" title="AQNWB::IO::BaseRecordingData">BaseRecordingData</a> wrapper used for recording data to a dataset. <div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#aeb21020579ca18f10e64fac9689a7ef6">DEFINE_DATASET_FIELD</a>(getData, recordData, <span class="keywordtype">float</span>, <span class="stringliteral">&quot;data&quot;</span>, The main data)</div>
<div class="ttc" id="a_registered_type_8hpp_html_aeb21020579ca18f10e64fac9689a7ef6"><div class="ttname"><a href="_registered_type_8hpp.html#aeb21020579ca18f10e64fac9689a7ef6">DEFINE_DATASET_FIELD</a></div><div class="ttdeci">#define DEFINE_DATASET_FIELD(readName, writeName, default_type, fieldPath, description)</div><div class="ttdoc">Defines a lazy-loaded dataset field accessor function.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:573</div></div>
</div><!-- fragment --></li>
<li>Similarly, we use the <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a" title="DEFINE_REGISTERED_FIELD">DEFINE_REGISTERED_FIELD</a> or <a class="el" href="_registered_type_8hpp.html#aee89c439c94a4a8aa1f42024d063e4c0" title="DEFINE_UNNAMED_REGISTERED_FIELD">DEFINE_UNNAMED_REGISTERED_FIELD</a> macro to define getter methods for other <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="AQNWB::NWB::RegisteredType">RegisteredType</a> objects that we own, such as a <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrodes_table.html" title="AQNWB::NWB::ElectrodesTable">ElectrodesTable</a> that owns predefined <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html" title="AQNWB::NWB::VectorData">VectorData</a> columns: <div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a>(readGroupNameColumn, VectorData&lt;std::string&gt;, <span class="stringliteral">&quot;group_name&quot;</span>, <span class="stringliteral">&quot;the name of the ElectrodeGroup&quot;</span>)</div>
<div class="ttc" id="a_registered_type_8hpp_html_af374245a4f6d5a00540e9fdba52a652a"><div class="ttname"><a href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a></div><div class="ttdeci">#define DEFINE_REGISTERED_FIELD(name, registeredType, fieldPath, description)</div><div class="ttdoc">Defines a lazy-loaded accessor function for reading fields that are RegisteredTypes.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:638</div></div>
</div><!-- fragment --></li>
<li>When inheriting from the more specific <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html" title="AQNWB::NWB::Container">Container</a> or <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data.html" title="AQNWB::NWB::Data">Data</a> types, then we will typically also need to implement an <span class="tt">initialize</span> method, which is responsible for creating the relevant Groups, Datasets, and Attributes in the file for data write. Remember to also call the <span class="tt">initialize</span> method of the parent class.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="_registered_type_8hpp.html#a9f1005a8dc218dba0592fe5d5aaedb0c" title="DEFINE_ATTRIBUTE_FIELD">DEFINE_ATTRIBUTE_FIELD</a>, <a class="el" href="_registered_type_8hpp.html#aeb21020579ca18f10e64fac9689a7ef6" title="DEFINE_DATASET_FIELD">DEFINE_DATASET_FIELD</a>, <a class="el" href="_registered_type_8hpp.html#aee89c439c94a4a8aa1f42024d063e4c0" title="DEFINE_UNNAMED_REGISTERED_FIELD">DEFINE_UNNAMED_REGISTERED_FIELD</a> <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a" title="DEFINE_REGISTERED_FIELD">DEFINE_REGISTERED_FIELD</a> create templated, non-virtual read functions. This means if we want to "redefine" a field in a child class by calling one of these macros again, then the function will be "hidden" instead of "override". This is important to remember when casting a pointer to a base type, as in this case the implementation from the base type will be used since the functions created by these macros are not virtual.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="implement_registered_type_example"></a>
Example: Implementing a New Type</h2>
<p><em>MySubClass.hpp</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_registered_type_8hpp.html">RegisteredType.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;spec/my_namespace.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MySubClass : <span class="keyword">public</span> <a class="code hl_class" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">AQNWB::NWB::RegisteredType</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    MySubClass(<span class="keyword">const</span> std::string&amp; path, std::shared_ptr&lt;IO::BaseIO&gt; io)</div>
<div class="line">        : RegisteredType(path, io) {}</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_define" href="_registered_type_8hpp.html#aeb21020579ca18f10e64fac9689a7ef6">DEFINE_DATASET_FIELD</a>(getData, recordData, <span class="keywordtype">float</span>, <span class="stringliteral">&quot;data&quot;</span>, The main data)</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="_registered_type_8hpp.html#a48542bb43b1d1c733f729eb3f123c9dd">REGISTER_SUBCLASS</a>(MySubClass, RegisteredType, AQNWB::SPEC::MYNAMESPACE::namespaceName)</div>
<div class="line">};</div>
</div><!-- fragment --><p><em>MySubClass.cpp</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;MySubClass.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize the static member to trigger registration</span></div>
<div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a>(MySubClass)</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>To ensure proper function on read, the name of the class should match the name of the <span class="tt">neurodata_type</span> as defined in the schema. Similarly, "my-namespace" should match the name of the namespace in the schema (e.g., "core", "hdmf-common"). In this way we can look up the corresponding class for an object in a file based on the <span class="tt">neurodata_type</span> and <span class="tt">namespace</span> attributes stored in the file. A special version of the <span class="tt"><a class="el" href="_registered_type_8hpp.html#a48542bb43b1d1c733f729eb3f123c9dd" title="Macro to register a subclass with the RegisteredType class registry.">REGISTER_SUBCLASS</a></span> macro, called <span class="tt"><a class="el" href="_registered_type_8hpp.html#a9401c336dd314b808058449cf8567033" title="Macro to register a subclass with the RegisteredType class registry.">REGISTER_SUBCLASS_WITH_TYPENAME</a></span>, allows setting the typename explicitly as a third argument. This is for the <b>special case</b> where the name of the class cannot be the same as the name of the type (e.g,. when implementing a class that doesn't have an assigned type in the schema or a class that requires template parameters that are not part of the type name). See <a class="el" href="#using_registered_subclass_with_typename" title="How to implement a RegisteredType with a custom type name">How to implement a RegisteredType with a custom type name</a> for details.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="use_the_define_attribute_field_macro"></a>
DEFINE_ATTRIBUTE_FIELD: Creating read methods for attributes</h2>
<p>The <a class="el" href="_registered_type_8hpp.html#a9f1005a8dc218dba0592fe5d5aaedb0c" title="DEFINE_ATTRIBUTE_FIELD">DEFINE_ATTRIBUTE_FIELD</a> macro takes the following main inputs:</p>
<ul>
<li><span class="tt">name</span>: The name of the function to generate.</li>
<li><span class="tt">default_type</span> : The default data type to use. If not known, we can use <span class="tt">std::any</span>.</li>
<li><span class="tt">fieldPath</span> : Literal string with the relative path to the field within the schema of the respective neurodata_type. This is automatically being expanded at runtime to the full path.</li>
<li><span class="tt">description</span> : Description of the field to include in the docstring for the docs</li>
</ul>
<p>All of these inputs are required. A typical example will look as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#a9f1005a8dc218dba0592fe5d5aaedb0c">DEFINE_ATTRIBUTE_FIELD</a>(getDescription, std::string, <span class="stringliteral">&quot;description&quot;</span>, Description of the data)</div>
</div><!-- fragment --><p>The compiler will then expand this definition to create a new method (here called <span class="tt">getDescription</span>) that will return a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html" title="AQNWB::IO::ReadDataWrapper">ReadDataWrapper</a> for lazy reading for the field. The corresponding expanded function will look something like:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VTYPE = std::<span class="keywordtype">string</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> std::unique_ptr&lt;IO::ReadDataWrapper&lt;AttributeField, VTYPE&gt;&gt; getDescription()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unique&lt;IO::ReadDataWrapper&lt;AttributeField, VTYPE&gt;&gt;(</div>
<div class="line">         m_io,</div>
<div class="line">         <a class="code hl_function" href="namespace_a_q_n_w_b.html#a31983dbaaa85c2e355b9687fc0ef1881">AQNWB::mergePaths</a>(m_path, fieldPath));</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_a_q_n_w_b_html_a31983dbaaa85c2e355b9687fc0ef1881"><div class="ttname"><a href="namespace_a_q_n_w_b.html#a31983dbaaa85c2e355b9687fc0ef1881">AQNWB::mergePaths</a></div><div class="ttdeci">static std::string mergePaths(const std::string &amp;path1, const std::string &amp;path2)</div><div class="ttdoc">Merge two paths into a single path, handling extra trailing and starting &quot;/&quot;.</div><div class="ttdef"><b>Definition</b> Utils.hpp:225</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="use_the_define_dataset_field_macro"></a>
DEFINE_DATASET_FIELD: Creating read and write methods for datasets</h2>
<p>The <a class="el" href="_registered_type_8hpp.html#aeb21020579ca18f10e64fac9689a7ef6" title="DEFINE_DATASET_FIELD">DEFINE_DATASET_FIELD</a> macro takes the following main inputs:</p>
<ul>
<li><span class="tt">readName</span>: The name of the read function to generate.</li>
<li><span class="tt">writeName</span>: The name of the write function to generate.</li>
<li><span class="tt">default_type</span> : The default data type to use. If not known, we can use <span class="tt">std::any</span>.</li>
<li><span class="tt">fieldPath</span> : Literal string with the relative path to the field within the schema of the respective neurodata_type. This is automatically being expanded at runtime to the full path.</li>
<li><span class="tt">description</span> : Description of the field to include in the docstring for the docs</li>
</ul>
<p>All of these inputs are required. A typical example will look as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#aeb21020579ca18f10e64fac9689a7ef6">DEFINE_DATASET_FIELD</a>(getData, recordData, <span class="keywordtype">float</span>, <span class="stringliteral">&quot;data&quot;</span>, The main data)</div>
</div><!-- fragment --><p>The compiler will then expand this definition to create a new method (here called <span class="tt">getData</span>) that will return a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html" title="AQNWB::IO::ReadDataWrapper">ReadDataWrapper</a> for lazy reading for the field. The corresponding expanded function will look something like:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VTYPE = <span class="keywordtype">float</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> std::unique_ptr&lt;IO::ReadDataWrapper&lt;DatasetField, VTYPE&gt;&gt; getData()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unique&lt;IO::ReadDataWrapper&lt;DatasetField, VTYPE&gt;&gt;(</div>
<div class="line">         m_io,</div>
<div class="line">         <a class="code hl_function" href="namespace_a_q_n_w_b.html#a31983dbaaa85c2e355b9687fc0ef1881">AQNWB::mergePaths</a>(m_path, fieldPath));</div>
<div class="line">}</div>
</div><!-- fragment --><p>See <a class="el" href="read_page.html" title="Reading Data ðŸ“¤">Reading Data ðŸ“¤</a> for an example of how to use such methods (e.g., <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_time_series.html#a185cdbb22cb299862e950576a6c9ecab" title="AQNWB::NWB::TimeSeries::readData">TimeSeries::readData</a> ) for reading data fields from a file.</p>
<h2 class="doxsection"><a class="anchor" id="use_the_define_registered_field_macro"></a>
DEFINE_REGISTERED_FIELD: Defining read methods for neurodata_type objects</h2>
<p>The <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a" title="DEFINE_REGISTERED_FIELD">DEFINE_REGISTERED_FIELD</a> macro works much like the <a class="el" href="_registered_type_8hpp.html#a9f1005a8dc218dba0592fe5d5aaedb0c" title="DEFINE_ATTRIBUTE_FIELD">DEFINE_ATTRIBUTE_FIELD</a> and <a class="el" href="_registered_type_8hpp.html#aeb21020579ca18f10e64fac9689a7ef6" title="DEFINE_DATASET_FIELD">DEFINE_DATASET_FIELD</a> macros but returns instances of specific subtypes of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="AQNWB::NWB::RegisteredType">RegisteredType</a>, rather than <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html" title="AQNWB::IO::ReadDataWrapper">ReadDataWrapper</a>. As such the main inputs for <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a" title="DEFINE_REGISTERED_FIELD">DEFINE_REGISTERED_FIELD</a> are as follows:</p>
<ul>
<li><span class="tt">name</span>: The name of the function to generate.</li>
<li><span class="tt">registeredType</span> : The specific subclass of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="AQNWB::NWB::RegisteredType">RegisteredType</a> to use</li>
<li><span class="tt">fieldPath</span> : Literal string with the relative path to the field within the schema of the respective neurodata_type. This is automatically being expanded at runtime to the full path.</li>
<li><span class="tt">description</span> : Description of the field to include in the docstring for the docs</li>
</ul>
<p>All of these inputs are required. A typical example will look as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a>(getMyTable, DynamicTable, <span class="stringliteral">&quot;my_table&quot;</span>, My data table)</div>
</div><!-- fragment --><p>The compiler will then expand this definition to create a new read method, in this called <span class="tt">getMyTable</span> that returns a <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_dynamic_table.html" title="AQNWB::NWB::DynamicTable">DynamicTable</a> for reading "my_table". The corresponding expanded function will look something like:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RTYPE = DynamicTable&gt; </div>
<div class="line"><span class="keyword">inline</span> std::shared_ptr&lt;RTYPE&gt; getMyTable()<span class="keyword"> const </span></div>
<div class="line"><span class="keyword"></span>{ </div>
<div class="line">  std::string objectPath = <a class="code hl_function" href="namespace_a_q_n_w_b.html#a31983dbaaa85c2e355b9687fc0ef1881">AQNWB::mergePaths</a>(m_path, fieldPath); </div>
<div class="line">  <span class="keywordflow">if</span> (m_io-&gt;objectExists(objectPath)) { </div>
<div class="line">    <span class="keywordflow">return</span> RegisteredType::create&lt;RTYPE&gt;(objectPath, m_io); </div>
<div class="line">  } </div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">nullptr</span>; </div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="use_the_define_unnamed_registered_field_macro"></a>
DEFINE_UNNAMED_REGISTERED_FIELD: Defining read methods for unnamed neurodata_type objects</h2>
<p>The <a class="el" href="_registered_type_8hpp.html#aee89c439c94a4a8aa1f42024d063e4c0" title="DEFINE_UNNAMED_REGISTERED_FIELD">DEFINE_UNNAMED_REGISTERED_FIELD</a> macro works much like the <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a" title="DEFINE_REGISTERED_FIELD">DEFINE_REGISTERED_FIELD</a> macro but is used for neurodata_types that do not have a fixed name in the schema (which are typically also either optional and/or allow for multiple instances, e.g., <span class="tt">VectorData</span> columns in a <span class="tt">DynamicTable</span>). The main inputs for <a class="el" href="_registered_type_8hpp.html#aee89c439c94a4a8aa1f42024d063e4c0" title="DEFINE_UNNAMED_REGISTERED_FIELD">DEFINE_UNNAMED_REGISTERED_FIELD</a> are as follows:</p>
<ul>
<li><span class="tt">readName</span>: The name of the function to generate for reading an existing object.</li>
<li><span class="tt">writeName</span>: The name of the functoin to generate for creating a new instance for writing a new object.</li>
<li><span class="tt">registeredType</span> : The specific subclass of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="AQNWB::NWB::RegisteredType">RegisteredType</a> to use</li>
<li><span class="tt">fieldPrefixPath</span> : Literal string with the relative path to the group where the field appears within the schema of the respective neurodata_type. This is automatically being expanded at runtime to the full path. E.g.,</li>
<li><span class="tt">description</span> : Description of the field to include in the docstring for the docs</li>
</ul>
<p>All of these inputs are required. A typical example will look as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a>(readAquisitionSeries, </div>
<div class="line">                        createAquisitionSeries,</div>
<div class="line">                        TimeSeries, </div>
<div class="line">                        <span class="stringliteral">&quot;acquisition&quot;</span>, </div>
<div class="line">                        Get a TimeSeries stored in the acquisition group</div>
</div><!-- fragment --><p>The compiler will then expand this definition to create two methods. The first method (here called <span class="tt">readAcquisitionSeries</span>) is for reading existing <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_time_series.html" title="AQNWB::NWB::TimeSeries">TimeSeries</a> from the <span class="tt">/acquisistion</span> group. The corresponding expanded function will look something like:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RTYPE = TimeSeries&gt; </div>
<div class="line"><span class="keyword">inline</span> std::shared_ptr&lt;RTYPE&gt; readAquisitionSeries(<span class="keyword">const</span> std::string&amp; objectName)<span class="keyword"> const </span></div>
<div class="line"><span class="keyword"></span>{ </div>
<div class="line">  std::string prefixPath = <a class="code hl_function" href="namespace_a_q_n_w_b.html#a31983dbaaa85c2e355b9687fc0ef1881">AQNWB::mergePaths</a>(m_path, fieldPrefixPath); </div>
<div class="line">  std::string objectPath = <a class="code hl_function" href="namespace_a_q_n_w_b.html#a31983dbaaa85c2e355b9687fc0ef1881">AQNWB::mergePaths</a>(prefixPath, objectName); </div>
<div class="line">  <span class="keywordflow">if</span> (m_io-&gt;objectExists(objectPath) || createNew) { </div>
<div class="line">    <span class="keywordflow">return</span> RegisteredType::create&lt;RTYPE&gt;(objectPath, m_io); </div>
<div class="line">  } </div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">nullptr</span>; </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">The second function is <span class="keywordflow">for</span> creating <span class="keyword">new</span> instances of \ref <a class="code hl_class" href="class_a_q_n_w_b_1_1_n_w_b_1_1_time_series.html">AQNWB::NWB::TimeSeries</a> <span class="stringliteral">&quot;TimeSeries&quot;</span> that we can </div>
<div class="line">use <span class="keywordflow">for</span> creating <span class="keyword">new</span> objects or writing to the existing series. The expanded function will look like <span class="keyword">this</span>:</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RTYPE = TimeSeries&gt; </div>
<div class="line"><span class="keyword">inline</span> std::unique_ptr&lt;RTYPE&gt; createAquisitionSeries(<span class="keyword">const</span> std::string&amp; objectName)<span class="keyword"> const </span></div>
<div class="line"><span class="keyword"></span>{ </div>
<div class="line">  std::string prefixPath = <a class="code hl_function" href="namespace_a_q_n_w_b.html#a31983dbaaa85c2e355b9687fc0ef1881">AQNWB::mergePaths</a>(m_path, fieldPrefixPath); </div>
<div class="line">  std::string objectPath = <a class="code hl_function" href="namespace_a_q_n_w_b.html#a31983dbaaa85c2e355b9687fc0ef1881">AQNWB::mergePaths</a>(prefixPath, objectName); </div>
<div class="line">  <span class="keywordflow">return</span> std::make_unique&lt;RTYPE&gt;(objectPath, m_io); </div>
<div class="line">}</div>
<div class="ttc" id="aclass_a_q_n_w_b_1_1_n_w_b_1_1_time_series_html"><div class="ttname"><a href="class_a_q_n_w_b_1_1_n_w_b_1_1_time_series.html">AQNWB::NWB::TimeSeries</a></div><div class="ttdoc">General purpose time series.</div><div class="ttdef"><b>Definition</b> TimeSeries.hpp:19</div></div>
</div><!-- fragment --><p>Since the function is templated, we can use it to create any <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_time_series.html" title="AQNWB::NWB::TimeSeries">TimeSeries</a>, e.g., we can create an <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html" title="AQNWB::NWB::ElectricalSeries">ElectricalSeries</a> via: </p><div class="fragment"><div class="line">es = nwbfile.createAquisitionSeries&lt;<a class="code hl_class" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html">AQNWB::NWB::ElectricalSeries</a>&gt;(<span class="stringliteral">&quot;myElectricalSeries&quot;</span>);</div>
<div class="line">es-&gt;<a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html#a68535ea0fcb4a74c63eb04217ef91f66">initialize</a>(...)</div>
<div class="ttc" id="aclass_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series_html"><div class="ttname"><a href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html">AQNWB::NWB::ElectricalSeries</a></div><div class="ttdoc">General purpose time series.</div><div class="ttdef"><b>Definition</b> ElectricalSeries.hpp:19</div></div>
<div class="ttc" id="aclass_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series_html_a68535ea0fcb4a74c63eb04217ef91f66"><div class="ttname"><a href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrical_series.html#a68535ea0fcb4a74c63eb04217ef91f66">AQNWB::NWB::ElectricalSeries::initialize</a></div><div class="ttdeci">Status initialize(const IO::ArrayDataSetConfig &amp;dataConfig, const Types::ChannelVector &amp;channelVector, const std::string &amp;description, const float &amp;conversion=1.0f, const float &amp;resolution=-1.0f, const float &amp;offset=0.0f)</div><div class="ttdoc">Initializes the Electrical Series.</div><div class="ttdef"><b>Definition</b> ElectricalSeries.cpp:23</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="use_the_define_referenced_registered_field_macro"></a>
DEFINE_REFERENCED_REGISTERED_FIELD: Defining read methods for references to neurodata_type objects</h2>
<p>The <a class="el" href="_registered_type_8hpp.html#a3b2c847e459e9e30e65e38897303a9a5" title="DEFINE_REFERENCED_REGISTERED_FIELD">DEFINE_REFERENCED_REGISTERED_FIELD</a> macro works exactly like the <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a" title="DEFINE_REGISTERED_FIELD">DEFINE_REGISTERED_FIELD</a> macro, but the underlying data is an attribute that stores a reference to an instances of a specific subtype of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="AQNWB::NWB::RegisteredType">RegisteredType</a> rather than the instance of the object directly. I.e., <span class="tt">fieldPath</span> here is the relative path to the attribute that stores the reference, rather than the relative path of the object itself. The generated read method then resolves the reference first and then returns the instance of the object that is being referenced.</p>
<h1 class="doxsection"><a class="anchor" id="using_registered_subclass_with_typename"></a>
How to implement a RegisteredType with a custom type name</h1>
<p>In most cases, the name of our <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="AQNWB::NWB::RegisteredType">RegisteredType</a> class should be the same as the <span class="tt">neurodata_type</span>. However, in some cases this may not be possible. In this case, we need to use <a class="el" href="_registered_type_8hpp.html#a9401c336dd314b808058449cf8567033" title="REGISTER_SUBCLASS_WITH_TYPENAME">REGISTER_SUBCLASS_WITH_TYPENAME</a> macro instead of <a class="el" href="_registered_type_8hpp.html#a48542bb43b1d1c733f729eb3f123c9dd" title="REGISTER_SUBCLASS">REGISTER_SUBCLASS</a>. E.g. using <span class="tt"><a class="el" href="_registered_type_8hpp.html#a9401c336dd314b808058449cf8567033" title="Macro to register a subclass with the RegisteredType class registry.">REGISTER_SUBCLASS_WITH_TYPENAME</a>(ElectrodesTable, DynamicTable, "core", "DynamicTable")</span>, the class will be registered in the registry, under the <span class="tt">core::ElectrodesTable</span> key, but with "DynamicTable" as the typename value and the <span class="tt">ElectrodesTable.getTypeName</span> automatic override returning the indicated typename instead of the classname. The main use cases for this are to implement:</p>
<ol type="1">
<li>Templated child classes of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="AQNWB::NWB::RegisteredType">RegisteredType</a> where the template parameters required in C++ are not part of the <span class="tt">neurodata_type</span> name in NWB. An example is <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html" title="AQNWB::NWB::VectorData">VectorData</a> which uses a template parameter to define the data type of data that is manages.</li>
<li>A class for a modified type that does not have its own <span class="tt">neurodata_type</span> in the NWB schema. An example is <span class="tt">ElectrodesTable</span> in NWB &lt;v2.9, which did not have an assigned <span class="tt">neurodata_type</span>, but was implemented as a regular <span class="tt">DynamicTable</span>. To allow us to define a class <span class="tt">ElectrodesTable</span> to help with writing the table we can then use <span class="tt"><a class="el" href="_registered_type_8hpp.html#a9401c336dd314b808058449cf8567033" title="Macro to register a subclass with the RegisteredType class registry.">REGISTER_SUBCLASS_WITH_TYPENAME</a>(ElectrodesTable, DynamicTable, "core", "DynamicTable")</span> in the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrodes_table.html" title="AQNWB::NWB::ElectrodesTable">ElectrodesTable</a> class. This ensures that the <span class="tt">neurodata_type</span> attribute is set correctly to <span class="tt">DynamicTable</span> on write instead of <span class="tt">ElectrodesTable</span>.</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="implement_templated_registered_type"></a>
Templated RegisteredType Classes</h2>
<p>In some cases, we may want to use templated classes to handle data types in a type-safe way. AqNWB uses templated neurodata_type classes for <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html" title="AQNWB::NWB::VectorDataTyped">VectorDataTyped&lt;DTYPE&gt;</a> and <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data_typed.html" title="AQNWB::NWB::DataTyped">DataTyped&lt;DTYPE&gt;</a> as these classes manage a particular dataset. Using this approach, we specify the data types to use with the class directly as part of <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a" title="DEFINE_REGISTERED_FIELD">DEFINE_REGISTERED_FIELD</a> (or <a class="el" href="_registered_type_8hpp.html#aee89c439c94a4a8aa1f42024d063e4c0" title="DEFINE_UNNAMED_REGISTERED_FIELD">DEFINE_UNNAMED_REGISTERED_FIELD</a>) macro so that the user doesn't need to manually specify the data type for read. To implement the use of templated classes for read, we can take two main approaches by either <a class="el" href="#implement_templated_registered_type_two_class" title="Using a base class and templated child class">Using a base class and templated child class</a> or <a class="el" href="#implement_templated_registered_type_single_class" title="Using a single templated class">Using a single templated class</a> .</p>
<h3 class="doxsection"><a class="anchor" id="implement_templated_registered_type_two_class"></a>
Using a base class and templated child class</h3>
<p>For the <span class="tt">VectorData</span> type (and <span class="tt">Data</span> type), AqNWB implements the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html" title="AQNWB::NWB::VectorData">VectorData</a> class, which exposes the data as <span class="tt">std::any</span> via the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data.html#a7dad9d54ec248dda4cc9a168659382bf" title="AQNWB::NWB::VectorData::readData">VectorData::readData</a> method for read. To simplify read, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html" title="AQNWB::NWB::VectorDataTyped">VectorDataTyped&lt;DTYPE&gt;</a> inherits from <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html" title="AQNWB::NWB::VectorData">VectorData</a> but allows the data type to be fixed at compile time via the class template, such that <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html" title="AQNWB::NWB::VectorDataTyped">VectorDataTyped&lt;DTYPE&gt;::readData</a> can expose the data with the type already set at compile time.</p>
<p>Using this approach where we have a non-templated base class <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html" title="AQNWB::NWB::VectorData">VectorData</a> with a templated child class <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html" title="AQNWB::NWB::VectorDataTyped">VectorDataTyped&lt;DTYPE&gt;</a>, only the base type <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html" title="AQNWB::NWB::VectorData">VectorData</a> is being registered with the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="AQNWB::NWB::RegisteredType">RegisteredType</a> registry via the <a class="el" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e" title="REGISTER_SUBCLASS_IMPL">REGISTER_SUBCLASS_IMPL</a> macro. This is because on read <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a" title="AQNWB::NWB::RegisteredType::create">RegisteredType::create</a> can only determine the base type based on the <span class="tt">namespace</span> and <span class="tt">neurodata_type</span> attribute stored in the file.</p>
<p>However, even though <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html" title="AQNWB::NWB::VectorDataTyped">VectorDataTyped&lt;DTYPE&gt;</a> is not being added to the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="AQNWB::NWB::RegisteredType">RegisteredType</a> registry, it does inherit from <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html" title="AQNWB::NWB::VectorData">VectorData</a> and as such, a user may chose to use <br  />
 <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html" title="AQNWB::NWB::VectorDataTyped">VectorDataTyped&lt;DTYPE&gt;</a> anywhere <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html" title="AQNWB::NWB::VectorData">VectorData</a> is being used. In particular, by using <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html" title="AQNWB::NWB::VectorDataTyped">VectorDataTyped&lt;DTYPE&gt;</a> as part of the <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a" title="DEFINE_REGISTERED_FIELD">DEFINE_REGISTERED_FIELD</a> macro, we can set the data type for read at compile time, simplifying read.</p>
<dl class="section note"><dt>Note</dt><dd>Since the templacted <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html" title="AQNWB::NWB::VectorDataTyped">VectorDataTyped&lt;DTYPE&gt;</a> does not call <a class="el" href="_registered_type_8hpp.html#a48542bb43b1d1c733f729eb3f123c9dd" title="REGISTER_SUBCLASS">REGISTER_SUBCLASS</a> we must manually declare: 1) <span class="tt">friend class <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="Base class for types defined in the NWB schema.">AQNWB::NWB::RegisteredType</a>;</span> and 2) <span class="tt">using VectorData::VectorData;</span> (as protected) to make sure we have access to the constructors and define <span class="tt">static std::shared_ptr&lt;VectorDataTyped&gt; create( const std::string&amp; path, std::shared_ptr&lt;<a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_base_i_o.html" title="The BaseIO class is an abstract base class that defines the interface for input/output (IO) operation...">AQNWB::IO::BaseIO</a>&gt; io) {  return RegisteredType::create&lt;VectorDataTyped&gt;(path, io); }</span> to make sure we have the factory method available.</dd>
<dd>
The <span class="tt">std::unique_ptr&lt;..&gt;</span> template type is not covariant, i.e., <span class="tt">std::unique_ptr&lt;DerivedClass&gt;</span> does not automatically convert to <span class="tt">std::unique_ptr&lt;BaseClass&gt;</span>. I.e., while <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html" title="AQNWB::NWB::VectorDataTyped">VectorDataTyped&lt;DTYPE&gt;</a> can be used anywhere <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html" title="AQNWB::NWB::VectorData">VectorData</a> is being used, when using <span class="tt">std::unique_ptr&lt;..&gt;</span> we cannot rely on the compiler to automatically upcast for us, but we will need to explicitly release and upcast <span class="tt">std::unique_ptr&lt;VectorDataTyped&lt;DTYPE&gt;</span> if <span class="tt">std::unique_ptr&lt;VectorData&gt;</span> is required. Since defining the <span class="tt">DTYPE</span> is primarily useful for read, we therefore typically use <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html" title="AQNWB::NWB::VectorDataTyped">VectorDataTyped&lt;DTYPE&gt;</a> on read while using <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html" title="AQNWB::NWB::VectorData">VectorData</a> otherwise.</dd></dl>
<h3 class="doxsection"><a class="anchor" id="implement_templated_registered_type_single_class"></a>
Using a single templated class</h3>
<p>Alternatively to the above approach, where we have two classes <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html" title="AQNWB::NWB::VectorData">VectorData</a> and <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html" title="AQNWB::NWB::VectorDataTyped">VectorDataTyped&lt;DTYPE&gt;</a>, we could also just use a single templated class <span class="tt">VectorData&lt;DTYPE&gt;</span> and then register only the generic version <span class="tt">VectorData&lt;std::any&gt;</span> with the type registry via the <a class="el" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e" title="REGISTER_SUBCLASS_IMPL">REGISTER_SUBCLASS_IMPL</a> macro. However, there are a few additional considerations to keep in mind with this approach, which is why in AqNWB we generally recommend the above approach using two classes instead.</p>
<ol type="1">
<li><b>Preparing for Registration</b> <div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#a9401c336dd314b808058449cf8567033">REGISTER_SUBCLASS_WITH_TYPENAME</a>(VectorData&lt;DTYPE&gt;, Data&lt;DTYPE&gt;, <span class="stringliteral">&quot;hdmf-common&quot;</span>, <span class="stringliteral">&quot;VectorData&quot;</span>)</div>
<div class="ttc" id="a_registered_type_8hpp_html_a9401c336dd314b808058449cf8567033"><div class="ttname"><a href="_registered_type_8hpp.html#a9401c336dd314b808058449cf8567033">REGISTER_SUBCLASS_WITH_TYPENAME</a></div><div class="ttdeci">#define REGISTER_SUBCLASS_WITH_TYPENAME(T, BASE, NAMESPACE_VAR, TYPENAME)</div><div class="ttdoc">Macro to register a subclass with the RegisteredType class registry.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:458</div></div>
</div><!-- fragment --> We use <span class="tt">VectorData&lt;DTYPE&gt;</span> with the template parameter because we want to prepare all possible instantiations (e.g., <span class="tt">VectorData&lt;int&gt;</span>, <span class="tt">VectorData&lt;double&gt;</span>, etc.) for registration</li>
<li><p class="startli"><b>Actual Registration</b> </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt; <a class="code hl_define" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a>(VectorData&lt;std::any&gt;)</div>
</div><!-- fragment --><p> This performs the actual registration in the type system. We only register the most generic type (<span class="tt">std::any</span>) because in the NWB file, we only store <span class="tt">namespace=hdmf-common</span> and <span class="tt">neurodata_type=VectorData</span> (i.e., the NWB file doesn't have the notion of templates) and the generic type serves as the default registration. Note, that we need to use <span class="tt">template&lt;&gt;</span> as this is a template specialization.</p>
<dl class="section note"><dt>Note</dt><dd>In C++ the implementation of templated classes is not easily separate into <span class="tt">.hpp</span> and <span class="tt">.cpp</span> files. However, the <span class="tt">template&lt;&gt; <a class="el" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e" title="Macro to initialize the static member registered_ to trigger registration.">REGISTER_SUBCLASS_IMPL</a>(VectorData&lt;std::any&gt;)</span> cannot be part of the <span class="tt">.hpp</span> file where the class is being defined. Also, the compiler will only include the call if the <span class="tt">VectorData&lt;std::any&gt;</span> is actually being instantiated. A simple instantiation of <span class="tt">template class VectorData&lt;std::any&gt;;</span> in the <span class="tt"><a class="el" href="_vector_data_8cpp.html">VectorData.cpp</a></span> may not be sufficient for this. As a work-around, the <span class="tt">template&lt;&gt; <a class="el" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e" title="Macro to initialize the static member registered_ to trigger registration.">REGISTER_SUBCLASS_IMPL</a>(VectorData&lt;std::any&gt;)</span> may need to be placed in a different <span class="tt">.cpp</span> file that we know is going to be built (the need for this workaround is one reason why we recommend the two-class approach in AqNWB). <br  />
</dd></dl>
</li>
<li><b>Template Instantiation</b> In <span class="tt"><a class="el" href="_vector_data_8cpp.html">VectorData.cpp</a></span>: <div class="fragment"><div class="line"><span class="keyword">template</span> <span class="keyword">class </span>VectorData&lt;std::any&gt;;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>VectorData&lt;uint8_t&gt;;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>VectorData&lt;int16_t&gt;;</div>
<div class="line"><span class="comment">// ... other types ...</span></div>
</div><!-- fragment --> This is an optimization that pre-instantiates all the types we expect to use and makes these instantiations part of the AqNWB library. This allows users to use these types directly and prevents the compiler from having to generate these as part of the user's code build.</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="limitations_registered_subclass_with_typename"></a>
Limitations of REGISTER_SUBCLASS_WITH_TYPENAME</h2>
<p>The main limitaton of the <a class="el" href="_registered_type_8hpp.html#a9401c336dd314b808058449cf8567033" title="REGISTER_SUBCLASS_WITH_TYPENAME">REGISTER_SUBCLASS_WITH_TYPENAME</a> approach is that on read, AqNWB will use the default class associated with the <span class="tt">neurodata_type</span>. E.g., in the case of the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrodes_table.html" title="AQNWB::NWB::ElectrodesTable">ElectrodesTable</a> class, by default the regular <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_dynamic_table.html" title="AQNWB::NWB::DynamicTable">DynamicTable</a> class will be used since that is what the schema is indicating to use. Similarly, for <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html" title="AQNWB::NWB::VectorData">VectorData</a> the default <span class="tt">VectorData&lt;std::any&gt;</span> will be used on read. To support reading using the more specific types, we can use the <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a" title="DEFINE_REGISTERED_FIELD">DEFINE_REGISTERED_FIELD</a> macro to define read methods that will return the approbriate type, e.g.:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a>(readElectrodesTable,</div>
<div class="line">                        ElectrodesTable,</div>
<div class="line">                        ElectrodesTable::electrodesTablePath,</div>
<div class="line">                        <span class="stringliteral">&quot;table with the extracellular electrodes&quot;</span>)</div>
</div><!-- fragment --><p>in <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html" title="AQNWB::NWB::NWBFile">NWBFile</a> to read the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrodes_table.html" title="AQNWB::NWB::ElectrodesTable">ElectrodesTable</a>, or</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a>(</div>
<div class="line">    readGroupNameColumn,</div>
<div class="line">    VectorData&lt;std::string&gt;,</div>
<div class="line">    <span class="stringliteral">&quot;group_name&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;the name of the ElectrodeGroup this electrode is a part of&quot;</span>)</div>
</div><!-- fragment --><p>in the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrodes_table.html" title="AQNWB::NWB::ElectrodesTable">ElectrodesTable</a> to read the <span class="tt">group_name</span> column as <span class="tt">VectorData&lt;std::string&gt;</span> with the data type already specified as <span class="tt">std::string</span> at compile time.</p>
<h1 class="doxsection"><a class="anchor" id="using_schematype_to_aqnwb"></a>
Using the generate-types command</h1>
<p>The <span class="tt">generate-types</span> command, included in the <a href="https://github.com/NeurodataWithoutBorders/aqnwb">AqNWB source repository</a>, is a simple utility designed to create skeleton C++ source files for integrating new neurodata_types with AqNWB. While the generated source files are only an outline and are not guaranteed to compile, they serve as a helpful starting point. Look for <span class="tt">TODO</span> comments in the generated files, indicating items that need to be addressed. For example, if you clone the <a href="https://github.com/NeurodataWithoutBorders/nwb-schema/">nwb-schema repo</a>, then the following command will generate template code for AqNWB classes for all neurodata_types in the NWB schema:</p>
<div class="fragment"><div class="line">uv run resources/utils/aqnwb_utils.py generate-types nwb-schema/core/nwb.namespace.yaml test_output</div>
</div><!-- fragment --><p>The generated files will be placed in the folder hierarchy based on the name of the namespace and source yaml file where the type is defined. E.g, <span class="tt">TimeSeries</span> is defined in <span class="tt">nwb.base.yaml</span> in the <span class="tt">core</span> NWB namespace, and will be generated as <span class="tt">core/base/TimeSeries.hpp</span>.</p>
<p>We can also create a simple example app that instantiates all the generated classes to make it simplify testing that all the classes can be compiled. To generate the app, simply add the <span class="tt">--generate-test-app</span> option:</p>
<div class="fragment"><div class="line">uv run resources/utils/aqnwb_utils.py generate-types --generate-test-app nwb-schema/core/nwb.namespace.yaml test_output</div>
</div><!-- fragment --><p>To learn more about how to use the script and its parameters, you can view the help doc by running:</p>
<div class="fragment"><div class="line">uv run resources/utils/aqnwb_utils.py generate-types --help</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The <span class="tt">generate-types</span> command uses <span class="tt">PyNWB</span> for parsing schema. Currently the script does not unload namespaces loaded by default by <span class="tt">PyNWB</span>. I.e., if you see a warning of the form: <div class="fragment"><div class="line">UserWarning: Ignoring cached <span class="keyword">namespace </span>&#39;core&#39; version 2.7.0 because version 2.8.0 is already loaded.</div>
</div><!-- fragment --> it means that the script is actually using the namespace with the version already loaded by PyNWB rather than the requested version. In practice, this is mainly relevant if you are generating classes for the NWB <span class="tt">core</span> and <span class="tt">hdmf-common</span> namespaces.</dd>
<dd>
When generating the test app via the <span class="tt">--generate-test-app</span> option we also need to generate the schema headers files and save them in the <span class="tt">/spec</span> folder.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="implement_registered_type_unit_tests"></a>
Testing RegisteredTypes</h1>
<p>As with all code, it is good practice to create appropriate unit tests to validate that our new class is functioning correctly. In the case of subclasses of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="AQNWB::NWB::RegisteredType">RegisteredType</a> we should pay attention to:</p>
<ul>
<li>Test that the registration is being executed correctly and the type has been registered with the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html" title="AQNWB::NWB::RegisteredType">RegisteredType</a> type registry, e.g. via: <div class="fragment"><div class="line">  SECTION(<span class="stringliteral">&quot;test VectorData is registered as a subclass of RegisteredType&quot;</span>)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">auto</span> registry = <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#ab7e3361637885fe601cc20cb342bf01c">AQNWB::NWB::RegisteredType::getRegistry</a>();</div>
<div class="line">    <span class="comment">// check that hdfm-common::VectorData is in the registry</span></div>
<div class="line">    REQUIRE(registry.find(<span class="stringliteral">&quot;hdmf-common::VectorData&quot;</span>) != registry.end());</div>
<div class="line">  }</div>
</div><!-- fragment --></li>
<li>Test that <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a" title="AQNWB::NWB::RegisteredType::create">RegisteredType::create</a> works as expected for reading our new type, e.g. via: <div class="fragment"><div class="line">    <span class="keyword">auto</span> readDataUntyped = <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">NWB::RegisteredType::create</a>(dataPath, io);</div>
<div class="line">    <span class="keyword">auto</span> readVectorData =</div>
<div class="line">        std::dynamic_pointer_cast&lt;NWB::VectorData&gt;(readDataUntyped);</div>
<div class="line">    REQUIRE(readVectorData != <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --></li>
<li>Test that every read method created via the <a class="el" href="_registered_type_8hpp.html#a9f1005a8dc218dba0592fe5d5aaedb0c" title="DEFINE_ATTRIBUTE_FIELD">DEFINE_ATTRIBUTE_FIELD</a>, <a class="el" href="_registered_type_8hpp.html#aeb21020579ca18f10e64fac9689a7ef6" title="DEFINE_DATASET_FIELD">DEFINE_DATASET_FIELD</a>, <a class="el" href="_registered_type_8hpp.html#aee89c439c94a4a8aa1f42024d063e4c0" title="DEFINE_UNNAMED_REGISTERED_FIELD">DEFINE_UNNAMED_REGISTERED_FIELD</a>, <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a" title="DEFINE_REGISTERED_FIELD">DEFINE_REGISTERED_FIELD</a>, and <a class="el" href="_registered_type_8hpp.html#a3b2c847e459e9e30e65e38897303a9a5" title="DEFINE_REFERENCED_REGISTERED_FIELD">DEFINE_REFERENCED_REGISTERED_FIELD</a> macros is working as expected, e.g. via: <div class="fragment"><div class="line">    <span class="comment">// Read the &quot;namespace&quot; attribute via the readNamespace field</span></div>
<div class="line">    <span class="keyword">auto</span> namespaceData = readVectorData-&gt;readNamespace();</div>
<div class="line">    std::string namespaceStr = namespaceData-&gt;values().data[0];</div>
<div class="line">    REQUIRE(namespaceStr == <span class="stringliteral">&quot;hdmf-common&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Read the &quot;neurodata_type&quot; attribute via the readNeurodataType field</span></div>
<div class="line">    <span class="keyword">auto</span> neurodataTypeData = readVectorData-&gt;readNeurodataType();</div>
<div class="line">    std::string neurodataTypeStr = neurodataTypeData-&gt;values().data[0];</div>
<div class="line">    REQUIRE(neurodataTypeStr == <span class="stringliteral">&quot;VectorData&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Read the &quot;description&quot; attribute via the readDescription field</span></div>
<div class="line">    <span class="keyword">auto</span> descriptionData = readVectorData-&gt;readDescription();</div>
<div class="line">    std::string descriptionStr = descriptionData-&gt;values().data[0];</div>
<div class="line">    REQUIRE(descriptionStr == description);</div>
</div><!-- fragment --></li>
<li>Test that the <span class="tt">initialize</span> method is working as expected (if included). </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="devdocs.html">For Developers</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.1 </li>
  </ul>
</div>
</body>
</html>
