<!-- HTML header for doxygen 1.11.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>aqnwb: Implementing a new Neurodata Type</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow" >
  <td id="projectlogo"><img alt="Logo" src="aqnwb-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">aqnwb<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('registered_type_page.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Implementing a new Neurodata Type</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1">
    <a href="#implement_registered_type">How to Implement a RegisteredType</a>
    <ul>
      <li class="level2">
        <a href="#implement_registered_type_example">Example: Implementing a new type</a>
      </li>
      <li class="level2">
        <a href="#use_the_define_field_macro">DEFINE_FIELD: Creating read methods for datasets and attributes</a>
      </li>
      <li class="level2">
        <a href="#use_the_define_registered_field_macro">DEFINE_REGISTERED_FIELD: Defining read methods for neurodata_type objects</a>
      </li>
      <li class="level2">
        <a href="#use_the_define_referenced_registered_field_macro">DEFINE_REFERENCED_REGISTERED_FIELD: Defining read methods for references to neurodata_type objects</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#using_registered_subclass_with_typename">How to implement a RegisteredType with a custom type name</a>
    <ul>
      <li class="level2">
        <a href="#implement_templated_registered_type">Templated RegisteredType Classes</a>
        <ul>
          <li class="level3">
            <a href="#implement_templated_registered_type_two_class">Using a base class and templated child class</a>
          </li>
          <li class="level3">
            <a href="#implement_templated_registered_type_single_class">Using a single templated class</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#limitations_registered_subclass_with_typename">Limitations of REGISTER_SUBCLASS_WITH_TYPENAME</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#implement_registered_type_unit_tests">Testing RegisteredTypes</a>
  </li>
</ul>
</div>
<div class="textblock"><p>New neurodata_types typically inherit from at least either <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html">Container</a> or <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data.html">Data</a>, or a more specialized type of the two. In any case, all classes that represent a <code>neurodata_type</code> defined in the schema should be implemented as a subtype of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a>. Here we focus on how to implement new subclasses of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a>. If you want to learn more about the how <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> manages types and implements data read then please see <a class="el" href="read_design_page.html">Implementation of data read</a>.</p>
<h1><a class="anchor" id="implement_registered_type"></a>
How to Implement a RegisteredType</h1>
<p>To implement a subclass of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a>, follow these steps:</p>
<ol type="1">
<li>Include the <code><a class="el" href="_registered_type_8hpp.html">RegisteredType.hpp</a></code> header file in your subclass header file (or the header of your more specific parent class that inherits from <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a>). <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_registered_type_8hpp.html">nwb/RegisteredType.hpp</a>&quot;</span></div>
<div class="ttc" id="a_registered_type_8hpp_html"><div class="ttname"><a href="_registered_type_8hpp.html">RegisteredType.hpp</a></div></div>
</div><!-- fragment --></li>
<li>Define your subclass by inheriting from <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> (or one of its child classes). Ensure that your subclass implements a constructor with the arguments <code>(const std::string&amp; path, std::shared_ptr&lt;IO::BaseIO&gt; io)</code>, as the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">RegisteredType::create</a> method expects this constructor signature. <div class="fragment"><div class="line"><span class="keyword">class </span>MySubClass : <span class="keyword">public</span> <a class="code hl_class" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">AQNWB::NWB::RegisteredType</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MySubClass(<span class="keyword">const</span> std::string&amp; path, std::shared_ptr&lt;IO::BaseIO&gt; io)</div>
<div class="line">        : RegisteredType(path, io) {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Implement any additional methods or overrides here</span></div>
<div class="line">};</div>
<div class="ttc" id="aclass_a_q_n_w_b_1_1_n_w_b_1_1_registered_type_html"><div class="ttname"><a href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">AQNWB::NWB::RegisteredType</a></div><div class="ttdoc">Base class for types defined in the NWB schema.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:48</div></div>
</div><!-- fragment --></li>
<li>Use the <a class="el" href="_registered_type_8hpp.html#a9c1f79aa46baaf33d1bf885cf7484aa1">REGISTER_SUBCLASS</a> macro to prepare your subclass for registration with the class registry defined by <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a>. This should usually appear in the header (<code>hpp</code>) file as part of the class definition: <div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#a9c1f79aa46baaf33d1bf885cf7484aa1">REGISTER_SUBCLASS</a>(MySubClass, <span class="stringliteral">&quot;my-namespace&quot;</span>)</div>
<div class="ttc" id="a_registered_type_8hpp_html_a9c1f79aa46baaf33d1bf885cf7484aa1"><div class="ttname"><a href="_registered_type_8hpp.html#a9c1f79aa46baaf33d1bf885cf7484aa1">REGISTER_SUBCLASS</a></div><div class="ttdeci">#define REGISTER_SUBCLASS(T, NAMESPACE)</div><div class="ttdoc">Macro to register a subclass with the RegisteredType class registry.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:368</div></div>
</div><!-- fragment --></li>
<li>In the corresponding source (<code>cpp</code>) file, initialize the static member to trigger the registration using the <a class="el" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a> macro: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;MySubClass.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize the static member to trigger registration</span></div>
<div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a>(MySubClass)</div>
<div class="ttc" id="a_registered_type_8hpp_html_a54ea7671d2bcf5bae392b8ba1824961e"><div class="ttname"><a href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a></div><div class="ttdeci">#define REGISTER_SUBCLASS_IMPL(T)</div><div class="ttdoc">Macro to initialize the static member registered_ to trigger registration.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:380</div></div>
</div><!-- fragment --></li>
<li>To define getter methods for lazy read access to datasets and attributes that belong to our type, we can use the <a class="el" href="_registered_type_8hpp.html#acd3c876a1c357333cd4a8ff27300ee08">DEFINE_FIELD</a> macro. This macro creates a standard method for retrieving a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a> for lazy reading for the field: <div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#acd3c876a1c357333cd4a8ff27300ee08">DEFINE_FIELD</a>(getData, DatasetField, <span class="keywordtype">float</span>, <span class="stringliteral">&quot;data&quot;</span>, The main data)</div>
<div class="ttc" id="a_registered_type_8hpp_html_acd3c876a1c357333cd4a8ff27300ee08"><div class="ttname"><a href="_registered_type_8hpp.html#acd3c876a1c357333cd4a8ff27300ee08">DEFINE_FIELD</a></div><div class="ttdeci">#define DEFINE_FIELD(name, storageObjectType, default_type, fieldPath, description)</div><div class="ttdoc">Defines a lazy-loaded field accessor function.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:402</div></div>
</div><!-- fragment --></li>
<li>Similarly, we use the <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a> macro to define getter methods for other <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> objects that we own, such as a <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrode_table.html">ElectrodeTable</a> that owns predefined <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> columns: <div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a>(readGroupNameColumn, VectorData&lt;std::string&gt;, <span class="stringliteral">&quot;group_name&quot;</span>, <span class="stringliteral">&quot;the name of the ElectrodeGroup&quot;</span>)</div>
<div class="ttc" id="a_registered_type_8hpp_html_af374245a4f6d5a00540e9fdba52a652a"><div class="ttname"><a href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a></div><div class="ttdeci">#define DEFINE_REGISTERED_FIELD(name, registeredType, fieldPath, description)</div><div class="ttdoc">Defines a lazy-loaded accessor function for reading fields that are RegisteredTypes.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:434</div></div>
</div><!-- fragment --></li>
<li>When inheriting from the more specific <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_container.html">Container</a> or <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data.html">Data</a> types, then we will typically also need to implement an <code>initialize</code> method, which is responsible for creating the relevant Groups, Datasets, and Attributes in the file for data write. Remember to also call the <code>initialize</code> method of the parent class.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd><code>DEFINE_FIELD</code> and <code>DEFINE_REGISTERED_FIELD</code> create templated, non-virtual read functions. This means if we want to "redefine" a field in a child class by calling <code>DEFINE_FIELD</code> again, then the function will be "hidden" instead of "override". This is important to remember when casting a pointer to a base type, as in this case the implementation from the base type will be used since the function created by <code>DEFINE_FIELD</code> is not virtual.</dd></dl>
<h2><a class="anchor" id="implement_registered_type_example"></a>
Example: Implementing a new type</h2>
<p><em>MySubClass.hpp</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_registered_type_8hpp.html">RegisteredType.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MySubClass : <span class="keyword">public</span> <a class="code hl_class" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">AQNWB::NWB::RegisteredType</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MySubClass(<span class="keyword">const</span> std::string&amp; path, std::shared_ptr&lt;IO::BaseIO&gt; io)</div>
<div class="line">        : RegisteredType(path, io) {}</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="_registered_type_8hpp.html#acd3c876a1c357333cd4a8ff27300ee08">DEFINE_FIELD</a>(getData, DatasetField, <span class="keywordtype">float</span>, <span class="stringliteral">&quot;data&quot;</span>, The main data)</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="_registered_type_8hpp.html#a9c1f79aa46baaf33d1bf885cf7484aa1">REGISTER_SUBCLASS</a>(MySubClass, <span class="stringliteral">&quot;my-namespace&quot;</span>)</div>
<div class="line">};</div>
</div><!-- fragment --><p><em>MySubClass.cpp</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;MySubClass.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize the static member to trigger registration</span></div>
<div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a>(MySubClass)</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>To ensure proper function on read, the name of the class should match the name of the <code>neurodata_type</code> as defined in the schema. Similarly, "my-namespace" should match the name of the namespace in the schema (e.g., "core", "hdmf-common"). In this way we can look up the corresponding class for an object in a file based on the <code>neurodata_type</code> and <code>namespace</code> attributes stored in the file. A special version of the <code>REGISTER_SUBCLASS</code> macro, called <code>REGISTER_SUBCLASS_WITH_TYPENAME</code>, allows setting the typename explicitly as a third argument. This is for the <b>special case</b> where the name of the class cannot be the same as the name of the type (e.g,. when implementing a class that doesn't have an assigned type in the schema or a class that requires template parameters that are not part of the type name). See <a class="el" href="#using_registered_subclass_with_typename">How to implement a RegisteredType with a custom type name</a> for details.</dd></dl>
<h2><a class="anchor" id="use_the_define_field_macro"></a>
DEFINE_FIELD: Creating read methods for datasets and attributes</h2>
<p>The <a class="el" href="_registered_type_8hpp.html#acd3c876a1c357333cd4a8ff27300ee08">DEFINE_FIELD</a> macro takes the following main inputs:</p>
<ul>
<li><code>name</code>: The name of the function to generate.</li>
<li><code>storageObjectType</code> : One of either <a class="el" href="namespace_a_q_n_w_b_1_1_n_w_b.html#acfd896b65a7f56c25b3730a6e8dc80ca">DatasetField</a> or <a class="el" href="namespace_a_q_n_w_b_1_1_n_w_b.html#a4a7413b10eb1a838f0349fc59b5a333f">AttributeField</a> to define the type of storage object used to store the field.</li>
<li><code>default_type</code> : The default data type to use. If not known, we can use <code>std::any</code>.</li>
<li><code>fieldPath</code> : Literal string with the relative path to the field within the schema of the respective neurodata_type. This is automatically being expanded at runtime to the full path.</li>
<li><code>description</code> : Description of the field to include in the docstring for the docs</li>
</ul>
<p>All of these inputs are required. A typical example will look as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#acd3c876a1c357333cd4a8ff27300ee08">DEFINE_FIELD</a>(getData, DatasetField, <span class="keywordtype">float</span>, <span class="stringliteral">&quot;data&quot;</span>, The main data)</div>
</div><!-- fragment --><p>The compiler will then expand this definition to create a new method (here called <code>getData</code>) that will return a <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a> for lazy reading for the field. The corresponding expanded function will look something like:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VTYPE = <span class="keywordtype">float</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> std::unique_ptr&lt;IO::ReadDataWrapper&lt;DatasetField, VTYPE&gt;&gt; getData()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unique&lt;IO::ReadDataWrapper&lt;DatasetField, VTYPE&gt;&gt;(</div>
<div class="line">         m_io,</div>
<div class="line">         <a class="code hl_function" href="namespace_a_q_n_w_b.html#a31983dbaaa85c2e355b9687fc0ef1881">AQNWB::mergePaths</a>(m_path, fieldPath));</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_a_q_n_w_b_html_a31983dbaaa85c2e355b9687fc0ef1881"><div class="ttname"><a href="namespace_a_q_n_w_b.html#a31983dbaaa85c2e355b9687fc0ef1881">AQNWB::mergePaths</a></div><div class="ttdeci">static std::string mergePaths(const std::string &amp;path1, const std::string &amp;path2)</div><div class="ttdoc">Merge two paths into a single path, handling extra trailing and starting &quot;/&quot;.</div><div class="ttdef"><b>Definition</b> Utils.hpp:112</div></div>
</div><!-- fragment --><p>See <a class="el" href="read_page.html">Reading data</a> for an example of how to use such methods (e.g., <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_time_series.html#a8a43d4c249f6865ee4f77c58a91b6546">TimeSeries::readData</a> ) for reading data fields from a file.</p>
<h2><a class="anchor" id="use_the_define_registered_field_macro"></a>
DEFINE_REGISTERED_FIELD: Defining read methods for neurodata_type objects</h2>
<p>The <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a> macro works much like the <a class="el" href="_registered_type_8hpp.html#acd3c876a1c357333cd4a8ff27300ee08">DEFINE_FIELD</a> macro macro but returns instances of specific subtypes of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a>, rather than <a class="el" href="class_a_q_n_w_b_1_1_i_o_1_1_read_data_wrapper.html">ReadDataWrapper</a>. As such the main inputs for <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a> are as follows:</p>
<ul>
<li><code>name</code>: The name of the function to generate.</li>
<li><code>registeredType</code> : The specific subclass of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> to use</li>
<li><code>fieldPath</code> : Literal string with the relative path to the field within the schema of the respective neurodata_type. This is automatically being expanded at runtime to the full path.</li>
<li><code>description</code> : Description of the field to include in the docstring for the docs</li>
</ul>
<p>All of these inputs are required. A typical example will look as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a>(getMyTable, DynamicTable, <span class="stringliteral">&quot;my_table&quot;</span>, My data table)</div>
</div><!-- fragment --><p>The compiler will then expand this definition to create a new read method, in this called <code>getMyTable</code> that returns a <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_dynamic_table.html">DynamicTable</a> for reading "my_table". The corresponding expanded function will look something like:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RTYPE = DynamicTable&gt; </div>
<div class="line"><span class="keyword">inline</span> std::shared_ptr&lt;RTYPE&gt; getMyTable()<span class="keyword"> const </span></div>
<div class="line"><span class="keyword"></span>{ </div>
<div class="line">  std::string objectPath = <a class="code hl_function" href="namespace_a_q_n_w_b.html#a31983dbaaa85c2e355b9687fc0ef1881">AQNWB::mergePaths</a>(m_path, fieldPath); </div>
<div class="line">  <span class="keywordflow">if</span> (m_io-&gt;objectExists(objectPath)) { </div>
<div class="line">    <span class="keywordflow">return</span> RegisteredType::create&lt;RTYPE&gt;(objectPath, m_io); </div>
<div class="line">  } </div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">nullptr</span>; </div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="use_the_define_referenced_registered_field_macro"></a>
DEFINE_REFERENCED_REGISTERED_FIELD: Defining read methods for references to neurodata_type objects</h2>
<p>The <a class="el" href="_registered_type_8hpp.html#a3b2c847e459e9e30e65e38897303a9a5">DEFINE_REFERENCED_REGISTERED_FIELD</a> macro works exactly like the <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a> macro, but the underlying data is an attribute that stores a reference to an instances of a specific subtype of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> rather than the instance of the object directly. I.e., <code>fieldPath</code> here is the relative path to the attribute that stores the reference, rather than the relative path of the object itself. The generated read method then resolves the reference first and then returns the instance of the object that is being referenced.</p>
<h1><a class="anchor" id="using_registered_subclass_with_typename"></a>
How to implement a RegisteredType with a custom type name</h1>
<p>In most cases, the name of our <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> class should be the same as the <code>neurodata_type</code>. However, in some cases this may not be possible. In this case, we need to use <a class="el" href="_registered_type_8hpp.html#a34a1efef99cdbc58adaec1c8fcf5d250">REGISTER_SUBCLASS_WITH_TYPENAME</a> macro instead of <a class="el" href="_registered_type_8hpp.html#a9c1f79aa46baaf33d1bf885cf7484aa1">REGISTER_SUBCLASS</a>. E.g. using <code>REGISTER_SUBCLASS_WITH_TYPENAME(ElectrodeTable, "core", "DynamicTable")</code>, the class will be registered in the registry, under the <code>core::ElectrodesTable</code> key, but with "DynamicTable" as the typename value and the <code>ElectrodesTable.getTypeName</code> automatic override returning the indicated typename instead of the classname. The main use cases for this are to implement:</p>
<ol type="1">
<li>Templated child classes of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> where the template parameters required in C++ are not part of the <code>neurodata_type</code> name in NWB. An example is <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> which uses a template parameter to define the data type of data that is manages.</li>
<li>A class for a modified type that does not have its own <code>neurodata_type</code> in the NWB schema. An example is <code>ElectrodesTable</code> in NWB &lt;v2.7, which did not have an assigned <code>neurodata_type</code>, but was implemented as a regular <code>DynamicTable</code>. To allow us to define a class <code>ElectrodeTable</code> to help with writing the table we can then use <code>REGISTER_SUBCLASS_WITH_TYPENAME(ElectrodeTable, "core", "DynamicTable")</code> in the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrode_table.html">ElectrodeTable</a> class. This ensures that the <code>neurodata_type</code> attribute is set correctly to <code>DynamicTable</code> on write instead of <code>ElectrodeTable</code>.</li>
</ol>
<h2><a class="anchor" id="implement_templated_registered_type"></a>
Templated RegisteredType Classes</h2>
<p>In some cases, we may want to use templated classes to handle data types in a type-safe way. AqNWB uses templated neurodata_type classes for <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a> and <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data_typed.html">DataTyped&lt;DTYPE&gt;</a> as these classes manage a particular dataset. Using this approach, we specify the data types to use with the class directly as part of <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a> macro so that the user doesn't need to manually specify the data type for read. To implement the use of templated classes for read, we can take two main approaches by either <a class="el" href="#implement_templated_registered_type_two_class">Using a base class and templated child class</a> or <a class="el" href="#implement_templated_registered_type_single_class">Using a single templated class</a> .</p>
<h3><a class="anchor" id="implement_templated_registered_type_two_class"></a>
Using a base class and templated child class</h3>
<p>For the <code>VectorData</code> type (and <code>Data</code> type), AqNWB implements the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> class, which exposes the data as <code>std::any</code> via the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_data.html#afe2d2e01b7ade2a1089e8cc051d7f49e">VectorData::readData</a> method for read. To simplify read, <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a> inherits from <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> but allows the data type to be fixed at compile time via the class template, such that <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;::readData</a> can expose the data with the type already set at compile time.</p>
<p>Using this approach where we have a non-templated base class <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> with a templated child class <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a>, only the base type <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> is being registered with the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> registry via the <a class="el" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a> macro. This is because on read <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">RegisteredType::create</a> can only determine the base type based on the <code>namespace</code> and <code>neurodata_type</code> attribute stored in the file.</p>
<p>However, even though <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a> is not being added to the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> registry, it does inherit from <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> and as such, a user may chose to use <br  />
 <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a> anywhere <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> is being used. In particular, by using <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a> as part of the <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a> macro, we can set the data type for read at compile time, simplifying read.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>std::unique_ptr&lt;..&gt;</code> template type is not covariant, i.e., <code>std::unique_ptr&lt;DerivedClass&gt;</code> does not automatically convert to <code>std::unique_ptr&lt;BaseClass&gt;</code>. I.e., while <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a> can be used anywhere <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> is being used, when using <code>std::unique_ptr&lt;..&gt;</code> we cannot rely on the compiler to automatically upcast for us, but we will need to explicitly release and upcast <code>std::unique_ptr&lt;VectorDataTyped&lt;DTYPE&gt;</code> if <code>std::unique_ptr&lt;VectorData&gt;</code> is required. Since defining the <code>DTYPE</code> is primarily useful for read, we therefore typically use <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a> on read while using <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> otherwise.</dd></dl>
<h3><a class="anchor" id="implement_templated_registered_type_single_class"></a>
Using a single templated class</h3>
<p>Alternatively to the above approach, where we have two classes <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> and <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data_typed.html">VectorDataTyped&lt;DTYPE&gt;</a>, we could also just use a single templated class <code>VectorData&lt;DTYPE&gt;</code> and then register only the generic version <code>VectorData&lt;std::any&gt;</code> with the type registry via the <a class="el" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a> macro. However, there are a few additional considerations to keep in mind with this approach, which is why in AqNWB we generally recommend the above approach using two classes instead.</p>
<ol type="1">
<li><b>Preparing for Registration</b> <div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#a34a1efef99cdbc58adaec1c8fcf5d250">REGISTER_SUBCLASS_WITH_TYPENAME</a>(VectorData&lt;DTYPE&gt;, <span class="stringliteral">&quot;hdmf-common&quot;</span>, <span class="stringliteral">&quot;VectorData&quot;</span>)</div>
<div class="ttc" id="a_registered_type_8hpp_html_a34a1efef99cdbc58adaec1c8fcf5d250"><div class="ttname"><a href="_registered_type_8hpp.html#a34a1efef99cdbc58adaec1c8fcf5d250">REGISTER_SUBCLASS_WITH_TYPENAME</a></div><div class="ttdeci">#define REGISTER_SUBCLASS_WITH_TYPENAME(T, NAMESPACE, TYPENAME)</div><div class="ttdoc">Macro to register a subclass with the RegisteredType class registry.</div><div class="ttdef"><b>Definition</b> RegisteredType.hpp:336</div></div>
</div><!-- fragment --> We use <code>VectorData&lt;DTYPE&gt;</code> with the template parameter because we want to prepare all possible instantiations (e.g., <code>VectorData&lt;int&gt;</code>, <code>VectorData&lt;double&gt;</code>, etc.) for registration</li>
<li><p class="startli"><b>Actual Registration</b> </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt; <a class="code hl_define" href="_registered_type_8hpp.html#a54ea7671d2bcf5bae392b8ba1824961e">REGISTER_SUBCLASS_IMPL</a>(VectorData&lt;std::any&gt;)</div>
</div><!-- fragment --><p> This performs the actual registration in the type system. We only register the most generic type (<code>std::any</code>) because in the NWB file, we only store <code>namespace=hdmf-common</code> and <code>neurodata_type=VectorData</code> (i.e., the NWB file doesn't have the notion of templates) and the generic type serves as the default registration. Note, that we need to use <code>template&lt;&gt;</code> as this is a template specialization.</p>
<dl class="section note"><dt>Note</dt><dd>In C++ the implementation of templated classes is not easily separate into <code>.hpp</code> and <code>.cpp</code> files. However, the <code>template&lt;&gt; REGISTER_SUBCLASS_IMPL(VectorData&lt;std::any&gt;)</code> cannot be part of the <code>.hpp</code> file where the class is being defined. Also, the compiler will only include the call if the <code>VectorData&lt;std::any&gt;</code> is actually being instantiated. A simple instantiation of <code>template class VectorData&lt;std::any&gt;;</code> in the <code><a class="el" href="_vector_data_8cpp.html">VectorData.cpp</a></code> may not be sufficient for this. As a work-around, the <code>template&lt;&gt; REGISTER_SUBCLASS_IMPL(VectorData&lt;std::any&gt;)</code> may need to be placed in a different <code>.cpp</code> file that we know is going to be built (the need for this workaround is one reason why we recommend the two-class approach in AqNWB). <br  />
</dd></dl>
</li>
<li><b>Template Instantiation</b> In <code><a class="el" href="_vector_data_8cpp.html">VectorData.cpp</a></code>: <div class="fragment"><div class="line"><span class="keyword">template</span> <span class="keyword">class </span>VectorData&lt;std::any&gt;;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>VectorData&lt;uint8_t&gt;;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>VectorData&lt;int16_t&gt;;</div>
<div class="line"><span class="comment">// ... other types ...</span></div>
</div><!-- fragment --> This is an optimization that pre-instantiates all the types we expect to use and makes these instantiations part of the AqNWB library. This allows users to use these types directly and prevents the compiler from having to generate these as part of the user's code build.</li>
</ol>
<h2><a class="anchor" id="limitations_registered_subclass_with_typename"></a>
Limitations of REGISTER_SUBCLASS_WITH_TYPENAME</h2>
<p>The main limitaton of the <a class="el" href="_registered_type_8hpp.html#a34a1efef99cdbc58adaec1c8fcf5d250">REGISTER_SUBCLASS_WITH_TYPENAME</a> approach is that on read, AqNWB will use the default class associated with the <code>neurodata_type</code>. E.g., in the case of the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrode_table.html">ElectrodeTable</a> class, by default the regular <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_dynamic_table.html">DynamicTable</a> class will be used since that is what the schema is indicating to use. Similarly, for <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_vector_data.html">VectorData</a> the default <code>VectorData&lt;std::any&gt;</code> will be used on read. To support reading using the more specific types, we can use the <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a> macro to define read methods that will return the approbriate type, e.g.:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a>(readElectrodeTable,</div>
<div class="line">                        ElectrodeTable,</div>
<div class="line">                        ElectrodeTable::electrodeTablePath,</div>
<div class="line">                        <span class="stringliteral">&quot;table with the extracellular electrodes&quot;</span>)</div>
</div><!-- fragment --><p>in <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_n_w_b_file.html">NWBFile</a> to read the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrode_table.html">ElectrodeTable</a>, or</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a>(</div>
<div class="line">    readGroupNameColumn,</div>
<div class="line">    VectorData&lt;std::string&gt;,</div>
<div class="line">    <span class="stringliteral">&quot;group_name&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;the name of the ElectrodeGroup this electrode is a part of&quot;</span>)</div>
</div><!-- fragment --><p>in the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_electrode_table.html">ElectrodeTable</a> to read the <code>group_name</code> column as <code>VectorData&lt;std::string&gt;</code> with the data type already specified as <code>std::string</code> at compile time.</p>
<h1><a class="anchor" id="implement_registered_type_unit_tests"></a>
Testing RegisteredTypes</h1>
<p>As with all code, it is good practice to create appropriate unit tests to validate that our new class is functioning correctly. In the case of subclasses of <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> we should pay attention to:</p>
<ul>
<li>Test that the registration is being executed correctly and the type has been registered with the <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html">RegisteredType</a> type registry, e.g. via: <div class="fragment"><div class="line">  SECTION(<span class="stringliteral">&quot;test VectorData is registered as a subclass of RegisteredType&quot;</span>)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">auto</span> registry = <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#ab7e3361637885fe601cc20cb342bf01c">AQNWB::NWB::RegisteredType::getRegistry</a>();</div>
<div class="line">    <span class="comment">// check that hdfm-common::VectorData is in the registry</span></div>
<div class="line">    REQUIRE(registry.find(<span class="stringliteral">&quot;hdmf-common::VectorData&quot;</span>) != registry.end());</div>
<div class="line">  }</div>
</div><!-- fragment --></li>
<li>Test that <a class="el" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">RegisteredType::create</a> works as expected for reading our new type, e.g. via: <div class="fragment"><div class="line">    <span class="keyword">auto</span> readDataUntyped = <a class="code hl_function" href="class_a_q_n_w_b_1_1_n_w_b_1_1_registered_type.html#a6f7d3d6d30763215c823452176ed876a">NWB::RegisteredType::create</a>(dataPath, io);</div>
<div class="line">    <span class="keyword">auto</span> readVectorData =</div>
<div class="line">        std::dynamic_pointer_cast&lt;NWB::VectorData&gt;(readDataUntyped);</div>
<div class="line">    REQUIRE(readVectorData != <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --></li>
<li>Test that every read method created via the <a class="el" href="_registered_type_8hpp.html#acd3c876a1c357333cd4a8ff27300ee08">DEFINE_FIELD</a> and <a class="el" href="_registered_type_8hpp.html#af374245a4f6d5a00540e9fdba52a652a">DEFINE_REGISTERED_FIELD</a> macros is working as expected, e.g. via: <div class="fragment"><div class="line">    <span class="comment">// Read the &quot;namespace&quot; attribute via the readNamespace field</span></div>
<div class="line">    <span class="keyword">auto</span> namespaceData = readVectorData-&gt;readNamespace();</div>
<div class="line">    std::string namespaceStr = namespaceData-&gt;values().data[0];</div>
<div class="line">    REQUIRE(namespaceStr == <span class="stringliteral">&quot;hdmf-common&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Read the &quot;neurodata_type&quot; attribute via the readNeurodataType field</span></div>
<div class="line">    <span class="keyword">auto</span> neurodataTypeData = readVectorData-&gt;readNeurodataType();</div>
<div class="line">    std::string neurodataTypeStr = neurodataTypeData-&gt;values().data[0];</div>
<div class="line">    REQUIRE(neurodataTypeStr == <span class="stringliteral">&quot;VectorData&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Read the &quot;description&quot; attribute via the readDescription field</span></div>
<div class="line">    <span class="keyword">auto</span> descriptionData = readVectorData-&gt;readDescription();</div>
<div class="line">    std::string descriptionStr = descriptionData-&gt;values().data[0];</div>
<div class="line">    REQUIRE(descriptionStr == description);</div>
</div><!-- fragment --></li>
<li>Test that the <code>initialize</code> method is working as expected (if included). </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="devdocs.html">For Developers</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
